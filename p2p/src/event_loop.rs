//! The Grease P2P network event loop.
//!
//! See [`EventLoop`] for more information.

use crate::behaviour::{ConnectionBehavior, ConnectionBehaviorEvent};
use crate::errors::RemoteServerError;
use futures::channel::{mpsc, oneshot};
use futures::{SinkExt, StreamExt};
use libp2p::core::transport::ListenerId;
use libp2p::core::ConnectedPoint;
use libp2p::identify::Event as IdentifyEvent;
use libp2p::multiaddr::Protocol;
use libp2p::request_response::{self, ResponseChannel};
use libp2p::request_response::{InboundFailure, InboundRequestId, Message, OutboundFailure, OutboundRequestId};
use libp2p::swarm::{ConnectionError, ConnectionId, DialError, ListenError, SwarmEvent};
use libp2p::{noise, Multiaddr, PeerId, Swarm, TransportError};
use log::*;
use serde::de::DeserializeOwned;
use serde::Serialize;
use std::any::Any;
use std::collections::{hash_map, HashMap, HashSet};
use std::convert::Infallible;
use std::fmt::{Debug, Display};
use std::io;
use std::num::NonZeroU32;
use std::sync::atomic::AtomicUsize;
use std::time::Duration;
use thiserror::Error;

const RUNNING: usize = 0;

const SHUTDOWN: usize = 2;
const SHUTTING_DOWN: usize = 1;

/// The main event loop handler for Grease p2p connections
///
/// The `EventLoop` handles network events and commands for the Grease p2p network communications. It responds to
/// events that are generated by the connection as well as commands that are received from remote peers.
///
/// The `EventLoop` ensures that network events are appropriately handled and commands are executed, maintaining the
/// state and connections of the p2p network.
///
/// **Important**: The `EventLoop` is only a data broker. It does not do any business or application logic itself.
///
/// ## Handling outbound requests to peers
///
/// If, in response to a command (e.g. via a call from [`crate::network_client::Client`], the event loop needs to
/// delegate a task to a peer on the network, the event loop:
///  * creates a new Request record via `self.swarm.behaviour_mut().json.send_request(&peer_id, cmd)`
///  * and stores the resulting request_id and one-shot sender channel in the appropriate data structure.
///    It can then return.
///
/// When the appropriate response is received from a peer, via a `Response` event, the event loop can then
/// * retrieve the stored return channel by using the request_id as a key,
/// * send the response via the one-shot sender channel
///
/// ## Handling inbound requests from peers
///
/// An inbound request will hit the event loop as a [`ReqResEvent::Message`] event. The event loop will then convert
/// this event into an [`PeerConnectionEvent::InboundRequest`] event, passing the request specifics _as well as_ the
/// network `ResponseChannel` instance to the application layer. `ResponseChannel` is a channel that libp2p uses to
/// track the response to a request.
///
/// The application layer carries out all the business logic. Once it is done, it calls a suitable method on the
/// [`Client`] instance, which will handle the creation of the correct [`ClientCommand`], packaging the result
/// data and the `ResponseChannel` instance, and sending it to the event loop.
pub struct EventLoop<Req, Resp>
where
    Req: DeserializeOwned + Serialize + Send + 'static,
    Resp: DeserializeOwned + Serialize + Send + 'static,
{
    swarm: Swarm<ConnectionBehavior<Req, Resp>>,
    command_receiver: mpsc::Receiver<ClientCommand<Req, Resp>>,
    request_forwarder: mpsc::Sender<RemoteRequest<Req, Resp>>,
    pending_dial: HashMap<PeerId, oneshot::Sender<Result<(), PeerConnectionError>>>,
    pending_shutdown: Option<oneshot::Sender<bool>>,
    status: AtomicUsize,
    connections: HashSet<ConnectionId>,
    pending_requests: HashMap<OutboundRequestId, oneshot::Sender<Result<Resp, RemoteServerError>>>,
}

impl<Req, Resp> EventLoop<Req, Resp>
where
    Req: DeserializeOwned + Serialize + Send + 'static,
    Resp: Display + DeserializeOwned + Serialize + Send + 'static,
{
    pub fn new(
        swarm: Swarm<ConnectionBehavior<Req, Resp>>,
        command_receiver: mpsc::Receiver<ClientCommand<Req, Resp>>,
        request_forwarder: mpsc::Sender<RemoteRequest<Req, Resp>>,
    ) -> Self {
        Self {
            swarm,
            command_receiver,
            request_forwarder,
            pending_dial: HashMap::default(),
            pending_shutdown: None,
            status: AtomicUsize::new(RUNNING),
            connections: Default::default(),
            pending_requests: HashMap::new(),
        }
    }

    pub async fn run(mut self) {
        loop {
            tokio::select! {
                event = self.swarm.select_next_some() => self.handle_network_event(event).await,
                command = self.command_receiver.next() => match command {
                    Some(c) => self.handle_command(c).await,
                    // Command channel closed, thus shutting down the network event loop.
                    None =>  return,
                },
            }
            if self.status.load(std::sync::atomic::Ordering::SeqCst) == SHUTDOWN {
                info!("Event loop has shutdown gracefully.");
                if let Some(sender) = self.pending_shutdown.take() {
                    let _ = sender.send(true);
                }
                break;
            }
        }
    }

    pub fn is_running(&self) -> bool {
        self.status.load(std::sync::atomic::Ordering::SeqCst) == RUNNING
    }

    /// Network event handler.
    ///
    /// This function is called whenever a new event is received from the network.
    /// Both general network events ([SwarmEvent]) and specific events triggered by the payment channel state machine
    /// ([ReqResEvent]) are handled here.
    async fn handle_network_event(&mut self, event: SwarmEvent<ConnectionBehaviorEvent<Req, Resp>>) {
        match event {
            SwarmEvent::Behaviour(event) => {
                self.behaviour_event(event).await;
            }
            SwarmEvent::NewListenAddr { listener_id, address } => {
                self.on_new_listen_addr(listener_id, address);
            }
            SwarmEvent::IncomingConnection { connection_id, local_addr, send_back_addr } => {
                self.on_incoming_connection(connection_id, local_addr, send_back_addr);
            }
            SwarmEvent::ConnectionEstablished {
                peer_id,
                connection_id,
                endpoint,
                num_established,
                concurrent_dial_errors,
                established_in,
            } => {
                self.on_connection_established(
                    peer_id,
                    connection_id,
                    endpoint,
                    num_established,
                    concurrent_dial_errors,
                    established_in,
                );
            }
            SwarmEvent::ConnectionClosed { peer_id, connection_id, endpoint, num_established, cause } => {
                self.on_connection_closed(peer_id, connection_id, endpoint, num_established, cause);
            }
            SwarmEvent::OutgoingConnectionError { peer_id, connection_id, error } => {
                self.on_outgoing_connection_error(peer_id, connection_id, error);
            }
            SwarmEvent::IncomingConnectionError { connection_id, local_addr, send_back_addr, error } => {
                self.on_incoming_connection_error(connection_id, local_addr, send_back_addr, error);
            }
            SwarmEvent::Dialing { peer_id, connection_id } => {
                self.on_dialing_event(peer_id, connection_id);
            }
            SwarmEvent::ExpiredListenAddr { listener_id, address } => {
                self.on_expired_listen_addr(listener_id, address);
            }
            SwarmEvent::ListenerClosed { listener_id, addresses, reason } => {
                self.on_listener_closed(listener_id, addresses, reason);
            }
            SwarmEvent::ListenerError { listener_id, error } => {
                self.on_non_fatal_listener_error(listener_id, error);
            }
            SwarmEvent::NewExternalAddrCandidate { address } => {
                trace!("EVENT: New external address candidate: {address}");
            }
            SwarmEvent::ExternalAddrConfirmed { address } => {
                trace!("EVENT: External address confirmed: {address}");
            }
            SwarmEvent::ExternalAddrExpired { address } => {
                trace!("EVENT: External address expired: {address}");
            }
            SwarmEvent::NewExternalAddrOfPeer { peer_id, address } => {
                trace!("EVENT: New external address of peer: {peer_id} {address}");
            }
            ev => {
                trace!("Unknown and unhandled event: {:?}", ev.type_id());
            }
        }
    }

    async fn behaviour_event(&mut self, event: ConnectionBehaviorEvent<Req, Resp>) {
        match event {
            ConnectionBehaviorEvent::Identify(ev) => self.handle_identify_event(ev).await,
            ConnectionBehaviorEvent::Json(ev) => self.handle_json_event(ev).await,
        }
    }

    async fn handle_json_event(&mut self, event: request_response::Event<Req, Resp>) {
        match event {
            request_response::Event::Message { peer, connection_id, message } => {
                self.on_network_message(peer, connection_id, message).await;
            }
            request_response::Event::InboundFailure { peer, connection_id, request_id, error } => {
                self.on_inbound_failure(peer, connection_id, request_id, error);
            }
            request_response::Event::ResponseSent { peer, connection_id, request_id } => {
                self.on_response_sent(peer, connection_id, request_id);
            }
            request_response::Event::OutboundFailure { peer, connection_id, request_id, error } => {
                self.on_outbound_failure(peer, connection_id, request_id, error);
            }
        }
    }
    /// Respond to a new request or response message from a network peer.
    async fn on_network_message(&mut self, peer: PeerId, connection_id: ConnectionId, message: Message<Req, Resp>) {
        trace!("EVENT: Network message received from {peer}. Connection id: {connection_id}.");
        match message {
            Message::Request { request_id, request, channel } => {
                debug!("Request received. Peer: {peer}. Connection id: {connection_id}. Request id: {request_id}");
                let request = RemoteRequest::new(request, channel);
                if let Err(err) = self.request_forwarder.send(request).await {
                    error!("Failed to forward request to {peer}: {err:?}");
                }
            }
            Message::Response { request_id, response } => {
                trace!("EVENT: Response received. Peer: {peer}. Conn_id: {connection_id}. Req_id: {request_id}");
                // Generally, the response implies that there is a pending request that we need to match to it.
                // So we fetch the pending request and send the response back to the requester.
                self.handle_message_response(request_id, response).await;
            }
        }
    }

    async fn handle_identify_event(&mut self, event: IdentifyEvent) {
        match event {
            IdentifyEvent::Sent { peer_id, .. } => {
                info!("Sent identify info to {peer_id:?}");
            }
            IdentifyEvent::Received { peer_id, info, .. } => {
                info!("Received identify info from {peer_id:?}: {info:?}");
            }
            IdentifyEvent::Error { peer_id, error, connection_id } => {
                error!("Identify error with {peer_id:?} #{connection_id}: {error}");
            }
            IdentifyEvent::Pushed { connection_id, peer_id, info } => {
                info!("Identify info pushed to {peer_id:?} #{connection_id}");
                debug!("Identify info: {info:?}");
            }
        }
    }

    /// Handle a [`GreaseResponse`] response message received from a peer. Usually this entails fetching a `Sender`
    /// channel from the map of pending requests and passing the response through it.
    async fn handle_message_response(&mut self, request_id: OutboundRequestId, response: Resp) {
        match self.pending_requests.remove(&request_id) {
            None => {
                error!("Received response for unknown request. Request id: {request_id}");
                return;
            }
            Some(sender) => {
                if let Err(_res) = sender.send(Ok(response)) {
                    warn!("Failed to send response back to requester. Request id: {request_id}.");
                }
            }
        }
    }

    /// Handle a failed inbound request
    ///
    /// ## Parameters
    /// * `peer` - The peer from whom the request was received.
    /// * `connection_id` - Identifier of the connection that the request was received on.
    /// * `request_id` - The id of the failed request.
    /// * `error` - The error that happened.
    fn on_inbound_failure(
        &mut self,
        peer: PeerId,
        connection_id: ConnectionId,
        request_id: InboundRequestId,
        error: InboundFailure,
    ) {
        warn!("Inbound request failed. Peer: {peer}. Connection id: {connection_id}. Request id: {request_id}. Error: {error}");
    }

    /// This gets called when a response to an inbound request has been sent.
    /// When this event is received, the response has already been flushed on the underlying transport connection.
    ///
    /// ## Parameters
    /// * `peer` - The peer to whom the response was sent.
    /// * `connection_id` - Identifier of the connection that the response was sent on.
    /// * `request_id` - The id of the request for which the response was sent.
    fn on_response_sent(&mut self, peer: PeerId, connection_id: ConnectionId, request_id: InboundRequestId) {
        trace!("EVENT: Response sent. Peer: {peer}. Connection id: {connection_id}. Request id: {request_id}");
    }

    /// Handle a failed connection attempt
    ///
    /// This gets called when an error happened on an outbound connection.
    ///
    /// ## Parameters
    /// * `peer_id` - Identity of the peer that we were trying to connect to, if it is known.
    /// * `connection_id` - Identifier of the connection that failed.
    /// * `error` - the dial error that happened.
    fn on_outgoing_connection_error(&mut self, peer_id: Option<PeerId>, connection_id: ConnectionId, error: DialError) {
        let peer_str = match peer_id {
            Some(peer_id) => peer_id.to_string(),
            None => "[unknown peer]".to_string(),
        };
        warn!("Connection to {peer_str} failed. Connection id: {connection_id}. Error: {error}");
        if let Some(peer_id) = peer_id {
            if let Some(sender) = self.pending_dial.remove(&peer_id) {
                let _ = sender.send(Err(PeerConnectionError::DialError(error)));
            }
        }
    }

    /// Handle a failed incoming connection
    ///
    /// This gets called when an error happened on an inbound connection during its initial handshake.
    /// This can include, for example, an error during the handshake of the encryption layer,
    /// or the connection unexpectedly closed.
    ///
    /// ## Parameters
    /// * `connection_id` - Identifier of the connection that failed.
    /// * `local_addr` - Local address that we were trying to listen on. This address has been earlier reported with
    ///   a [SwarmEvent::NewListenAddr] event.
    /// * `send_back_addr` - Address of the peer that we were trying to connect to.
    /// * `error` - the dial error that happened.
    fn on_incoming_connection_error(
        &mut self,
        connection_id: ConnectionId,
        local_addr: Multiaddr,
        send_back_addr: Multiaddr,
        error: ListenError,
    ) {
        warn!("Incoming connection failed. Connection id: {connection_id}. Local address: {local_addr}. Send back address: {send_back_addr}. Error: {error}");
    }

    /// Respond to a new connection
    ///
    /// This gets called when a connection to the given peer has been opened.
    ///
    /// ## Arguments
    /// * `peer_id` - Identity of the peer that we have connected to
    /// * `connection_id` - Identifier of the connection
    /// * `endpoint` - Endpoint of the connection that has been opened.
    /// * `num_established` - Number of established connections to this peer, including the one that has just been opened.
    /// * `concurrent_dial_errors` - [`Some`] when the new connection is an outgoing connection. Addresses are dialed
    ///   concurrently. Contains the addresses and errors of dial attempts that failed before the one successful dial.
    fn on_connection_established(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        endpoint: ConnectedPoint,
        num_established: NonZeroU32,
        concurrent_dial_errors: Option<Vec<(Multiaddr, TransportError<io::Error>)>>,
        established_in: Duration,
    ) {
        let ep_type = match endpoint {
            ConnectedPoint::Dialer { .. } => "dialer",
            ConnectedPoint::Listener { .. } => "listener",
        };
        info!("Connection to {peer_id} established as {ep_type} in {:0.3}s. Connection id: {connection_id}. {num_established} connections are active.", established_in.as_secs_f64());
        self.connections.insert(connection_id);
        if let Some(errs) = concurrent_dial_errors {
            if !errs.is_empty() {
                warn!("{} concurrent dial errors were reported for {peer_id}.", errs.len());
                errs.into_iter().for_each(|(addr, err)| {
                    debug!("Concurrent dial error for {peer_id}. Address: {addr}. Error: {err}");
                });
            }
        }
        if endpoint.is_dialer() {
            trace!("Letting client know dial was successful.");
            if let Some(sender) = self.pending_dial.remove(&peer_id) {
                let _ = sender.send(Ok(()));
            }
        }
    }

    /// Handle a new dial event
    ///
    /// A new dialing attempt has been initiated by the NetworkBehaviour implementation.
    /// A [SwarmEvent::ConnectionEstablished] event is reported if the dialing attempt succeeds,
    /// otherwise an [SwarmEvent::OutgoingConnectionError] event is reported.
    ///
    /// ## Parameters
    /// * `peer_id` - Identity of the peer that we are trying to connect to, if known.
    /// * `connection_id` - Identifier of the connection that is being dialed.
    fn on_dialing_event(&mut self, peer_id: Option<PeerId>, connection_id: ConnectionId) {
        let peer_str = match peer_id {
            Some(peer_id) => peer_id.to_string(),
            None => "[unknown peer]".to_string(),
        };
        info!("Dialing peer {peer_str}. Connection id: {connection_id}");
    }

    /// Respond to a connection being closed.
    ///
    /// This event fires when A connection with the given peer has been closed, possibly as a result of an error.
    ///
    /// ## Parameters
    /// * `peer_id` - Identity of the peer that we have connected to
    /// * `connection_id` - Identifier of the connection
    /// * `endpoint` - Endpoint of the connection that has been closed.
    /// * `num_established` - Number of other remaining connections to this same peer.
    /// * `cause` - [`Some`] if the connection was closed because of an error. Contains the error.
    fn on_connection_closed(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        endpoint: ConnectedPoint,
        num_established: u32,
        cause: Option<ConnectionError>,
    ) {
        self.connections.remove(&connection_id);
        let endpoint_str = match endpoint {
            ConnectedPoint::Dialer { address, .. } => {
                let reason = match cause {
                    Some(e) => format!("Connection closed with error: {e}"),
                    None => "Connection closed gracefully".to_string(),
                };
                format!("We were dialer to {address}. Reason: {reason}")
            }
            ConnectedPoint::Listener { local_addr, send_back_addr } => {
                format!("We were listening on {local_addr}, and the remote peer connected from {send_back_addr}.")
            }
        };
        info!("Connection to {peer_id}/{connection_id} closed. {endpoint_str}. {num_established} connections remain.");
        if num_established == 0 && self.status.load(std::sync::atomic::Ordering::SeqCst) == SHUTTING_DOWN {
            self.status.store(SHUTDOWN, std::sync::atomic::Ordering::SeqCst);
        }
    }

    /// This gets called when one of our listeners has reported a new local listening address.
    ///
    /// ## Parameters
    /// * `listener_id` - Identifier of the listener that is now listening on the address.
    /// * `address` - Address that is now being listened on.
    fn on_new_listen_addr(&self, listener_id: ListenerId, address: Multiaddr) {
        let local_peer_id = *self.swarm.local_peer_id();
        info!(
            "Local node is listening on {:?} with id: {listener_id}",
            address.with(Protocol::P2p(local_peer_id))
        );
    }

    /// A new connection arrived on a listener and is in the process of protocol negotiation.
    ///
    /// A corresponding [`ConnectionEstablished`](SwarmEvent::ConnectionEstablished) or
    /// [`IncomingConnectionError`](SwarmEvent::IncomingConnectionError) event will later be generated for this
    /// connection.
    ///
    /// ## Parameters
    /// * `connection_id` - Identifier of the connection.
    /// * `local_addr` - Local address that received the connection.
    /// * `send_back_addr` - Address to which the connection is being sent back.
    fn on_incoming_connection(&self, connection_id: ConnectionId, local_addr: Multiaddr, send_back_addr: Multiaddr) {
        info!("Incoming connection. Connection id: {connection_id}. Local address: {local_addr}. Send back address: {send_back_addr}");
    }

    /// Responds when a listening address has expired.
    ///
    /// ## Parameters
    /// * `listener_id` - The listener that is no longer listening on the address.
    /// * `address` - Address that has expired.
    fn on_expired_listen_addr(&mut self, listener_id: ListenerId, address: Multiaddr) {
        trace!("EVENT: Expired listen address: {address} #{listener_id}");
    }

    /// Responds to a listener being closed.
    ///
    /// This gets called whn one of the listeners gracefully closed.
    ///
    /// ## Parameters
    /// * `listener_id` - Identifier of the listener that closed.
    /// * `addresses` - The addresses that the listener was listening on. These addresses are now considered
    ///   expired, similar to if a [`ExpiredListenAddr`](SwarmEvent::ExpiredListenAddr) event
    ///   has been generated for each of them.
    /// * `reason` - Reason for the listener being closed. Contains `Ok(())` if the stream produced `None`, or `Err`
    ///   if the stream produced an error.
    fn on_listener_closed(
        &mut self,
        listener_id: ListenerId,
        addresses: Vec<Multiaddr>,
        reason: Result<(), io::Error>,
    ) {
        let reason = match reason {
            Ok(()) => "gracefully",
            Err(e) => &format!("with error: {e}"),
        };
        trace!("EVENT: Listener {listener_id} closed {reason}.");
        let addresses = addresses.into_iter().map(|addr| format!("{addr}")).collect::<Vec<_>>();
        debug!("Connections closed: {}", addresses.join(","));
    }

    /// Responds to a non-fatal listener error.
    ///
    /// ## Parameters
    /// * `listener_id` - Identifier of the listener that produced the error.
    /// * `error` - The error that happened.
    fn on_non_fatal_listener_error(&mut self, listener_id: ListenerId, error: io::Error) {
        debug!("EVENT: Non-fatal listener error: {listener_id} Error: {error}");
    }

    /// Handle a failed outbound request
    ///
    /// ## Parameters
    /// * `peer` - The peer to whom the request was sent.
    /// * `connection_id` - Identifier of the connection that the request was sent on.
    /// * `request_id` - The (local) ID of the failed request.
    /// * `error` - The error that happened.
    fn on_outbound_failure(
        &mut self,
        peer: PeerId,
        connection_id: ConnectionId,
        request_id: OutboundRequestId,
        error: OutboundFailure,
    ) {
        warn!("Outbound request failed. Peer: {peer}. Connection id: {connection_id}. Request id: {request_id}. Error: {error}");
        let send_result = if let Some(sender) = self.pending_requests.remove(&request_id) {
            sender.send(Err(RemoteServerError::NetworkError))
                // It's always `RemoteServerError::NetworkError` at this point. No need to capture it
                .map_err(|_err| {
                    warn!("An outbound request failed AND we failed to send the initiator of the request notification of the failure. \
                    The network is probably down.");
                })
        } else if let Some(sender) = self.pending_dial.remove(&peer) {
            sender.send(Err(PeerConnectionError::OutboundFailure(error))).map_err(|_value| {
                warn!("Failed to send error response for dial failure.");
            })
        } else {
            debug!("No pending request found for outbound failure. Request id: {request_id}");
            Ok(())
        };
        if send_result.is_err() {
            warn!("Failed to send error response for outbound request failure. Request id: {request_id}");
        }
    }

    async fn handle_command(&mut self, command: ClientCommand<Req, Resp>) {
        let abort_if_shutting_down = |sender: oneshot::Sender<_>| {
            if !self.is_running() {
                info!("Event loop is shutting down. Aborting command.");
                let _ = sender.send(Err(PeerConnectionError::EventLoopShuttingDown));
                return None;
            }
            Some(sender)
        };
        match command {
            ClientCommand::StartListening { addr, sender } => {
                if let Some(sender) = abort_if_shutting_down(sender) {
                    let _result = match self.swarm.listen_on(addr) {
                        Ok(_) => sender.send(Ok(())),
                        Err(e) => sender.send(Err(PeerConnectionError::TransportError(e))),
                    };
                }
            }
            ClientCommand::Dial { peer_id, peer_addr, sender } => {
                if let Some(sender) = abort_if_shutting_down(sender) {
                    self.handle_dial(peer_id, peer_addr, sender);
                }
            }
            ClientCommand::NewRequest { peer_id, request, sender } => {
                self.handle_new_request_command(peer_id, *request, sender).await;
            }
            ClientCommand::ResponseToRequest { res, return_channel } => {
                if let Err(response) = self.swarm.behaviour_mut().json.send_response(return_channel, *res) {
                    error!("Failed to send response to request. {response}");
                    // todo: retry logic
                }
            }
            ClientCommand::ConnectedPeers { sender } => {
                debug!("Connected peers requested.");
                let peers = self.swarm.connected_peers().cloned().collect();
                let _ = sender.send(peers);
            }
            ClientCommand::Shutdown(sender) => {
                info!("Shutting down event loop.");
                self.status.store(SHUTTING_DOWN, std::sync::atomic::Ordering::SeqCst);
                self.pending_shutdown = Some(sender);
                let connections = self.connections.clone();
                for id in connections {
                    self.swarm.close_connection(id);
                }
            }
        }
    }

    fn handle_dial(
        &mut self,
        peer_id: PeerId,
        peer_addr: Multiaddr,
        sender: oneshot::Sender<Result<(), PeerConnectionError>>,
    ) {
        if let hash_map::Entry::Vacant(e) = self.pending_dial.entry(peer_id) {
            match self.swarm.dial(peer_addr.with(Protocol::P2p(peer_id))) {
                Ok(()) => {
                    e.insert(sender);
                }
                Err(e) => {
                    let _ = sender.send(Err(PeerConnectionError::DialError(e)));
                }
            }
        } else {
            debug!("Dialing already in progress for peer {peer_id}. Ignoring additional dial attempt.");
        }
    }

    async fn handle_new_request_command(
        &mut self,
        peer: PeerId,
        req: Req,
        sender: oneshot::Sender<Result<Resp, RemoteServerError>>,
    ) {
        if !self.is_running() {
            info!("Event loop is shutting down. I'm not going to send new requests.");
            let _ = sender.send(Err(RemoteServerError::ServerShuttingDown));
            return;
        }
        let request_id = self.swarm.behaviour_mut().json.send_request(&peer, req);
        self.pending_requests.insert(request_id, sender);
    }
}

/// A remote request.
///
/// This is identical to [`Message::Request`], with the request_id removed.
pub struct RemoteRequest<Req, Resp> {
    /// The request message.
    pub request: Req,
    /// The remote channel waiting for the response.
    pub channel: ResponseChannel<Resp>,
}

impl<Req, Resp> RemoteRequest<Req, Resp> {
    /// Create a new `RemoteRequest` from a libp2p `Message::Request`.
    pub fn new(request: Req, channel: ResponseChannel<Resp>) -> Self {
        Self { request, channel }
    }

    /// Get the request message.
    pub fn request(&self) -> &Req {
        &self.request
    }

    /// Get the response channel.
    pub fn channel(&self) -> &ResponseChannel<Resp> {
        &self.channel
    }
}

#[derive(Error, Debug)]
pub enum PeerConnectionError {
    #[error("Failed to create P2P connection, due to an error in the Noise handshake. {0}")]
    NoiseError(#[from] noise::Error),
    #[error("Failed to dial peer: {0}")]
    DialError(#[from] DialError),
    #[error("Failed to create P2P connection, due to an error in the transport layer. {0}")]
    TransportError(#[from] TransportError<io::Error>),
    #[error("Cannot dial server peer, because the peer id is missing in the multiaddr")]
    MissingPeerId,
    #[error("Error in an internal mpsc channel. {0}")]
    SendError(#[from] mpsc::SendError),
    #[error("Could not give network client the result of a command because the return channel is canceled. {0}")]
    OneshotError(#[from] oneshot::Canceled),
    #[error("The event loop is shutting down, so the command cannot be executed.")]
    EventLoopShuttingDown,
    #[error("The remote peer server returned an operational error. {0}")]
    RemoteServerError(#[from] RemoteServerError),
    #[error("Will never happen, but required for the error trait")]
    Infallible(#[from] Infallible),
    #[error("An error occurred while processing an outbound request. {0}")]
    OutboundFailure(#[from] OutboundFailure),
    #[error("Received an unexpected response type from the peer. Expected {expected}, but got {got}.")]
    UnexpectedResponseType { expected: &'static str, got: String },
    #[error("Received a response for an unexpected channel. Expected {expected}, but got {got}.")]
    UnexpectedChannel { expected: String, got: String },
}

impl PeerConnectionError {
    pub fn unexpected_response(expected: &'static str, got: impl Display) -> Self {
        PeerConnectionError::UnexpectedResponseType { expected, got: got.to_string() }
    }

    pub fn unexpected_channel(expected: impl Display, got: impl Display) -> Self {
        PeerConnectionError::UnexpectedChannel { expected: expected.to_string(), got: got.to_string() }
    }
}

/// The set of commands that can be initiated by the user (via the `Client`) to the network event loop.
///
/// There is typically one method in the `Client` for each of these commands.
#[derive(Debug)]
pub enum ClientCommand<Req, Resp> {
    /// Start listening on a given address. Executed via [`crate::Client::start_listening`].
    StartListening { addr: Multiaddr, sender: oneshot::Sender<Result<(), PeerConnectionError>> },
    /// Dial a peer at a given address. Executed via [`crate::Client::dial`].
    Dial { peer_id: PeerId, peer_addr: Multiaddr, sender: oneshot::Sender<Result<(), PeerConnectionError>> },
    /// A new remote request for `peer_id` initiated from the client. The request will be forwarded to the peer and
    /// wait for the response, which is sent back via `sender`.
    NewRequest { peer_id: PeerId, request: Box<Req>, sender: oneshot::Sender<Result<Resp, RemoteServerError>> },
    /// Send a response back over the network to the peer that made a request.
    ResponseToRequest { res: Box<Resp>, return_channel: ResponseChannel<Resp> },
    /// Request the list of connected peers. Executed via [`crate::Client::connected_peers`].
    ConnectedPeers { sender: oneshot::Sender<Vec<PeerId>> },
    /// Shutdown the network event loop. Executed via [`crate::Client::shutdown`].
    Shutdown(oneshot::Sender<bool>),
}
