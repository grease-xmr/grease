//! The Grease P2P network event loop.
//!
//! See [`EventLoop`] for more information.

use crate::behaviour::{ConnectionBehavior, ConnectionBehaviorEvent, ProtocolCommand, RequestResponseHandlers};
use crate::errors::RemoteServerError;
use futures::channel::{mpsc, oneshot};
use futures::StreamExt;
use libp2p::core::transport::ListenerId;
use libp2p::core::ConnectedPoint;
use libp2p::multiaddr::Protocol;
use libp2p::request_response::ResponseChannel;
use libp2p::swarm::{ConnectionError, ConnectionId, DialError, ListenError, SwarmEvent};
use libp2p::{noise, Multiaddr, PeerId, Swarm, TransportError};
use log::*;
use std::any::Any;
use std::collections::{hash_map, HashMap, HashSet};
use std::convert::Infallible;
use std::fmt::{Debug, Display};
use std::io;
use std::num::NonZeroU32;
use std::sync::atomic::AtomicUsize;
use std::time::Duration;
use thiserror::Error;

const RUNNING: usize = 0;
const SHUTTING_DOWN: usize = 1;
const SHUTDOWN: usize = 2;

/// The main event loop handler for Grease p2p connections.
///
/// The `EventLoop` handles network events and commands for the Grease p2p network communications.
/// It responds to events generated by the connection as well as commands received from remote peers.
///
/// **Important**: The `EventLoop` is only a data broker. It does not perform any business or application logic itself.
///
/// ## Request-Response Handlers
///
/// Each request-response protocol (Grease, KES, etc.) has its own handler wrapped by
/// [`AsyncReqResponseHandler`](crate::p2p_networking::AsyncReqResponseHandler) that:
/// - Tracks pending outbound requests with oneshot senders
/// - Forwards inbound requests to the application layer via mpsc channel
/// - Completes pending requests when responses arrive
///
/// ## Adding New Protocols
///
/// To add a new protocol:
/// 1. Add a `json::Behaviour` field to [`ConnectionBehavior`]
/// 2. Add an [`AsyncApiWrapper`] handler field here
/// 3. Add a dispatch arm in [`EventLoop::behaviour_event()`]
/// 4. Add command variants to [`NetworkCommand`]
pub struct EventLoop {
    swarm: Swarm<ConnectionBehavior>,
    command_receiver: mpsc::Receiver<NetworkCommand>,
    /// Request-response handlers for all message types (Grease, KES, etc.)
    handlers: RequestResponseHandlers,
    /// Pending dial attempts
    pending_dial: HashMap<PeerId, oneshot::Sender<Result<(), PeerConnectionError>>>,
    /// Pending shutdown signal
    pending_shutdown: Option<oneshot::Sender<bool>>,
    /// Event loop status (RUNNING, SHUTTING_DOWN, SHUTDOWN)
    status: AtomicUsize,
    /// Active connections
    connections: HashSet<ConnectionId>,
}

impl EventLoop {
    /// Create a new EventLoop with the given swarm, command receiver, and request-response handlers.
    pub fn new(
        swarm: Swarm<ConnectionBehavior>,
        command_receiver: mpsc::Receiver<NetworkCommand>,
        handlers: RequestResponseHandlers,
    ) -> Self {
        Self {
            swarm,
            command_receiver,
            handlers,
            pending_dial: HashMap::default(),
            pending_shutdown: None,
            status: AtomicUsize::new(RUNNING),
            connections: Default::default(),
        }
    }

    /// Run the event loop until shutdown.
    pub async fn run(mut self) {
        loop {
            tokio::select! {
                event = self.swarm.select_next_some() => self.handle_network_event(event).await,
                command = self.command_receiver.next() => match command {
                    Some(c) => self.handle_command(c).await,
                    // Command channel closed, thus shutting down the network event loop.
                    None => return,
                },
            }
            if self.status.load(std::sync::atomic::Ordering::SeqCst) == SHUTDOWN {
                info!("Event loop has shutdown gracefully.");
                if let Some(sender) = self.pending_shutdown.take() {
                    let _ = sender.send(true);
                }
                break;
            }
        }
    }

    /// Check if the event loop is running.
    pub fn is_running(&self) -> bool {
        self.status.load(std::sync::atomic::Ordering::SeqCst) == RUNNING
    }

    /// Network event handler.
    ///
    /// This function is called whenever a new event is received from the network.
    async fn handle_network_event(&mut self, event: SwarmEvent<ConnectionBehaviorEvent>) {
        match event {
            SwarmEvent::Behaviour(event) => {
                self.handlers.dispatch_event(event).await;
            }
            SwarmEvent::NewListenAddr { listener_id, address } => {
                self.on_new_listen_addr(listener_id, address);
            }
            SwarmEvent::IncomingConnection { connection_id, local_addr, send_back_addr } => {
                self.on_incoming_connection(connection_id, local_addr, send_back_addr);
            }
            SwarmEvent::ConnectionEstablished {
                peer_id,
                connection_id,
                endpoint,
                num_established,
                concurrent_dial_errors,
                established_in,
            } => {
                self.on_connection_established(
                    peer_id,
                    connection_id,
                    endpoint,
                    num_established,
                    concurrent_dial_errors,
                    established_in,
                );
            }
            SwarmEvent::ConnectionClosed { peer_id, connection_id, endpoint, num_established, cause } => {
                self.on_connection_closed(peer_id, connection_id, endpoint, num_established, cause);
            }
            SwarmEvent::OutgoingConnectionError { peer_id, connection_id, error } => {
                self.on_outgoing_connection_error(peer_id, connection_id, error);
            }
            SwarmEvent::IncomingConnectionError { connection_id, local_addr, send_back_addr, error } => {
                self.on_incoming_connection_error(connection_id, local_addr, send_back_addr, error);
            }
            SwarmEvent::Dialing { peer_id, connection_id } => {
                self.on_dialing_event(peer_id, connection_id);
            }
            SwarmEvent::ExpiredListenAddr { listener_id, address } => {
                self.on_expired_listen_addr(listener_id, address);
            }
            SwarmEvent::ListenerClosed { listener_id, addresses, reason } => {
                self.on_listener_closed(listener_id, addresses, reason);
            }
            SwarmEvent::ListenerError { listener_id, error } => {
                self.on_non_fatal_listener_error(listener_id, error);
            }
            SwarmEvent::NewExternalAddrCandidate { address } => {
                trace!("EVENT: New external address candidate: {address}");
            }
            SwarmEvent::ExternalAddrConfirmed { address } => {
                trace!("EVENT: External address confirmed: {address}");
            }
            SwarmEvent::ExternalAddrExpired { address } => {
                trace!("EVENT: External address expired: {address}");
            }
            SwarmEvent::NewExternalAddrOfPeer { peer_id, address } => {
                trace!("EVENT: New external address of peer: {peer_id} {address}");
            }
            ev => {
                trace!("Unknown and unhandled event: {:?}", ev.type_id());
            }
        }
    }

    /// Handle a failed connection attempt.
    fn on_outgoing_connection_error(&mut self, peer_id: Option<PeerId>, connection_id: ConnectionId, error: DialError) {
        let peer_str = peer_id.map_or_else(|| "[unknown peer]".to_string(), |p| p.to_string());
        warn!("Connection to {peer_str} failed. Connection id: {connection_id}. Error: {error}");
        if let Some(peer_id) = peer_id {
            if let Some(sender) = self.pending_dial.remove(&peer_id) {
                let _ = sender.send(Err(PeerConnectionError::DialError(error)));
            }
        }
    }

    /// Handle a failed incoming connection.
    fn on_incoming_connection_error(
        &mut self,
        connection_id: ConnectionId,
        local_addr: Multiaddr,
        send_back_addr: Multiaddr,
        error: ListenError,
    ) {
        warn!("Incoming connection failed. Connection id: {connection_id}. Local address: {local_addr}. Send back address: {send_back_addr}. Error: {error}");
    }

    /// Respond to a new connection.
    fn on_connection_established(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        endpoint: ConnectedPoint,
        num_established: NonZeroU32,
        concurrent_dial_errors: Option<Vec<(Multiaddr, TransportError<io::Error>)>>,
        established_in: Duration,
    ) {
        let ep_type = match endpoint {
            ConnectedPoint::Dialer { .. } => "dialer",
            ConnectedPoint::Listener { .. } => "listener",
        };
        info!(
            "Connection to {peer_id} established as {ep_type} in {:0.3}s. Connection id: {connection_id}. {num_established} connections are active.",
            established_in.as_secs_f64()
        );
        self.connections.insert(connection_id);
        if let Some(errs) = concurrent_dial_errors {
            if !errs.is_empty() {
                warn!("{} concurrent dial errors were reported for {peer_id}.", errs.len());
                errs.into_iter().for_each(|(addr, err)| {
                    debug!("Concurrent dial error for {peer_id}. Address: {addr}. Error: {err}");
                });
            }
        }
        if endpoint.is_dialer() {
            trace!("Letting client know dial was successful.");
            if let Some(sender) = self.pending_dial.remove(&peer_id) {
                let _ = sender.send(Ok(()));
            }
        }
    }

    /// Handle a new dial event.
    fn on_dialing_event(&mut self, peer_id: Option<PeerId>, connection_id: ConnectionId) {
        let peer_str = peer_id.map_or_else(|| "[unknown peer]".to_string(), |p| p.to_string());
        info!("Dialing peer {peer_str}. Connection id: {connection_id}");
    }

    /// Respond to a connection being closed.
    fn on_connection_closed(
        &mut self,
        peer_id: PeerId,
        connection_id: ConnectionId,
        endpoint: ConnectedPoint,
        num_established: u32,
        cause: Option<ConnectionError>,
    ) {
        self.connections.remove(&connection_id);
        let endpoint_str = match endpoint {
            ConnectedPoint::Dialer { address, .. } => {
                let reason = cause.map_or_else(
                    || "Connection closed gracefully".to_string(),
                    |e| format!("Connection closed with error: {e}"),
                );
                format!("We were dialer to {address}. Reason: {reason}")
            }
            ConnectedPoint::Listener { local_addr, send_back_addr } => {
                format!("We were listening on {local_addr}, and the remote peer connected from {send_back_addr}.")
            }
        };
        info!("Connection to {peer_id}/{connection_id} closed. {endpoint_str}. {num_established} connections remain.");
        if num_established == 0 && self.status.load(std::sync::atomic::Ordering::SeqCst) == SHUTTING_DOWN {
            self.status.store(SHUTDOWN, std::sync::atomic::Ordering::SeqCst);
        }
    }

    /// This gets called when one of our listeners has reported a new local listening address.
    fn on_new_listen_addr(&self, listener_id: ListenerId, address: Multiaddr) {
        let local_peer_id = *self.swarm.local_peer_id();
        info!(
            "Local node is listening on {:?} with id: {listener_id}",
            address.with(Protocol::P2p(local_peer_id))
        );
    }

    /// A new connection arrived on a listener and is in the process of protocol negotiation.
    fn on_incoming_connection(&self, connection_id: ConnectionId, local_addr: Multiaddr, send_back_addr: Multiaddr) {
        info!("Incoming connection. Connection id: {connection_id}. Local address: {local_addr}. Send back address: {send_back_addr}");
    }

    /// Responds when a listening address has expired.
    fn on_expired_listen_addr(&mut self, listener_id: ListenerId, address: Multiaddr) {
        trace!("EVENT: Expired listen address: {address} #{listener_id}");
    }

    /// Responds to a listener being closed.
    fn on_listener_closed(
        &mut self,
        listener_id: ListenerId,
        addresses: Vec<Multiaddr>,
        reason: Result<(), io::Error>,
    ) {
        let reason = reason.map_or_else(|e| format!("with error: {e}"), |()| "gracefully".to_string());
        trace!("EVENT: Listener {listener_id} closed {reason}.");
        let addresses = addresses.into_iter().map(|addr| format!("{addr}")).collect::<Vec<_>>();
        debug!("Connections closed: {}", addresses.join(","));
    }

    /// Responds to a non-fatal listener error.
    fn on_non_fatal_listener_error(&mut self, listener_id: ListenerId, error: io::Error) {
        debug!("EVENT: Non-fatal listener error: {listener_id} Error: {error}");
    }

    /// Handle commands from the client API.
    async fn handle_command(&mut self, command: NetworkCommand) {
        let abort_if_shutting_down = |sender: oneshot::Sender<_>| {
            if !self.is_running() {
                info!("Event loop is shutting down. Aborting command.");
                let _ = sender.send(Err(PeerConnectionError::EventLoopShuttingDown));
                return None;
            }
            Some(sender)
        };
        match command {
            NetworkCommand::StartListening { addr, sender } => {
                if let Some(sender) = abort_if_shutting_down(sender) {
                    let _result = match self.swarm.listen_on(addr) {
                        Ok(_) => sender.send(Ok(())),
                        Err(e) => sender.send(Err(PeerConnectionError::TransportError(e))),
                    };
                }
            }
            NetworkCommand::Dial { peer_id, peer_addr, sender } => {
                if let Some(sender) = abort_if_shutting_down(sender) {
                    self.handle_dial(peer_id, peer_addr, sender);
                }
            }
            NetworkCommand::Protocol(cmd) => {
                if self.is_running() {
                    self.handlers.handle_command(cmd, self.swarm.behaviour_mut());
                }
            }
            NetworkCommand::ConnectedPeers { sender } => {
                debug!("Connected peers requested.");
                let peers = self.swarm.connected_peers().cloned().collect();
                let _ = sender.send(peers);
            }
            NetworkCommand::Shutdown(sender) => {
                info!("Shutting down event loop.");
                self.status.store(SHUTTING_DOWN, std::sync::atomic::Ordering::SeqCst);
                self.pending_shutdown = Some(sender);
                let connections = self.connections.clone();
                for id in connections {
                    self.swarm.close_connection(id);
                }
            }
        }
    }

    fn handle_dial(
        &mut self,
        peer_id: PeerId,
        peer_addr: Multiaddr,
        sender: oneshot::Sender<Result<(), PeerConnectionError>>,
    ) {
        if let hash_map::Entry::Vacant(e) = self.pending_dial.entry(peer_id) {
            match self.swarm.dial(peer_addr.with(Protocol::P2p(peer_id))) {
                Ok(()) => {
                    e.insert(sender);
                }
                Err(e) => {
                    let _ = sender.send(Err(PeerConnectionError::DialError(e)));
                }
            }
        } else {
            debug!("Dialing already in progress for peer {peer_id}. Ignoring additional dial attempt.");
        }
    }
}

/// A remote request.
///
/// This is identical to [`Message::Request`], with the request_id removed.
pub struct RemoteRequest<Req, Resp> {
    /// The request message.
    pub request: Req,
    /// The remote channel waiting for the response.
    pub channel: ResponseChannel<Resp>,
}

impl<Req, Resp> RemoteRequest<Req, Resp> {
    /// Create a new `RemoteRequest` from a libp2p `Message::Request`.
    pub fn new(request: Req, channel: ResponseChannel<Resp>) -> Self {
        Self { request, channel }
    }

    /// Get the request message.
    pub fn request(&self) -> &Req {
        &self.request
    }

    /// Get the response channel.
    pub fn channel(&self) -> &ResponseChannel<Resp> {
        &self.channel
    }
}

#[derive(Error, Debug)]
pub enum PeerConnectionError {
    #[error("Failed to create P2P connection, due to an error in the Noise handshake. {0}")]
    NoiseError(#[from] noise::Error),
    #[error("Failed to dial peer: {0}")]
    DialError(#[from] DialError),
    #[error("Failed to create P2P connection, due to an error in the transport layer. {0}")]
    TransportError(#[from] TransportError<io::Error>),
    #[error("Cannot dial server peer, because the peer id is missing in the multiaddr")]
    MissingPeerId,
    #[error("Error in an internal mpsc channel. {0}")]
    SendError(#[from] mpsc::SendError),
    #[error("Could not give network client the result of a command because the return channel is canceled. {0}")]
    OneshotError(#[from] oneshot::Canceled),
    #[error("The event loop is shutting down, so the command cannot be executed.")]
    EventLoopShuttingDown,
    #[error("The remote peer server returned an operational error. {0}")]
    RemoteServerError(#[from] RemoteServerError),
    #[error("Will never happen, but required for the error trait")]
    Infallible(#[from] Infallible),
    #[error("An error occurred while processing an outbound request. {0}")]
    OutboundFailure(#[from] libp2p::request_response::OutboundFailure),
    #[error("Received an unexpected response type from the peer. Expected {expected}, but got {got}.")]
    UnexpectedResponseType { expected: &'static str, got: String },
    #[error("Received a response for an unexpected channel. Expected {expected}, but got {got}.")]
    UnexpectedChannel { expected: String, got: String },
    #[error("{0}")]
    InvalidChannelId(String),
}

impl PeerConnectionError {
    /// Create an error for receiving an unexpected response type.
    pub fn unexpected_response(expected: &'static str, got: impl Display) -> Self {
        PeerConnectionError::UnexpectedResponseType { expected, got: got.to_string() }
    }

    /// Create an error for receiving a response on an unexpected channel.
    pub fn unexpected_channel(expected: impl Display, got: impl Display) -> Self {
        PeerConnectionError::UnexpectedChannel { expected: expected.to_string(), got: got.to_string() }
    }
}

/// Commands that can be sent to the network event loop.
///
/// Protocol-specific commands are wrapped in `Protocol(ProtocolCommand)`.
#[derive(Debug)]
pub enum NetworkCommand {
    /// Start listening on a given address.
    StartListening { addr: Multiaddr, sender: oneshot::Sender<Result<(), PeerConnectionError>> },
    /// Dial a peer at a given address.
    Dial { peer_id: PeerId, peer_addr: Multiaddr, sender: oneshot::Sender<Result<(), PeerConnectionError>> },
    /// Protocol-specific command (send request/response).
    Protocol(ProtocolCommand),
    /// Request the list of connected peers.
    ConnectedPeers { sender: oneshot::Sender<Vec<PeerId>> },
    /// Shutdown the network event loop.
    Shutdown(oneshot::Sender<bool>),
}
