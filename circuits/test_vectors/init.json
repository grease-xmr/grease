{
  "noir_version": "1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663",
  "hash": "14149417934511280575",
  "abi": {
    "parameters": [
      {
        "name": "nonce_peer",
        "type": {
          "kind": "field"
        },
        "visibility": "public"
      },
      {
        "name": "T_0",
        "type": {
          "kind": "struct",
          "path": "edwards::Curve",
          "fields": [
            {
              "name": "x",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "y",
              "type": {
                "kind": "field"
              }
            }
          ]
        },
        "visibility": "public"
      },
      {
        "name": "witness_0",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "blinding",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "fi_2",
        "type": {
          "kind": "struct",
          "path": "edwards::Curve",
          "fields": [
            {
              "name": "x",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "y",
              "type": {
                "kind": "field"
              }
            }
          ]
        },
        "visibility": "private"
      },
      {
        "name": "enc_2",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "r_2",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "pubkey_KES",
        "type": {
          "kind": "struct",
          "path": "edwards::Curve",
          "fields": [
            {
              "name": "x",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "y",
              "type": {
                "kind": "field"
              }
            }
          ]
        },
        "visibility": "public"
      },
      {
        "name": "challenge_bytes",
        "type": {
          "kind": "array",
          "length": 32,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "public"
      },
      {
        "name": "blinding_DLEQ",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "response_div_BabyJubJub",
        "type": {
          "kind": "array",
          "length": 32,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "response_BabyJubJub",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "response_div_ed25519",
        "type": {
          "kind": "array",
          "length": 32,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "response_ed25519",
        "type": {
          "kind": "array",
          "length": 32,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "361444214588792908": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "1998584279744703196": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3301098964710512891": {
        "error_kind": "fmtstring",
        "length": 56,
        "item_types": []
      },
      "9125450380484214683": {
        "error_kind": "string",
        "string": "validate_gt fail"
      },
      "11084314168516775404": {
        "error_kind": "string",
        "string": "assert_is_not_zero_integer fail"
      },
      "12469291177396340830": {
        "error_kind": "string",
        "string": "call to assert_max_bit_size"
      },
      "14990209321349310352": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "15764276373176857197": {
        "error_kind": "string",
        "string": "Stack too deep"
      },
      "15835548349546956319": {
        "error_kind": "string",
        "string": "Field failed to decompose into specified 32 limbs"
      },
      "16431471497789672479": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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PQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AHnoG8tAzkIeegTz0DOShZyAPPQN56BnIQ89AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBSgZ6AAPQMF6BkoQM9AAXoGCtAzUICegQL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9AEXoGitAzUISegSL0DBShZ6AIPQNF6BkoQs9A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uDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDuDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDhDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDpDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxDlDxD1Pv91f09zPdXc8P5/mpuNd9f5f38+furudv8/dU73715X2d69c53b933Mr1657u37u9tejU3n159//2Z8fr2XXe+e7//3st4ffv333sZr2/v+Zzv3n7m1+ad7c515/n8fee4c+N1jl7n9up9ndur93Vur97Xub16X2e+v5rXme+v3tcpvM7G6zRe5+h15u+v5nWmV/M6Znodc72OhV7HEq9TeJ2N12m8ztHr+KPX8aXXcdzZcWfHnR13dtzZcWfHnR13Dtw5cOfAnQN3jtnbd07MhXljbsxHcz6YF2bD7Jhn77lzYr571/0zeXvV6/4+b6967TvfvXbfy+1V233N26v2+95vr9rnc+7e+8/m+Pa+/zyOb++4r3l71XF/D7dXnfM5d+/9Z3Z8e9+mjW/vuq95e9V1fw+3V73nc+7e27fx7X2bNr69+77m7VXP1+72qvv+fm6vuu/v5/aqz/393F6d537+7dWZe95enbnh7dW5rRvf/t7z9uq9Z5fueXv13vP26r3n7dV7z9ur955n6Z63V+89b6/ee57QPW+v3nveXr33vL1673l79d7znN97jm+fe45vn3uOb597jm+fe45vn3uOb597jm+fe45vn3uOb597jm+fe45vn3uOb597jm+fe45vn3uOb597jm+fe45vn3uOb597jm+fe45vn3uOb597jm+fe45vn3uOb597jm+fe45vn3uOb597jm9/7zm9mntOr+ae06u55/Rq7umme7rrntOruef0au55e/Xe8/bqvae37nl79d5zejX3nF7NPadXc8/p1dxzejX3nF7NPadXc8/p1dxzejX3nF7NPadXc8/p1dxzejX3nF7NPadXc8/p1dxzejX3nF7NPadXc8/p1dxzejX3nF7NPadXc8/p1dzz9uq95+3Ve88q3fP26r3n9GruOb2ae06v5p7Tq7nn9GruOb2ae06v5p7Tq7nn9GruOb2ae06v5p7Tq7nn7dV7z1665+3Ve8923XN6NfecXs09p1dzz+nV3HN6NfecXs09p1dzz+nV3POY7nl79d7zhO55e/Xe8+h5NL79vefR82h8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPt7T9PzaHz7e0/X82h8+3tP1/NofPt7T9fzaHz7e0/X82h8+3tP1/NofPt7z9DzaHz7e8/Q82h8+3vP0PNofPt7z9DzaHz7e8/Q82h8+3vP1PNofPt7z9TzaHz7e8/U82h8+3vP1PNofPt7z9TzaHz7e8/S82h8+3vP0vNofPt7z9LzaHz7e8/S82h8+3vP0vNofPt7z63n0fj2955bz6Px7e89t55H49vfe249j8a3v/fceh6Nb3/v2XoejW9/79l6Ho1vf+/Zeh6Nb3/v2XoejW9/79l6Ho1vf+959Dwa3/7e8+h5NL79vefR82h8+3vPo+fR+Pb3nkfPo/Ht9545vv3eM8e333vm8/w+j3J8+71njm+/98zx7feeOb793jPHt9975vj2e88c337vmePb7z1zfPu9Z45vv/fM8e33njm+/d4zx7ffe+b49nvPHN9+75nj2+89c3z7vWeOb7/3zPHt9545vv3eM8e333vm+PZ7zxzffu+Z49vvPXN8+3tPa93Tju7pj+7pS/d00z3ddU8P3dNT9/TSPX3rnt66px/dMx7dM5buGaZ7huueEbpnpO4ZpXvG1j2jdc84umc+umcu3TNN90zXPTN0z0zdM0v3zK17ZuueeXTPenTPWrpnme5ZrntW6J6VumeV7llb96zWPevonvvRPffSPbfpntt1zx26507dc5fuubfuuVv33Ef37Ef37KV7tume7bpnh+7ZqXt26Z69dc9u3bOP7nke3fMs3fOY7nlc9zyhe57UPU/pnmfrnqd1z/P7PMrx7XPP8e1zz/Htc8/x7XPP8e1zz/Htc8/x7XPP8e1zz/Htc8/x7XPP8e1zz/Htc8/x7XPP8e1zz7V+n0c5vn3uOb597jm+fe45vn3uOb597jm+fe45vn3uOb597jm+fe45vn3uOb597jm+fe45vv29p7XuaUf39Ef39KV7uume7rqnh+7pqXt66Z6+dU9v3dP1PBrf/t4z9DxaoefR+Pb3nqHn0fj2956h59H49veeoefR+Pb3nqnn0fj2956p59H49veeqefR+Pb3nqnn0fj2956p59H49veepefR+Pb3nqXn0fj2956l59H49veepefR+Pb3nqXn0fj2955bz6Px7e89t55H49vfe249j8a3v/fceh6Nb3/vufU8Gt/+3rP1PBrf/t6z9Twa3/7es/U8Gt/+3rP1PBrf/t6z9Twa3/7e8+h5NL79vefR82h8+3vPo+fR+Pb3nkfPo/Ht7z2Pnkfj2+ee49vnnuPb557j2+ee49vnnuPb557j2+ee49vnnuPb557j2+ee49vnnuPb557j2+ee49vnnuPb557j2+ee49vnnuPb557j2+ee49vnnuPb557j2+ee49vnnuPb557j2+ee49vnnuPb555meh6Nb3/vaXoejW9/7+l6Ho1vf+/peh6Nb3/v6XoejW9/7+l6Ho1vf+/peh6Nb3/vGXoejW9/7xl6Ho1vf+8Zeh6Nb3/vGXoejW9/7xl6Ho1vf++Zeh6Nb3/vmXoejW9/75l6Ho1vf++Zeh6Nb3/vmXoejW9/71l6Ho1vf+9Zeh6Nb3/vWXoejW9/71l6Ho1vf+9Zeh6Nb3/vufU8Gt/+3nPreTS+/b3n1vNofPt7z63n0fj2955bz6Px7e89W8+j8e3vPVvPo/Ht7z1bz6Px7e89W8+j8e3vPVvPo/Ht7z2Pnkfj2997Hj2Pxre/9zx6Ho1vf+959Dwa3/7e8+h5NL597jm+fe45vn3uOb597jm+fe45vn3uOb597umPnkfj2+ee49vnnuPb556+9Dwa3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN/+3tP0PBrf/t7T9Twa3/7e0/U8Gt/+3tP1PBrf/t7T9Twa3/7e0/U8Gt/+3jP0PBrf/t4z9Dwa3/7eM/Q8Gt/+3jP0PBrf/t4z9Dwa3/7eM/U8Gt/+3jP1PBrf/t4z9Twa3/7eM/U8Gt/+3jP1PBrf/t6z9Dwa3/7es/Q8Gt/+3rP0PBrf/t6z9Dwa3/7es/Q8Gt/+3nPreTS+/b3n1vNofPt7z63n0fj2955bz6Px7e89t55H49vfe7aeR+Pb33u2nkfj2997tp5H49vfe7aeR+Pb33u2nkfj2997Hj2Pxre/9zx6Ho1vf+959Dwa3/7e8+h5NL79vefR82h8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9xzfPvcc3z73HN8+9wzlp5H49vnnuPb557j2+eeYXoejW+fe45vn3uOb597jm+fe45vf+9peh6Nb3/v6XoejW9/7+l6Ho1vf+/peh6Nb3/v6XoejW9/7+l6Ho1vf+8Zeh6Nb3/vGXoejW9/7xl6Ho1vf+8Zeh6Nb3/vGXoejW9/75l6Ho1vf++Zeh6Nb3/vmXoejW9/7ynPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCHPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCnPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkCXPkAXPsOEZNjzDhmfY8AwbnmHDM2x4hg3PsOEZNjzDhmfY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V4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXpl6JWhV4ZeGXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV45eOXrl6JWjV/DtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtDd/e8O0N397w7Q3f3vDtnxl70Sv49oZvb/j2hm9v+PaGb2/49oZvb/j2hm9v+PaGb2/49oZvb/j2hm9v+PaGb2/49oZv79e31/Odp1fvvDAbZsccmBNzYd6YGzP2Huw92Huw92Dvwd6DvQd7D/Ye7D2/e8/r2995YTbMjjkwJ+bCvDE3Zuxd2Luwd2Hvwt6FvQt7F/Yu7F3Yu7DXsNew17DXsNew17DXsNew17DXsNex17HXsdex17HXsdex17HXsdexN7A3sDewd3pVdue7d8989+6+c2HemBvz3fv93wg+r28/fufPXvv8SbuzYfbvvOZzAnPeeV6nvrOtO2/Mjfncub7zt1e/890b973U3fv938I417f/fjzw8bs35tfevXHfV23Mjfnujfv73Hdv3l+7F+a7d267797KOwfmu3ff977v3r7va9+9PZ9z9/bdu+/ec2/YD+aF+e4993X67j3313Zg/u5dz33v31595n3njfm7d62Zv3uX3fnbK1t+f8/fXn3m+36/vfqd/c5317dXtmI+/+6dO5/CvDE35vM7X9/+O9+96Xc2zHdvnjvfvfu5893b8zl375mP370n7vzd+/kDdOej+dsrs+//bvW5vv13/u61++fw+vbPfF//26vfOTHXnfvOG/Pde/8cXt/+me97tEcft4WP3733z+H17WZ534sF5sR89+b9fdrdm/NrG/PdW3eX372177ww3737vne/e+eefvf2fM7de//sXd/+O2/Md++5t/W799yvVzyYv3v9ubu+vfrM9/f57dXv/N3r697k2ytzu7//b68+83zOd6/fP6vXt//OR/O3V7/z3ev3dW6vfua71+/v5/bK52txe/UzF+aNuTEfzbdXPl+X2yvPu+v26md2zIE5Md+9eX9vt1d+m3N9++98NN9e/cx3b91b3V75vr+f26uf+e7tme/e+TreXv3MG/Pde+6fh9uruM2/vv13XpgNs9/5/t5ur+K26Pp2izWf890bdt/v7dXP3JiP5turuO26vv0z3z9jt1c/s2MOzIm5MG/Mjfn8zte3W9w/P9e3/86G2THfvbeZ17d//nH3O9+993lxffvvxxsfP/r47dX78durn48bPu74eODj2Luwd2Hvwt6FvYa9Nnv3ne/e2+Hr2z+z3TkwJ+bCvDHfvXt23b19X/P26mdemA3z3dt157v3fq9yffvvfPeemb9785m5MR/Nt1d5nwXXt3/m+7W7vfqZHXNg/u5Nu7+326u0eZ271+ZzGvPRfHv1My/MhtkxB+bEXJjv3tu369t/56P59upnvnu//9tk5/r2zwvfr9HtVc6fgdurnzkx373zNb29yvvsuL79dz6ab69+5oXZMN+995lyfftnvv9M3V79zIV5Y27Md++5v8/bq7otur79dzbMjjnufO95e/X5/87fuTB/95bN/N37+f9o3/lovr36me9ev+/x9urz/5W+s2MOzIn57r3f617f/pnnde7enM+5e+/X5fr233lhNsx37/3n+vr2z3zunJgL88bcmI/m9WBemA3z3bvjzoE5MRfmu/f+bHJ9++cPkd/53Pm+l9ur9+O3Vz8fN3zc8fHAxxMfL3x84+PYa9jr2OvY69jr2Ouz99789mrf5+D17b/zxtyYj+bbq595YTbMjjkwz977e4jCvDE35rv3ft97ffvnH9D7dbm92vfP4fXtv7NjvntzPv/uvd+jXt/+O2/Mjflovr36mRdmw+yYA/PdO3/mb69+5o25Md+99/ul69s/UbE73723J9e3/86O+bu3n/n8vHPduTBvzI353Pn+M3J79TMvzIbZMQfmxFyYN+a7d/48NPYe7D3Ye3v1fv7B3oO9B3tvr34+/+69zby+/fN1ube6ver7M/717b/zwmyYHXNgvnvv91rXt//OG3NjPppvr37mu/f+bHt9+yf883HHHJgT8917/x7m+vbPbHduzEfz7dXPvDAbZsccmBPz7N133pgb89F8e9X3z/b17Z+H1b3h7VXfv0+4vv3344GPJz5e+PjGxxsfP/r47dX78cDewN7A3sDewN7A3turc3/WuL79M9+v3e3VO99e/cwLs2F2zIE5MRfmjfnuvX/Or2//mW+vfuaF+e69P+de3/75RuB+XW6vTsznJObCfPfG/Nq7N+fjR/Pt1c+8MBtmxxyYE3Nh3phn7/0976O5H8wL8917f6a4vv3zzUvc+e7t+ZzEXJjv3jOff/fO1/326p1vr37mhfmz9/NN0P1z/u3V7xyYE3Nh3pgb8/mdr2//nded7c6GjzvmwJz4/MLHN+bGfPT5a/b6ne/7jf33P/70f/7xb3/5x3/667/87z/9t//3+T//53/+6z//x1/+7V/f//M//u+///w3//S3v/z1r3/5X//93//2b//8L//jP//2L//9r//2z9//7k/P9z++L/8Pn795sfPnzycvfWj/4fb9kL2f+g+fv4V4/vj8lcPz5z/+9Hmf//BJeuVnXvNffn4i+PzH/n5gzQf684F+vq/hP6/x+Ynqj883xO8rfD6j++cVPj+0/fH54evn13//Nuvz7eP3V8d//as/f037+e9/fvXnB6HPj4m/v/rz/crnJ8Lvr87fX/15pn++G/7zfZef119/fB7z72t9/57u8wPR76t93tvnZ4HfV9vnj8/j7Ptq9Xugz09PcRfs74e+L/Lp87afl/j8oPt59c9/3T/7v39n83ma/1fv/fNN1h+fb5Z+9n2+V/r8n/dXn98X33/McZ/3F/v9ej2/7+77W975vvrnsbSf33fzicnnR9bfd/Ppyeen0/vL1+8X9/s38p+/c13vC3x+1j6/x/38fW1+/kv7Pcj6/h385z/ivoj+hPQnzZ+/EHp+r/r5eqX/vsz+/JP9+Y/z+zL9+VP2+Y/5o/f7h+Tzrf0fn293f34n8cf5/cJ8/+7w89PE76FWfP7P+1VYv39KPt8Z/fH5buG//OWfP6SuP6Of78U+X5HPn9C///3Pf///",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "39": {
      "source": "use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_add(y as u8) as i8\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_add(y as u16) as i16\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_add(y as u32) as i32\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_add(y as u64) as i64\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_sub(y as u8) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_sub(y as u16) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_sub(y as u32) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_sub(y as u64) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_mul(y as u8) as i8\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_mul(y as u16) as i16\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_mul(y as u32) as i32\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_mul(y as u64) as i64\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        crate::static_assert(1 == 2, \"custom message\");\n    }\n\n    mod arithmetic {\n        use crate::ops::arith::{Add, Div, Mul, Neg, Rem, Sub};\n        #[test]\n        fn test_basic_arithmetic_traits() {\n            // add\n            assert_eq(5.add(3), 8);\n            assert_eq(0u8.add(255u8), 255u8);\n            assert_eq(42.add(58), 100);\n\n            // sub\n            assert_eq(10.sub(3), 7);\n            assert_eq(100.sub(42), 58);\n\n            // mul\n            assert_eq(6.mul(7), 42);\n\n            // div\n            assert_eq(15.div(3), 5);\n            assert_eq(10u8.div(3u8), 3u8);\n            assert_eq(15.div(3), 5);\n\n            // rem\n            assert_eq(17.rem(5), 2);\n            assert_eq(10u8.rem(3u8), 1u8);\n\n            // neg\n            assert_eq(42.neg(), -42);\n            assert_eq((-10).neg(), 10);\n            assert_eq(42.neg(), -42);\n        }\n\n        #[test]\n        fn test_division() {\n            // test division by one\n            assert_eq(42.div(1), 42);\n            assert_eq(0.div(1), 0);\n            assert_eq(255u8.div(1u8), 255u8);\n\n            // test division by self\n            assert_eq(42.div(42), 1);\n            assert_eq(1.div(1), 1);\n\n            // test remainder\n            assert_eq(42.rem(42), 0);\n            assert_eq(0.rem(42), 0);\n            assert_eq(1.rem(42), 1);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_sub_overflow_failure() {\n            let _ = 0u8.sub(1u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_add_overflow_failure() {\n            let _ = 255u8.add(1u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_mul_overflow_failure() {\n            let _ = 255u8.mul(2u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_sub_overflow_failure() {\n            let _ = 0u16.sub(1u16);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_add_overflow_failure() {\n            let _ = 65535u16.add(1u16);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_mul_overflow_failure() {\n            let _ = 65535u16.mul(2u16);\n        }\n\n        #[test(should_fail)]\n        fn test_signed_sub_overflow_failure() {\n            let val: i8 = -128;\n            let _ = val.sub(1i8);\n        }\n\n        #[test(should_fail)]\n        fn test_signed_overflow_failure() {\n            let _ = 127i8.add(1i8);\n        }\n\n        #[test]\n        fn test_field() {\n            let zero: Field = 0;\n            let one: Field = 1;\n\n            // test Field basic operations\n            assert_eq(zero.add(one), one);\n            assert_eq(one.add(zero), one);\n            assert_eq(one.sub(one), zero);\n            assert_eq(one.mul(one), one);\n            assert_eq(one.div(one), one);\n            assert_eq(zero.neg(), zero);\n            assert_eq(one.neg(), -one);\n        }\n\n    }\n\n    mod wrapping_arithmetic {\n        use crate::ops::arith::{Add, Div, Mul, Neg, Sub, WrappingAdd, WrappingMul, WrappingSub};\n        #[test]\n        fn test_wrapping_add() {\n            assert_eq(255u8.wrapping_add(1u8), 0u8);\n            assert_eq(255u8.wrapping_add(255u8), 254u8);\n            assert_eq(0u8.wrapping_add(0u8), 0u8);\n            assert_eq(128u8.wrapping_add(128u8), 0u8);\n\n            // test u16 wrapping add\n            assert_eq(65535u16.wrapping_add(1u16), 0u16);\n            assert_eq(65535u16.wrapping_add(65535u16), 65534u16);\n\n            // test u32 wrapping add\n            assert_eq(0xffffffffu32.wrapping_add(1u32), 0u32);\n            assert_eq(0xffffffffu32.wrapping_add(0xffffffffu32), 0xfffffffeu32);\n\n            // test u64 wrapping add\n            assert_eq(0xffffffffffffffffu64.wrapping_add(1u64), 0u64);\n            assert_eq(\n                0xffffffffffffffffu64.wrapping_add(0xffffffffffffffffu64),\n                0xfffffffffffffffeu64,\n            );\n\n            // test u128 wrapping add\n            assert_eq(0xffffffffffffffffffffffffffffffffu128.wrapping_add(1u128), 0u128);\n\n            // test signed types\n            assert_eq(127i8.wrapping_add(1i8), -128i8);\n            let val: i8 = -128;\n            assert_eq(val.wrapping_add(-1i8), 127i8);\n\n            // test Field wrapping add\n            let forty_two: Field = 42;\n            let fifty_eight: Field = 58;\n            let hundred: Field = 100;\n            let neg_two: Field = -2;\n            let two: Field = 2;\n            let zero: Field = 0;\n            let neg_two_hundred: Field = -200;\n            let neg_one_ninety_eight: Field = -198;\n            assert_eq(forty_two.wrapping_add(fifty_eight), hundred);\n            assert_eq(neg_two.wrapping_add(two), zero);\n            assert_eq(neg_two_hundred.wrapping_add(two), neg_one_ninety_eight);\n        }\n\n        #[test]\n        fn test_wrapping_sub() {\n            assert_eq(0u8.wrapping_sub(1u8), 255u8);\n            assert_eq(255u8.wrapping_sub(255u8), 0u8);\n            assert_eq(0u8.wrapping_sub(0u8), 0u8);\n            assert_eq(1u8.wrapping_sub(2u8), 255u8);\n\n            // test u16 wrapping sub\n            assert_eq(0u16.wrapping_sub(1u16), 65535u16);\n            assert_eq(65535u16.wrapping_sub(65535u16), 0u16);\n\n            // test u32 wrapping sub\n            assert_eq(0u32.wrapping_sub(1u32), 0xffffffffu32);\n            assert_eq(0xffffffffu32.wrapping_sub(0xffffffffu32), 0u32);\n\n            // test u64 wrapping sub\n            assert_eq(0u64.wrapping_sub(1u64), 0xffffffffffffffffu64);\n            assert_eq(0xffffffffffffffffu64.wrapping_sub(0xffffffffffffffffu64), 0u64);\n\n            // test u128 wrapping sub\n            assert_eq(0u128.wrapping_sub(1u128), 0xffffffffffffffffffffffffffffffffu128);\n\n            // test signed types\n            let val: i8 = -128;\n            assert_eq(val.wrapping_sub(1i8), 127i8);\n            assert_eq(127i8.wrapping_sub(-1i8), -128i8);\n\n            // test Field wrapping sub\n            let forty_two: Field = 42;\n            let fifty_eight: Field = 58;\n            let neg_sixteen: Field = -16;\n            assert_eq(forty_two.wrapping_sub(fifty_eight), neg_sixteen);\n        }\n\n        #[test]\n        fn test_wrapping_mul() {\n            let zero: u128 = 0;\n            let one: u128 = 1;\n            let two_pow_64: u128 = 0x10000000000000000;\n            let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n            assert_eq(zero, zero.wrapping_mul(one));\n            assert_eq(zero, one.wrapping_mul(zero));\n            assert_eq(one, one.wrapping_mul(one));\n            assert_eq(zero, zero.wrapping_mul(two_pow_64));\n            assert_eq(zero, two_pow_64.wrapping_mul(zero));\n            assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n            assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n            assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n            assert_eq(one, u128_max.wrapping_mul(u128_max));\n\n            // test u8 wrapping mul\n            assert_eq(255u8.wrapping_mul(2u8), 254u8);\n            assert_eq(255u8.wrapping_mul(255u8), 1u8);\n            assert_eq(128u8.wrapping_mul(2u8), 0u8);\n\n            // test u16 wrapping mul\n            assert_eq(65535u16.wrapping_mul(2u16), 65534u16);\n            assert_eq(65535u16.wrapping_mul(65535u16), 1u16);\n\n            // test u32 wrapping mul\n            assert_eq(0xffffffffu32.wrapping_mul(2u32), 0xfffffffeu32);\n            assert_eq(0xffffffffu32.wrapping_mul(0xffffffffu32), 1u32);\n\n            // test u64 wrapping mul\n            // 0xffffffffffffffffu64 is 2^64 - 1\n            assert_eq(0xffffffffffffffffu64.wrapping_mul(2u64), 0xfffffffffffffffeu64);\n            assert_eq(0xffffffffffffffffu64.wrapping_mul(0xffffffffffffffffu64), 1u64);\n\n            // test signed types\n            assert_eq(127i8.wrapping_mul(2i8), -2i8);\n            let val: i8 = -128;\n            assert_eq(val.wrapping_mul(-1i8), -128i8);\n\n            // test Field wrapping mul\n            let six: Field = 6;\n            let seven: Field = 7;\n            let forty_two: Field = 42;\n            let neg_two: Field = -2;\n            let two: Field = 2;\n            let neg_four: Field = -4;\n            assert_eq(six.wrapping_mul(seven), forty_two);\n            assert_eq(neg_two.wrapping_mul(two), neg_four);\n        }\n\n        #[test]\n        fn test_u1_behavior() {\n            // u1 wrapping add is XOR\n            assert_eq(0u1.wrapping_add(0u1), 0u1);\n            assert_eq(0u1.wrapping_add(1u1), 1u1);\n            assert_eq(1u1.wrapping_add(0u1), 1u1);\n            assert_eq(1u1.wrapping_add(1u1), 0u1);\n\n            // u1 wrapping sub is XOR\n            assert_eq(0u1.wrapping_sub(0u1), 0u1);\n            assert_eq(0u1.wrapping_sub(1u1), 1u1);\n            assert_eq(1u1.wrapping_sub(0u1), 1u1);\n            assert_eq(1u1.wrapping_sub(1u1), 0u1);\n\n            // u1 wrapping mul is AND\n            assert_eq(0u1.wrapping_mul(0u1), 0u1);\n            assert_eq(0u1.wrapping_mul(1u1), 0u1);\n            assert_eq(1u1.wrapping_mul(0u1), 0u1);\n            assert_eq(1u1.wrapping_mul(1u1), 1u1);\n        }\n\n        // test wrapping operations is the same as the regular operations\n        #[test]\n        fn test_wrapping_vs_regular() {\n            let u64_large = 0x123456789abcdef0u64;\n            let u128_large = 0x123456789abcdef0123456789abcdef0u128;\n\n            assert_eq(u64_large.wrapping_add(1u64), u64_large + 1u64);\n            assert_eq(u64_large.wrapping_sub(1u64), u64_large - 1u64);\n            assert_eq(u64_large.wrapping_mul(2u64), u64_large * 2u64);\n\n            assert_eq(u128_large.wrapping_add(1u128), u128_large + 1u128);\n            assert_eq(u128_large.wrapping_sub(1u128), u128_large - 1u128);\n            assert_eq(u128_large.wrapping_mul(2u128), u128_large * 2u128);\n        }\n\n        #[test]\n        fn test_field_wrapping_operations() {\n            let zero: Field = 0;\n            let one: Field = 1;\n            let large_val = 0xffffffffffffffff;\n\n            // test Field wrapping operations\n            assert_eq(zero.wrapping_add(one), one);\n            assert_eq(one.wrapping_add(large_val), one + large_val);\n            assert_eq(zero.wrapping_sub(one), -one);\n            assert_eq(one.wrapping_sub(large_val), one - large_val);\n            assert_eq(zero.wrapping_mul(one), zero);\n            assert_eq(one.wrapping_mul(large_val), large_val);\n\n            // test Field basic operations\n            assert_eq(zero.add(one), one);\n            assert_eq(one.add(zero), one);\n            assert_eq(one.sub(one), zero);\n            assert_eq(one.mul(one), one);\n            assert_eq(one.div(one), one);\n            assert_eq(zero.neg(), zero);\n            assert_eq(one.neg(), -one);\n        }\n\n    }\n\n    mod split_functions {\n\n        use crate::ops::arith::{split64, split_into_64_bit_limbs};\n\n        // test split64 and split_into_64_bit_limbs functions\n        #[test]\n        fn test_split_functions() {\n            let small_val = 0x123456789abcdefu128;\n            let large_val = 0x123456789abcdef0123456789abcdef0u128;\n            let max_val = 0xffffffffffffffffffffffffffffffffu128;\n\n            // test split64 (unconstrained)\n            // Safety: testing\n            unsafe {\n                let (lo, hi) = split64(small_val);\n                assert_eq(lo, 0x123456789abcdefu64);\n                assert_eq(hi, 0u64);\n\n                let (lo2, hi2) = split64(large_val);\n                assert_eq(lo2, 0x123456789abcdef0u64);\n                assert_eq(hi2, 0x123456789abcdef0u64);\n            }\n\n            // test split_into_64_bit_limbs (constrained)\n            let (lo3, hi3) = split_into_64_bit_limbs(small_val);\n            assert_eq(lo3, 0x123456789abcdefu64);\n            assert_eq(hi3, 0u64);\n\n            let (lo4, hi4) = split_into_64_bit_limbs(large_val);\n            assert_eq(lo4, 0x123456789abcdef0u64);\n            assert_eq(hi4, 0x123456789abcdef0u64);\n\n            let (lo5, hi5) = split_into_64_bit_limbs(max_val);\n            assert_eq(lo5, 0xffffffffffffffffu64);\n            assert_eq(hi5, 0xffffffffffffffffu64);\n        }\n    }\n}\n",
      "path": "std/ops/arith.nr"
    },
    "46": {
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n        assert(empty_slice == &[]);\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n        assert_eq(a, &[1, 2, 3]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn len_empty() {\n        let empty: [Field] = &[];\n        assert_eq(empty.len(), 0);\n    }\n\n    #[test]\n    fn len_single() {\n        assert_eq(&[42].len(), 1);\n    }\n\n    #[test]\n    fn len_multiple() {\n        assert_eq(&[1, 2, 3, 4, 5].len(), 5);\n    }\n\n    #[test]\n    fn push_back_empty() {\n        let empty: [Field] = &[];\n        let result = empty.push_back(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_back_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_back(4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test]\n    fn push_front_empty() {\n        let empty = &[];\n        let result = empty.push_front(42);\n        assert_eq(result.len(), 1);\n        assert_eq(result[0], 42);\n    }\n\n    #[test]\n    fn push_front_non_empty() {\n        let slice = &[1, 2, 3];\n        let result = slice.push_front(0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_back_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_back();\n    }\n\n    #[test]\n    fn pop_back_one() {\n        let slice = &[42];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_back_multiple() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.pop_back();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn pop_front_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.pop_front();\n    }\n\n    #[test]\n    fn pop_front_one() {\n        let slice = &[42];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 0);\n        assert_eq(elem, 42);\n    }\n\n    #[test]\n    fn pop_front_multiple() {\n        let slice = &[1, 2, 3];\n        let (elem, result) = slice.pop_front();\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn insert_beginning() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(0, 0);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[0, 1, 2, 3]);\n    }\n\n    #[test]\n    fn insert_middle() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(1, 99);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 99, 2, 3]);\n    }\n\n    #[test]\n    fn insert_end() {\n        let slice = &[1, 2, 3];\n        let result = slice.insert(3, 4);\n        assert_eq(result.len(), 4);\n        assert_eq(result, &[1, 2, 3, 4]);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn insert_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let _ = slice.insert(3, 4);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_empty() {\n        let slice: [Field] = &[];\n        let (_, _) = slice.remove(0);\n    }\n\n    #[test]\n    fn remove_beginning() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(0);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[2, 3]);\n        assert_eq(elem, 1);\n    }\n\n    #[test]\n    fn remove_middle() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(1);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 3]);\n        assert_eq(elem, 2);\n    }\n\n    #[test]\n    fn remove_end() {\n        let slice = &[1, 2, 3];\n        let (result, elem) = slice.remove(2);\n        assert_eq(result.len(), 2);\n        assert_eq(result, &[1, 2]);\n        assert_eq(elem, 3);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn remove_end_out_of_bounds() {\n        let slice = &[1, 2];\n        let (_, _) = slice.remove(2);\n    }\n\n    #[test]\n    fn fold_empty() {\n        let empty = &[];\n        let result = empty.fold(10, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn fold_single() {\n        let slice = &[5];\n        let result = slice.fold(10, |acc, x| acc + x);\n        assert_eq(result, 15);\n    }\n\n    #[test]\n    fn fold_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.fold(0, |acc, x| acc + x);\n        assert_eq(result, 10);\n    }\n\n    #[test(should_fail_with = \"Index out of bounds\")]\n    fn reduce_empty() {\n        let empty: [Field] = &[];\n        let _ = empty.reduce(|a, b| a + b);\n    }\n\n    #[test]\n    fn reduce_single() {\n        let slice = &[42];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 42);\n    }\n\n    #[test]\n    fn reduce_multiple() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.reduce(|a, b| a + b);\n        assert_eq(result, 10);\n    }\n\n    #[test]\n    fn filter_empty() {\n        let empty = &[];\n        let result = empty.filter(|x| x > 0);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 0);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn filter_all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.filter(|x| x > 10);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn filter_some() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0);\n        assert_eq(result, &[2, 4]);\n    }\n\n    #[test]\n    fn all_empty() {\n        let empty = &[];\n        let result = empty.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 0);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn all_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.all(|x| x > 2);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_empty() {\n        let empty = &[];\n        let result = empty.any(|x| x > 0);\n        assert_eq(result, false);\n    }\n\n    #[test]\n    fn any_true() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 3);\n        assert_eq(result, true);\n    }\n\n    #[test]\n    fn any_false() {\n        let slice = &[1, 2, 3, 4];\n        let result = slice.any(|x| x > 10);\n        assert_eq(result, false);\n    }\n\n    // utility method tests\n    #[test]\n    fn append_empty_to_empty() {\n        let empty1: [Field] = &[];\n        let empty2: [Field] = &[];\n        let result = empty1.append(empty2);\n        assert_eq(result.len(), 0);\n    }\n\n    #[test]\n    fn append_empty_to_non_empty() {\n        let slice = &[1, 2, 3];\n        let empty = &[];\n        let result = slice.append(empty);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_non_empty_to_empty() {\n        let empty = &[];\n        let slice = &[1, 2, 3];\n        let result = empty.append(slice);\n        assert_eq(result, slice);\n    }\n\n    #[test]\n    fn append_two_non_empty() {\n        let slice1 = &[1, 2];\n        let slice2 = &[3, 4, 5];\n        let result = slice1.append(slice2);\n        assert_eq(result, &[1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    fn as_array_single() {\n        let slice = &[42];\n        let array: [Field; 1] = slice.as_array();\n        assert_eq(array[0], 42);\n    }\n\n    #[test]\n    fn as_array_multiple() {\n        let slice = &[1, 2, 3];\n        let array: [Field; 3] = slice.as_array();\n        assert_eq(array[0], 1);\n        assert_eq(array[1], 2);\n        assert_eq(array[2], 3);\n    }\n\n    // complex scenarios\n    #[test]\n    fn chain_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n        let result = slice.filter(|x| x % 2 == 0).map(|x| x * 2).fold(0, |acc, x| acc + x);\n        assert_eq(result, 12); // (2*2) + (4*2) = 4 + 8 = 12\n    }\n\n    #[test]\n    fn nested_operations() {\n        let slice = &[1, 2, 3, 4];\n        let filtered = slice.filter(|x| x > 1);\n        let mapped = filtered.map(|x| x * x);\n        let sum = mapped.fold(0, |acc, x| acc + x);\n        assert_eq(sum, 29); // 2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29\n    }\n\n    #[test]\n    fn single_element_operations() {\n        let single = &[42];\n\n        // Test all operations on single element\n        assert_eq(single.len(), 1);\n\n        let pushed_back = single.push_back(99);\n        assert_eq(pushed_back, &[42, 99]);\n\n        let pushed_front = single.push_front(0);\n        assert_eq(pushed_front, &[0, 42]);\n\n        let (popped_back_slice, popped_back_elem) = single.pop_back();\n        assert_eq(popped_back_slice.len(), 0);\n        assert_eq(popped_back_elem, 42);\n\n        let (popped_front_elem, popped_front_slice) = single.pop_front();\n        assert_eq(popped_front_slice.len(), 0);\n        assert_eq(popped_front_elem, 42);\n\n        let inserted = single.insert(0, 0);\n        assert_eq(inserted, &[0, 42]);\n\n        let (removed_slice, removed_elem) = single.remove(0);\n        assert_eq(removed_slice.len(), 0);\n        assert_eq(removed_elem, 42);\n    }\n\n    #[test]\n    fn boundary_conditions() {\n        let slice = &[1, 2, 3];\n\n        // insert at boundaries\n        let at_start = slice.insert(0, 0);\n        assert_eq(at_start, &[0, 1, 2, 3]);\n\n        let at_end = slice.insert(3, 4);\n        assert_eq(at_end, &[1, 2, 3, 4]);\n\n        // remove at boundaries\n        let (removed_start, elem_start) = slice.remove(0);\n        assert_eq(removed_start, &[2, 3]);\n        assert_eq(elem_start, 1);\n\n        let (removed_end, elem_end) = slice.remove(2);\n        assert_eq(removed_end, &[1, 2]);\n        assert_eq(elem_end, 3);\n    }\n\n    #[test]\n    fn complex_predicates() {\n        let slice = &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n\n        let even_greater_than_5 = slice.filter(|x| (x % 2 == 0) & (x > 5));\n        assert_eq(even_greater_than_5, &[6, 8, 10]);\n\n        let all_positive_and_less_than_20 = slice.all(|x| (x > 0) & (x < 20));\n        assert_eq(all_positive_and_less_than_20, true);\n\n        let any_divisible_by_7 = slice.any(|x| x % 7 == 0);\n        assert_eq(any_divisible_by_7, true);\n    }\n\n    #[test]\n    fn identity_operations() {\n        let slice = &[1, 2, 3, 4, 5];\n\n        let mapped_identity = slice.map(|x| x);\n        assert_eq(mapped_identity, slice);\n\n        let filtered_all = slice.filter(|_| true);\n        assert_eq(filtered_all, slice);\n\n        let filtered_none = slice.filter(|_| false);\n        assert_eq(filtered_none.len(), 0);\n    }\n\n    #[test(should_fail)]\n    fn as_array_size_mismatch() {\n        let slice = &[1, 2, 3];\n        let _: [Field; 5] = slice.as_array(); // size doesn't match\n    }\n}\n",
      "path": "std/slice.nr"
    },
    "50": {
      "source": "use dep::bignum;\nuse dep::bignum::BigNum;\nuse dep::bignum::fields::U256::U256;\nuse edwards::bjj::BabyJubJubParams;\nuse std::field::bn254::assert_lt;\nuse std::hash::blake2s;\n\n// This is the constant for VerifyWitness0 hashing\nglobal HASH_HEADER_CONSTANT: [u8; 32] = [0; 32]; //TODO: Create a domain-separation constant\n\n/// Verify witness_0 [no given]\nfn VerifyWitness0(\n    nonce_peer: Field,\n    T_0: edwards::Curve<BabyJubJubParams>,\n    witness_0: Field,\n    blinding: Field,\n) {\n    assert(nonce_peer != 0);\n    assert(witness_0 != 0);\n    assert(blinding != 0);\n    assert_lt(nonce_peer, library::BABY_JUBJUB_ORDER_PLUS_ONE);\n    assert_lt(witness_0, library::BABY_JUBJUB_ORDER_PLUS_ONE);\n    assert_lt(blinding, library::BABY_JUBJUB_ORDER_PLUS_ONE);\n\n    //Create hash (random oracle) from both peers' entropy to ensure uniqueness\n    let constant_slice: [u8] = HASH_HEADER_CONSTANT.as_slice();\n    let nonce_peer_array: [u8; 32] = nonce_peer.to_be_bytes();\n    let blinding_array: [u8; 32] = blinding.to_be_bytes();\n\n    let pre_image_slice: [u8] = constant_slice.append(nonce_peer_array).append(blinding_array);\n    let pre_image_array: [u8; 96] = pre_image_slice.as_array();\n    let hash_bytes: [u8; 32] = blake2s(pre_image_array);\n    let hash_bytes_slice: [u8] = hash_bytes.as_slice();\n    // U256 from_be_bytes expects 32 bytes + 1 byte for potential overflow\n    // We add a leading 0u8 since our data won't use the full 256-bit range and is ignored in the modulo\n    let hash_bytes_33: [u8] = &[0].append(hash_bytes_slice);\n    let hash_bignum: U256 = U256::from_be_bytes(hash_bytes_33.as_array());\n\n    //Clamp to Baby Jubjub order\n    let l_bignum: U256 = U256::from(library::BABY_JUBJUB_ORDER);\n\n    let witness_0_calc_bignum = hash_bignum.umod(l_bignum);\n    let mut witness_0_calc_field = bignum::bignum::to_field(witness_0_calc_bignum);\n    if witness_0_calc_field == 0 {\n        witness_0_calc_field = library::BABY_JUBJUB_ORDER;\n    }\n\n    assert_lt(witness_0_calc_field, library::BABY_JUBJUB_ORDER_PLUS_ONE); //TODO: Is this necessary since the function has already been calculated?\n    // Ensure the witness matches the reduced hash\n    assert_eq(witness_0_calc_field, witness_0);\n\n    library::VerifyTi(T_0, witness_0);\n}\n\n/// Verify protocol conformance of encryption of `witness_0` to KES [given VerifyWitness0()]\nfn EncryptToKES(\n    witness_0: Field,\n    fi_2: edwards::Curve<BabyJubJubParams>,\n    enc_2: Field,\n    r_2: Field,\n    pubkey_KES: edwards::Curve<BabyJubJubParams>,\n) {\n    // Given: VerifyWitness0(nonce_peer, T_0, witness_0, blinding);\n\n    //Encrypt to KES\n    let (fi_2_calc, enc_2_calc) = library::VerifyEncryptMessage_ECDH(witness_0, r_2, pubkey_KES);\n    assert_eq(fi_2_calc, fi_2);\n    assert_eq(enc_2_calc, enc_2);\n}\n\n/// Main function for initialization\nfn main(\n    nonce_peer: pub Field,\n    T_0: pub edwards::Curve<BabyJubJubParams>,\n    witness_0: Field,\n    blinding: Field,\n    fi_2: edwards::Curve<BabyJubJubParams>,\n    enc_2: Field,\n    r_2: Field,\n    pubkey_KES: pub edwards::Curve<BabyJubJubParams>,\n    challenge_bytes: pub [u8; 32],\n    blinding_DLEQ: Field,\n    response_div_BabyJubJub: [u8; 32],\n    response_BabyJubJub: Field,\n    response_div_ed25519: [u8; 32],\n    response_ed25519: [u8; 32],\n) {\n    VerifyWitness0(nonce_peer, T_0, witness_0, blinding);\n\n    EncryptToKES(witness_0, fi_2, enc_2, r_2, pubkey_KES);\n\n    library::VerifyEquivalentModulo(\n        challenge_bytes,\n        blinding_DLEQ,\n        witness_0,\n        response_div_BabyJubJub,\n        response_BabyJubJub,\n        response_div_ed25519,\n        response_ed25519,\n    );\n}\n",
      "path": "/home/code/projects/grease/circuits/init/src/main.nr"
    },
    "53": {
      "source": "use crate::fns::constrained_ops::limbs_to_field;\nuse crate::params::BigNumParams;\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub trait BigNum: Neg + Add + Sub + Mul + Div + Eq {\n    let N: u32;\n    let MOD_BITS: u32;\n\n    fn params() -> BigNumParams<N, MOD_BITS>;\n    fn modulus_bits(_: Self) -> u32;\n    fn num_limbs(_: Self) -> u32;\n    fn modulus() -> Self;\n\n    fn new() -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn from_limbs(limbs: [u128; N]) -> Self;\n    fn get_limbs(self) -> [u128; N];\n    fn set_limb(self: &mut Self, idx: u32, value: u128);\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    fn from_be_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n    fn from_le_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n\n    fn get_limb(self: Self, idx: u32) -> u128 {\n        self.get_limbs()[idx]\n    }\n\n    unconstrained fn __eq(self: Self, other: Self) -> bool;\n\n    unconstrained fn __is_zero(self: Self) -> bool;\n\n    unconstrained fn __neg(self) -> Self;\n    unconstrained fn __add(self, other: Self) -> Self;\n    unconstrained fn __sub(self, other: Self) -> Self;\n    unconstrained fn __mul(self, other: Self) -> Self;\n    unconstrained fn __sqr(self) -> Self;\n    unconstrained fn __div(self, other: Self) -> Self;\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    unconstrained fn __invmod(self) -> Self;\n    unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n    unconstrained fn __sqrt(self) -> std::option::Option<Self>;\n\n    fn assert_is_not_equal(self: Self, other: Self);\n\n    fn validate_in_range(self);\n    fn validate_in_field(self);\n\n    fn sqr(self) -> Self;\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    fn udiv(self, divisor: Self) -> Self;\n    fn umod(self, divisor: Self) -> Self;\n\n    fn is_zero(self) -> bool;\n    fn is_zero_integer(self) -> bool;\n    fn assert_is_not_zero(self);\n    fn assert_is_not_zero_integer(self);\n}\n\n// we need macros that implement the BigNum, Default, From, Neg, Add, Sub, Mul, Div, Eq, Ord traits for each bignum type\npub comptime fn derive_bignum(\n    strukt: TypeDefinition,\n    N: u32,\n    MOD_BITS: u32,\n    params: Quoted,\n) -> Quoted {\n    let constrained_ops = quote { $crate::fns::constrained_ops };\n    let unconstrained_ops = quote { $crate::fns::unconstrained_ops };\n    let typ = strukt.as_type();\n    let serialization = quote { $crate::fns::serialization };\n    quote {\n\n        // implement BigNum for BigNum \n        impl $crate::BigNum for $typ {\n            let N: u32 = $N; \n            let MOD_BITS: u32 = $MOD_BITS;\n            \n            fn modulus_bits(_: Self) -> u32 {\n                $MOD_BITS\n            }\n            \n            fn num_limbs(_: Self) -> u32 {\n                $N\n            }\n\n            fn modulus() -> Self {\n                Self { limbs: Self::params().modulus }\n            }\n\n            fn new() -> Self {\n                Self {limbs: [0; $N]}\n            }\n\n            fn params() -> $crate::params::BigNumParams<$N, $MOD_BITS> {\n                $params\n            }\n\n            fn from_limbs(limbs: [u128; $N]) -> Self {\n                Self { limbs }\n            }\n\n            fn get_limbs(self: Self) -> [u128; $N] {\n                self.limbs\n            }\n\n            fn set_limb(self: &mut Self, idx: u32, value: u128) {\n                self.limbs[idx] = value;\n            }\n\n            fn zero() -> Self {\n                Self { limbs: [0; $N] }\n            }\n\n            fn one() -> Self {\n                let mut limbs = [0; $N];\n                limbs[0] = 1;\n                Self { limbs }\n            }\n\n            fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                $typ::from_limbs($constrained_ops::derive_from_seed::<_, $MOD_BITS, _>(params, seed))\n            }\n\n            unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                Self { limbs: $unconstrained_ops::__derive_from_seed::<_, $MOD_BITS, _>(params, seed) }\n            }\n\n            fn from_be_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_be_bytes::<_, $MOD_BITS>(x) }\n            }\n            \n            fn to_be_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_be_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            fn from_le_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_le_bytes::<_, $MOD_BITS>(x) }\n            }\n\n            fn to_le_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_le_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            unconstrained fn __eq(self: Self, other: Self) -> bool {\n                $crate::fns::unconstrained_ops::__eq(self.get_limbs(), other.get_limbs())\n            }\n\n            unconstrained fn __is_zero(self: Self) -> bool {\n                $crate::fns::unconstrained_ops::__is_zero(self.get_limbs())\n            }\n\n            unconstrained fn __neg(self: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__neg(params.modulus, self.get_limbs())}\n            }\n\n            unconstrained fn __add(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__add(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __sub(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__sub(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __mul(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__mul(params, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __sqr(self: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__sqr(params, self.get_limbs()) }\n            }\n\n            unconstrained fn __div(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__div(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            unconstrained fn __udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let (q, r) = $unconstrained_ops::__udiv_mod(self.get_limbs(), divisor.get_limbs());\n                (Self{limbs: q}, Self{limbs: r})\n            }\n\n            unconstrained fn __invmod(self: Self) -> Self {\n                let params = Self::params();\n                assert(params.has_multiplicative_inverse);\n                Self {limbs: $unconstrained_ops::__invmod(params, self.get_limbs())}\n            }\n\n            unconstrained fn __pow(self: Self, exponent: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__pow(params, self.get_limbs(), exponent.get_limbs())}\n            }\n\n            #[deprecated(\"use __sqrt\")]\n            unconstrained fn __tonelli_shanks_sqrt(self: Self) -> std::option::Option<Self> {\n                let params = Self::params();\n                let maybe_limbs = $unconstrained_ops::__sqrt(params, self.get_limbs());\n                maybe_limbs.map(|limbs| Self {limbs: limbs})\n            }\n\n            unconstrained fn __sqrt(self: Self) -> std::option::Option<Self> {\n                let params = Self::params();\n                let maybe_limbs = $unconstrained_ops::__sqrt(params, self.get_limbs());\n                maybe_limbs.map(|limbs| Self {limbs: limbs })\n            }\n\n            fn assert_is_not_equal(self: Self, other: Self) {\n                let params = Self::params();\n                $crate::fns::constrained_ops::assert_is_not_equal(\n                    params,\n                    self.get_limbs(),\n                    other.get_limbs(),\n                );\n            }\n\n            fn validate_in_field(self: Self) {\n                let params = Self::params();\n                $constrained_ops::validate_in_field::<_, $MOD_BITS>(params, self.get_limbs());\n            }\n\n            fn validate_in_range(self: Self) {\n                $constrained_ops::validate_in_range::<_, _, $MOD_BITS>(self.get_limbs());\n            }\n\n            fn sqr(self: Self) -> Self {\n                let params = Self::params();\n                Self { limbs: $constrained_ops::sqr::<$N, $MOD_BITS>(params, self.get_limbs()) }\n            }\n\n            fn udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let (q, r) = $constrained_ops::udiv_mod::<$N, $MOD_BITS>(self.get_limbs(), divisor.get_limbs());\n                (Self {limbs: q}, Self {limbs: r})\n            }\n\n            fn udiv(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::udiv::<$N, $MOD_BITS>(self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn umod(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::umod::<$N, $MOD_BITS>(self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn is_zero(self: Self) -> bool {\n                let params = Self::params();\n                $constrained_ops::is_zero::<$N, $MOD_BITS>(params, self.get_limbs())\n            }\n\n            fn is_zero_integer(self: Self) -> bool {\n                $constrained_ops::is_zero_integer(self.get_limbs())\n            }\n\n            fn assert_is_not_zero(self: Self) {\n                let params = Self::params();\n                $constrained_ops::assert_is_not_zero::<$N, $MOD_BITS>(params, self.get_limbs());\n            }\n\n            fn assert_is_not_zero_integer(self: Self) {\n                $constrained_ops::assert_is_not_zero_integer(self.get_limbs());\n            }\n        }\n\n        // implement Default for BigNum\n        impl Default for $typ {\n            fn default() -> Self {\n                $typ::from_limbs([0; $N])\n            }\n        }\n\n        impl std::convert::From<Field> for $typ {\n            fn from(input: Field) -> Self {\n                $typ { limbs: $constrained_ops::from_field::<$N, $MOD_BITS>($params, input) }\n            }\n        }\n\n        impl std::ops::Neg for $typ {\n            fn neg(self) -> Self {\n                $typ { limbs: $constrained_ops::neg::<$N, $MOD_BITS>($params, self.limbs) }\n            }\n        }\n\n        impl std::ops::Add for $typ {\n            fn add(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::add::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Sub for $typ {\n            fn sub(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::sub::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Mul for $typ {\n            fn mul(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::mul::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Div for $typ {\n            fn div(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::div::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::cmp::Eq for $typ {\n            fn eq(self, other: Self) -> bool {\n                $constrained_ops::eq::<$N, $MOD_BITS>($params, self.limbs, other.limbs)\n            }\n        }\n\n        impl std::cmp::Ord for $typ {\n            fn cmp(self, other: Self) -> std::cmp::Ordering {\n                $constrained_ops::cmp::<$N, $MOD_BITS>(self.limbs, other.limbs)\n            }\n        }\n\n    }\n}\n\npub fn conditional_select<T: BigNum>(lhs: T, rhs: T, predicate: bool) -> T {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub unconstrained fn compute_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (T, T) {\n    let params = T::params();\n    let (q_limbs, r_limbs) = crate::fns::expressions::__compute_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    );\n    (T::from_limbs(q_limbs), T::from_limbs(r_limbs))\n}\n\npub fn evaluate_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    let params = T::params();\n    crate::fns::expressions::evaluate_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    )\n}\n\npub unconstrained fn batch_invert<T: BigNum, let M: u32>(x: [T; M]) -> [T; M] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert(params, x.map(|bn: T| bn.get_limbs())).map(|limbs| {\n        T::from_limbs(limbs)\n    })\n}\n\npub unconstrained fn batch_invert_slice<T: BigNum>(x: [T]) -> [T] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert_slice(params, x.map(|bn: T| bn.get_limbs()))\n        .map(|limbs| T::from_limbs(limbs))\n}\n\npub fn to_field<T: BigNum>(bn: T) -> Field {\n    let params = T::params();\n    limbs_to_field(params, bn.get_limbs())\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/bignum.nr"
    },
    "85": {
      "source": "use crate::constants::{GRUMPKIN_MODULUS, TWO_POW_120, TWO_POW_240};\n\nuse crate::fns::{\n    expressions::{evaluate_quadratic_expression, validate_udiv_mod_expression},\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags,\n        __validate_gte_with_flags, __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sqr, __sub, __udiv_mod},\n};\n\nuse crate::params::BigNumParams;\n\nuse std::cmp::Ordering;\n\n/// Lift the limbs of a `BigNum` value onto the circuit `Field`\n///\n/// Descent the `BigNum` value back into the `Field` and\n///    - check that it's a proper `BigNum` value\n///    - validate the limbs sum up to a `Field` value\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: BigNumParams<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    validate_in_range::<u128, N, MOD_BITS>(limbs);\n    if N > 2 {\n        // validate that the `BigNum` is less than the Grumpkin modulus\n        let mut grumpkin_modulus: [u128; N] = [0; N];\n        grumpkin_modulus[0] = GRUMPKIN_MODULUS[0];\n        grumpkin_modulus[1] = GRUMPKIN_MODULUS[1];\n        grumpkin_modulus[2] = GRUMPKIN_MODULUS[2];\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n    }\n\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        (limbs[0] as Field) + (limbs[1] as Field) * (TWO_POW_120 as Field)\n    } else {\n        (limbs[0] as Field)\n            + (limbs[1] as Field) * (TWO_POW_120 as Field)\n            + (limbs[2] as Field) * TWO_POW_240\n    }\n}\n\n/// Construct a `BigNum` value from a native `Field`\n///\n/// Decomposes the `Field` value into 120-bit limbs\n/// then we have three cases:\n///     - MOD_BITS < 253 (grumpkin_mod_bits - 1): it is enough to call for `validate_in_field`, which is basically `val <= MOD`\n///     - MOD_BITS > 253: we need to verify that the obtained `BigNum` `val < GRUMPKIN_MODULUS`\n///     - MOD_BITS = 253: verify that `val < min(MOD, GRUMPKIN_MODULUS)`\n/// Next we verify that all the limbs are properly ranged\n/// and that the accumulated limbs are equal to the input `Field` value\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: BigNumParams<N, MOD_BITS>,\n    val: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(val) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            let mut grumpkin_modulus: [u128; N] = [0; N];\n            grumpkin_modulus[0] = GRUMPKIN_MODULUS[0];\n            grumpkin_modulus[1] = GRUMPKIN_MODULUS[1];\n            grumpkin_modulus[2] = GRUMPKIN_MODULUS[2];\n\n            if MOD_BITS > 253 {\n                // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n                // also for correct params N is always larger than 3 here\n                validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            } else {\n                // this is the tricky part, when MOD_BITS = 253, we have to compare the limbs of the modulus to the grumpkin modulus limbs\n                // any `BigNum` with 253 bits will have 3 limbs\n\n                // if MOD is less than grumpkin modulus, this will be true\n                let mut mod_lt_grumpkin: bool = false;\n                for i in 0..3 {\n                    if !mod_lt_grumpkin & (_params.modulus[2 - i] < grumpkin_modulus[2 - i]) {\n                        mod_lt_grumpkin = true;\n                    }\n                }\n                let min_modulus: [u128; N] = if mod_lt_grumpkin {\n                    _params.modulus\n                } else {\n                    grumpkin_modulus\n                };\n                validate_gt::<N, MOD_BITS>(min_modulus, result);\n            }\n        }\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        // validate the limbs sum up to the field value\n        let field_val: Field = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            (result[0] as Field) + (result[1] as Field) * (TWO_POW_120 as Field)\n        } else {\n            (result[0] as Field)\n                + (result[1] as Field) * (TWO_POW_120 as Field)\n                + (result[2] as Field) * TWO_POW_240\n        };\n        assert_eq(field_val, val);\n    }\n\n    result\n}\n\n/// Given an input seed, generate a pseudorandom `BigNum` value\n///\n/// This function *should* produce a uniformly randomly distributed value modulo `MOD`\n///\n///  First we take the seed and pack it's 31-byte chunks into `Field`s\n///  We use a hash function that can be modelled as a random oracle\n///  We hash the packed seed using Poseidon2 to produce `MOD_BITS * 2` bits of entropy\n///\n///  From these bits we construct 4(in case N = 2) or 3(N > 2) `BigNum` values:\n///  - We fill first `N - 1` limbs and leave the top limb empty\n///\n///  Then we accumulate the resulting BigNum values using:\n///  B = 2^{120 * (N - 1)}\n///  res = x3 + B * x2 + B^2 * x1 + B^3 * x0\n///\n/// ## Note\n/// This function will always produce an `x3` `BigNum`\n/// If `MOD = 2^{120 * (N - 1)}`\n/// It will use only `MOD_BITS - 1` bits of entropy\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    // Pack seed bytes into Fields.\n    // For the seed of length M, we construct a rolling_hash_field of size ceil(M / 31).\n    // i.e.  31 bytes per Field\n    // NOTE: the Fields produced are 248 bits in size\n    let mut rolling_hash_fields: [Field; (SeedBytes + 30) / 31] = [0; (SeedBytes + 30) / 31];\n    let mut seed_ptr: u32 = 0;\n    for i in 0..(SeedBytes + 30) / 31 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed: Field =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes + 30) / 31);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    // 120 bit limb has 15 bytes in it\n    // we buffer (N * 15) * 2 bytes for 2N limbs\n    let mut hash_buffer: [u8; N * 15 * 2] = [0; N * 15 * 2];\n\n    // We produce 32 bytes (254 bits) per hash iteration\n    // We take only 30 bytes, so we need ceil(N * 2 * 15 / 30) hashes to fill them up\n    for i in 0..N {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    let num_bits: u32 = MOD_BITS * 2;\n    let num_bytes: u32 = (num_bits + 7) / 8;\n\n    // Truncate the final byte that will be used in `BigNum` creation\n    let bits_in_last_byte: u8 = (num_bits as u8) % 8;\n    if bits_in_last_byte != 0 {\n        let last_byte_mask: u8 = ((1 as u8) << bits_in_last_byte) - 1;\n        hash_buffer[num_bytes - 1] &= last_byte_mask;\n    }\n\n    let num_bigfield_chunks: u32 = if N == 2 { 4 } else { 3 };\n    let mut byte_ptr: u32 = 0;\n\n    // We want to convert our hash_buffer into bigfield chunks, with each `BigNum` having at most N - 1 limbs filled\n    // We sample only N - 1 limbs mostly because we do not wont to deal with accidental overflows in the top limb\n    // In any case the security is preserved\n    //\n    // For all integer values N > 1, the number of chunks is either 4(for N = 2) or 3(for N > 2) (ceil(2*N / (N - 1)))\n    //\n    // To determine the exact number of chunks, we need the `!=` or `>` operator which is not available when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n\n        // Before the current limb, we filled out (N - 1) limbs, k times\n        // 15 bytes per limb\n        // resulting in total of 15 * k * (N - 1)\n        let mut num_filled_bytes: u32 = 15 * k * (N - 1);\n        if num_bytes > num_filled_bytes {\n            // Static assert for completeness\n            assert(num_filled_bytes == byte_ptr);\n\n            let mut num_remaining_bytes_to_sample: u32 = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs_to_sample: u32 = (num_remaining_bytes_to_sample + 14) / 15;\n\n            // Sample at most (N - 1) limbs from hash_buffer\n            let mut num_limbs_to_sample: u32 = if num_remaining_limbs_to_sample > (N - 1) {\n                N - 1\n            } else {\n                num_remaining_limbs_to_sample\n            };\n\n            for j in 0..num_limbs_to_sample {\n                let mut limb: Field = 0;\n                // Construct a 120 bit limb\n                for _ in 0..15 {\n                    if byte_ptr < num_bytes {\n                        let mut byte: u8 = hash_buffer[byte_ptr];\n                        limb *= 256;\n                        limb += byte as Field;\n                        byte_ptr += 1;\n                    }\n                }\n                // crucial for performance\n                limb.assert_max_bit_size::<120>();\n                // Accumulate limbs from top to bottom\n                bigfield_limbs[num_limbs_to_sample - 1 - j] = limb as u128;\n            }\n            // Accumulate `BigNum` values from top to bottom\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    // B = 2^{120 * (N - 1)}, we know it is \\leq `MOD`, since the top limb\n    // have to be at least one\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n\n    let mut result: [u128; N] = bigfield_chunks[0];\n\n    for i in 1..num_bigfield_chunks {\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_chunks[i]);\n    }\n\n    result\n}\n\n// ------------------------------ COMPARISON FUNCTIONS ------------------------------\n\n/// Validate lhs != rhs\n///\n/// We compare `A` and `B` via their encodings in the circuit `Field`\n///\n/// Under our range assumptions, equality in `Field` implies equality of the underlying\n/// `BigNum` values, hence equality (mod `MOD`)\n///\n/// In this library it is possible that A or B is a little bit greater than `MOD`\n/// So A == B (mod `MOD`) implies that A == B, A == B + MOD or A == B - MOD over the integers\n/// Hence we can compute everything (mod p) and constrain that\n/// (A - B) * (A - B + MOD) * (A - B - MOD) != 0 (mod p)\n///\n/// ## Soundness\n/// This method is *sound* for checking `A != B (mod MOD)`\n///\n/// If `A == B (mod MOD)`, then `A - B` is in `{0, +-MOD}` as an integer,\n/// so one of the factors `A-B`, `A-B+MOD`, `A-B-MOD` is zero in `Field`, and the product is zero\n/// Therefore, whenever the assertion `target != 0` holds, we must have `A != B (mod MOD)`\n/// under our range assumptions\n///\n/// ## Completeness\n/// In general, this method is not *complete*: if the admissible range of `A` and `B`\n/// is large enough relative to the circuit `Field` prime `p`, an honest prover with\n/// `A != B (mod MOD)` can still hit an alias where\n///     (A - B) * (A - B + MOD) * (A - B - MOD) == 0 (mod p),\n/// i.e.\n///     - A = B       (mod p), or\n///     - A = B + MOD (mod p), or\n///     - A = B - MOD (mod p).\n///\n/// For random `A, B` in such a wide range, the probability of this collision is\n/// roughly 3/p.\n///\n/// In case `MOD` < `p` this function becomes *complete*\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_p: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_p *= TWO_POW_120 as Field;\n\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_p += params.modulus[N - i - 1] as Field;\n    }\n\n    let diff: Field = l - r;\n    let target: Field = diff * (diff + modulus_mod_p) * (diff - modulus_mod_p);\n    assert(target != 0, \"assert_is_not_equal fail\");\n}\n\n/// Compute equality flag\n///\n/// A == B (mod MOD)\n/// We compute A - B and check whether it is `0` or `MOD`\n/// This is due to subtract constrains the diff value to be < 2^MOD_BITS, not < `MOD`\n///\n/// ## Soundness\n/// This function is conditionally *sound*. See `sub` for details\n///\n/// ## Completeness\n/// This function is *complete*. An honest prover will always be able to execute it.\n///\n/// ## TODO\n/// can do this more efficiently via witngen in unconstrained functions?\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff: [u128; N] = sub::<N, MOD_BITS>(params, lhs, rhs);\n    is_zero::<N, MOD_BITS>(params, diff)\n}\n\n/// Validate that `val` is not equal to zero when interpreted as an integer.\n///\n/// This enforces that at least one limb of `val` is non-zero.\n/// It does *not* check \"BigNum zero\" in the modular sense (e.g. it\n/// treats `MOD` as non-zero).\n///\n/// ## Assumptions\n/// * Each limb of `val` is range-constrained to be a 120-bit value:\n///   `0 <= val[i] < 2^120`.\n/// * For our concrete fields and limb counts we have `N * 2^120 < p`,\n///   so the sum of all limbs fits strictly inside the field modulus.\n///\n/// ## Completeness\n/// If `val` is non-zero as an integer, then at least one limb is non-zero,\n/// so the integer sum of the limbs satisfies `0 < limb_sum < p`. In this\n/// case `limb_sum != 0` in the `Field`, and the assertion passes.\n///\n/// ## Soundness\n/// If all limbs of `val` are zero, then `limb_sum` is zero as an integer\n/// and as a field element, so the assertion fails. A witness representing\n/// the zero integer can never satisfy this check.\n///\n/// ## Note\n/// This is slightly cheaper than doing `val != [0; N]`, as we avoid\n/// creating per-limb boolean equalities and chaining them with `and`s.\npub(crate) fn assert_is_not_zero_integer<let N: u32>(val: [u128; N]) {\n    let mut limb_sum: Field = 0;\n    for i in 0..N {\n        limb_sum += val[i] as Field;\n    }\n    assert(limb_sum != 0, \"assert_is_not_zero_integer fail\");\n}\n\n/// Check whether `val` is the zero `BigNum` in the integer sense.\n///\n/// This returns `true` iff all limbs of `val` are zero. It does *not*\n/// treat `MOD` as zero; for modular `BigNum` zero use `is_zero`.\n///\n/// See `assert_is_not_zero_integer` for the underlying assumptions.\n///\n/// ## Note\n/// This is slightly cheaper than testing `val == [0; N]`, as we avoid\n/// creating per-limb boolean equalities and chaining them with `and`s.\npub(crate) fn is_zero_integer<let N: u32>(val: [u128; N]) -> bool {\n    let mut limb_sum: Field = 0;\n    for i in 0..N {\n        limb_sum += val[i] as Field;\n    }\n    limb_sum == 0\n}\n\n/// Validate that a `BigNum` value is not zero modulo `MOD`.\n///\n/// Convenience wrapper around `assert_is_not_equal`.\npub(crate) fn assert_is_not_zero<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    assert_is_not_equal::<N, MOD_BITS>(params, val, [0; N]);\n}\n\n/// Check whether a `BigNum` value is zero modulo `MOD`.\n///\n/// This treats both the all-zero limb vector and `params.modulus` as\n/// representing zero. It assumes that all valid `BigNum` values are\n/// range-constrained so that no other representatives of `0 (mod MOD)`\n/// can appear.\n///\n/// ## Note\n/// This is cheaper than calling `eq(val, [0; N])`\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> bool {\n    is_zero_integer(val) | (val == params.modulus)\n}\n\n/// Validate a `BigNum` instance is correctly range constrained to contain no more than `MOD_BITS` bits\n///\n/// Constrain the `BigNum` instance to be < 2^MOD_BITS by:\n///     - Constraining each limb(0..N-2) to be 120-bit limb\n///     - Constraining the last limb to be `MOD_BITS - 120 * (N - 1)`\n///\n/// ## Note\n/// This can be a very expensive function, when the `TOP_LIMB_BITS` is uncommon\n///\n/// For example: BLS12_377Fr, with `TOP_LIMB_BITS`=13\n/// It creates a new 13-bit range table, which consists of roughly 3k variables\n/// And ~2k circuit gates\n///\n/// Compare this to BLS12_377Fq, with `TOP_LIMB_BITS`=17\n/// It is nicely decomposed into\n/// 14-bit range check and 3-bit range check - much much cheaper, since 14-bit range checks\n/// are already pretty common for 120-bit range checks\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/// Validate quotient produced from `evaluate_quadratic_expression` is well-formed\n///\n/// Because the inputs into `evaluate_quadratic_expression` may cause the quotient to extend beyond `Params::modulus_bits`.\n///           We allow the quotient to extend `6` bits beyond `Params::modulus_bits()`\n///           Why is this?\n///           several factors:    1. quotient * modulus , limbs cannot overflow `Field` boundary (254 bits)\n///                               2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n///                                  limbs cannot exceed `246` bits (246 magic number due to a higher number adding extra range check gates)\n///           because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be > 126 bits\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N - 1) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - (N - 1) * 120 + 6>();\n}\n\n/// Validate that `lhs - rhs` does not underflow i.e. that lhs > rhs over the integers\n///\n/// Compute `result = lhs - rhs` along with `borrow_flags`,\n/// then constrain `result` to be a valid `BigNum` value.\n///\n/// ## Completeness\n/// This function is complete and will work only if `lhs > rhs` over the integers.\n///\n/// ## Soundness\n/// This function is sound:\n///     result[0]     = lhs[0]     - rhs[0]     + bf[0] * 2^{120}             < 2^{120}\n///     result[i]     = lhs[i]     - rhs[i]     + bf[i] * 2^{120} - bf[i - 1] < 2^{120},  i = 1..N-2\n///     result[N - 1] = lhs[N - 1] - rhs[N - 1]                   - bf[N - 2] < 2^{TOP_LIMB_BITS}\n///     result != 0\n///\n/// If `lhs < rhs`, then some limb of `result` would have to borrow from a higher limb,\n/// which is impossible because the top limb cannot borrow\n/// Without the extra borrow, the resulting difference will be wrapped around the `Field` modulus\n/// And won't satisfy the range constraint, since all the limbs are < 2^120\n///\n/// ## Note\n/// `assert_is_not_zero_integer(result)` is crucial. Without it, we could always provide\n/// two identical inputs `x`, `x` and set `borrow_flags = [false; N]`,\n/// which would satisfy the limb constraints.\n///\n/// Also note that `underflow` is not properly constrained, so it just hangs there for\n/// completeness\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // Safety: compute borrow flags out-of-circuit\n    let (underflow, result, borrow_flags): (bool, [u128; N], [bool; N - 1]) =\n        unsafe { __validate_gte_with_flags(lhs, rhs) };\n\n    // Completeness: require that no underflow occurred\n    assert(!underflow, \"validate_gt fail\");\n\n    // Constrain the `result` to be a valid `BigNum` value\n    validate_in_range::<u128, N, MOD_BITS>(result);\n    // Constrain it to be strict inequality\n    assert_is_not_zero_integer(result);\n\n    // Constrain `result` and `borrow_flags` to match the expected arithmetic\n    check_gte_with_flags(lhs, rhs, result, borrow_flags);\n}\n\n/// Constraining function for the results of `__validate_gte_with_flags`,\n/// used by both `cmp` and `validate gt`\n///\n/// This function checks the relations between `lhs`, `rhs`, `result` adn `borrow_flags`:\n///     lhs[0]     - rhs[0]     - result[0]     + bf[0] * 2^{120}             = 0\n///     lhs[i]     - rhs[i]     - result[i]     + bf[i] * 2^{120} - bf[i - 1] = 0,  i = 1..N-2\n///     lhs[N - 1] - rhs[N - 1] - result[N - 1]                   - bf[N - 2] = 0\npub(crate) fn check_gte_with_flags<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N - 1],\n) {\n    let result_limb: Field = (lhs[0] as Field) - (rhs[0] as Field) - (result[0] as Field)\n        + (borrow_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb: Field = (lhs[i] as Field) - (rhs[i] as Field) - (result[i] as Field)\n            + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n            - (borrow_flags[i - 1] as Field);\n        assert(result_limb == 0);\n    }\n\n    let result_limb: Field = (lhs[N - 1] as Field)\n        - (rhs[N - 1] as Field)\n        - (result[N - 1] as Field)\n        - (borrow_flags[N - 2] as Field);\n    assert(result_limb == 0);\n}\n\n/// Validate that `val` <= `MOD`\n///\n/// Compute `result = MOD - val` along with `borrow_flags`,\n/// then constrain `result` to be a valid `BigNum` value.\n///\n/// Basically the same as `validate_gt` but we compute the result on the fly\n/// It is just a bit more optimized as we expect each `BigNum` value to be \\leq `MOD`\n///\n/// ## Note\n/// In contrast to `validate_gt`, we allow the value to be `MOD`\n/// Since it is consistent with the rest of the library\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    let modulus: [u128; N] = params.modulus;\n\n    // Safety: compute borrow flags out-of-circuit\n    let borrow_flags: [bool; (N - 1)] =\n        unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n\n    let mut p_minus_self: [Field; N] = [0; N];\n    p_minus_self[0] = (modulus[0] as Field) - (val[0] as Field)\n        + (borrow_flags[0] as Field) * (TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] = (modulus[i] as Field) - (val[i] as Field)\n            + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n            - (borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] =\n        (modulus[N - 1] as Field) - (val[N - 1] as Field) - (borrow_flags[N - 2] as Field);\n    validate_in_range::<Field, N, MOD_BITS>(p_minus_self);\n}\n\n/// Compare two `BigNum` values\n///\n/// Returns `lhs > rhs`\n///\n/// ## Note\n/// This is a strict value comparison over the integers,\n/// the values do not have to be reduced modulo `MOD`.\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    // Safety: we constrain:\n    //        - `result` and `borrow_flags` with `check_gte_with_flags`\n    //        - `borrow_flags` are also booleans\n    //        - `underflow` with the following swap and (bool)\n    let (underflow, result, borrow_flags): (bool, [u128; N], [bool; N - 1]) =\n        unsafe { __validate_gte_with_flags(lhs, rhs) };\n\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs): ([u128; N], [u128; N]) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    // Constrain the `result` to be a valid `BigNum` value\n    validate_in_range::<u128, N, MOD_BITS>(result);\n\n    // Constrain subtraction: result = lhs - rhs with borrow_flags\n    check_gte_with_flags(lhs, rhs, result, borrow_flags);\n\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// ------------------------------ ARITHMETIC FUNCTIONS ------------------------------\n\n/// Negate a `BigNum` value\n///\n/// Computes `result = MOD - val` using limb-wise subtraction with borrow flags,\n/// then constrains:\n///   - all `result` limbs to be a valid `BigNum` value, and\n///   - the subtraction relation with the borrow flags\n///\n/// ## Assumptions\n/// - `val` is a valid `BigNum` in the range `0 <= val <= MOD`.\n///\n/// ## Soundness\n/// This function constrains the following relations:\n///     result[0]     = MOD[0]     - val[0]     + bf[0] * 2^{120}             < 2^{120}\n///     result[i]     = MOD[i]     - val[i]     + bf[i] * 2^{120} - bf[i - 1] < 2^{120},  i = 1..N-2\n///     result[N - 1] = MOD[N - 1] - val[N - 1]                   - bf[N - 2] < 2^{TOP_LIMB_BITS}\n///\n/// If all `MOD` and `val` limbs are valid `BigNum` limbs, these constraints\n/// ensure that:\n///   - the borrow flags `bf[i]` form a valid limb-wise subtraction chain, and\n///   - no underflow can occur in the subtraction `MOD - val`.\n///\n/// ## Completeness\n/// This function is complete for inputs in the range `0 <= val <= MOD`.\n/// If a value `val > MOD` is passed in (while still `< 2^{MOD_BITS}`), the\n/// constraints above will fail, since there is no valid borrow chain making\n/// `MOD - val` a well-formed `BigNum`.\n///\n/// In practice, honest provers should not hit this case: all functions in this\n/// module are expected to return values `< MOD`.\n///\n/// ## Note\n/// This function returns `MOD` when `val` is zero.\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: no need to constrain in an unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // Safety: compute borrow flags out-of-circuit\n        let (result, borrow_flags): ([u128; N], [bool; N - 1]) =\n            unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        let result_limb: Field = (params.modulus[0] as Field)\n            - (val[0] as Field)\n            - (result[0] as Field)\n            + (borrow_flags[0] as Field) * (TWO_POW_120 as Field);\n        assert(result_limb == 0);\n\n        for i in 1..N - 1 {\n            let result_limb: Field = (params.modulus[i] as Field)\n                - (val[i] as Field)\n                - (result[i] as Field)\n                + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (borrow_flags[i - 1] as Field);\n            assert(result_limb == 0);\n        }\n\n        let result_limb: Field = (params.modulus[N - 1] as Field)\n            - (val[N - 1] as Field)\n            - (result[N - 1] as Field)\n            - (borrow_flags[N - 2] as Field);\n        assert(result_limb == 0);\n        result\n    }\n}\n\n/// Add two `BigNum` values\n///\n/// Computes `result = lhs + rhs` using limb-wise addition with carry flags,\n/// and an optional subtraction of `MOD` using borrow flags. The function then\n/// constrains:\n///   - all `result` limbs to be a valid `BigNum` value, and\n///   - the addition/subtraction relation with the carry/borrow flags and the\n///     `overflow_modulus` bit.\n///\n/// ## Assumptions\n/// - All limbs of `lhs`, `rhs` and `MOD` are valid `BigNum` limbs\n///   (120-bit for non-top limbs, `TOP_LIMB_BITS` for the top limb).\n/// - Semantically, we intend to use this only with `0 <= lhs, rhs < MOD`,\n///   even though the limb/range constraints allow values up to `< 2^{MOD_BITS}`.\n///\n/// ## Soundness (intended relation)\n/// This function constrains the following equations:\n///\n///     result[0]     = lhs[0]     + rhs[0]\n///                     - sub[0]\n///                     + bf[0] * 2^{120}\n///                     - cf[0]                                        < 2^{120}\n///\n///     result[i]     = lhs[i]     + rhs[i]\n///                     - sub[i]\n///                     + bf[i] * 2^{120}  - bf[i - 1]\n///                     - cf[i] * 2^{120}  + cf[i - 1]                 < 2^{120},\n///                     for i = 1..N-2\n///\n///     result[N - 1] = lhs[N - 1] + rhs[N - 1]\n///                     - sub[N - 1]\n///                     - bf[N - 2]\n///                     + cf[N - 2]                                   < 2^{TOP_LIMB_BITS}\n///\n/// where:\n///   - `bf[i]` are the borrow flags of the optional subtraction,\n///   - `cf[i]` are the carry flags of the addition, and\n///   - `sub` is either the zero vector or `MOD`, depending on the\n///     `overflow_modulus` flag:\n///         * `overflow_modulus = 0`  =>  `sub = 0`\n///         * `overflow_modulus = 1`  =>  `sub = MOD`\n///\n/// If `lhs`, `rhs` and `MOD` are valid `BigNum` limbs and the witness for\n/// `(bf, cf, overflow_modulus)` is the honest one produced by `__add_with_flags`,\n/// these constraints enforce:\n///   - a valid limb-wise carry chain for `lhs + rhs`, and\n///   - a valid limb-wise subtraction chain for either `lhs + rhs` or\n///     `lhs + rhs - MOD`, with no underflow in any limb.\n///\n/// Under these assumptions the constrained result equals:\n///\n///     result = lhs + rhs (mod MOD)\n///\n/// in the intended arithmetic.\n///\n/// ## Limitations / extra satisfying witnesses\n///\n/// The constraint system itself does **not** uniquely determine the carry/borrow\n/// flags nor the `overflow_modulus` bit:\n///\n/// - For each limb `i`, `bf[i]` and `cf[i]` only appear in the combination\n///   `bf[i] * 2^{120} - cf[i] * 2^{120}`. This means that both\n///\n///       (bf[i], cf[i]) = (0, 0)  and  (bf[i], cf[i]) = (1, 1)\n///\n///   give the same contribution to the equation. As a result, there are multiple\n///   valid flag assignments for the *same* `lhs`, `rhs`, `sub` and `result`.\n///\n/// - More importantly, if `lhs + rhs` is greater than `MOD` but still strictly\n///   less than `2^{MOD_BITS}`, there exist *spurious* witnesses where:\n///     * `overflow_modulus` is set inconsistently with the true arithmetic\n///       overflow, and\n///     * the `(bf, cf)` flags are adjusted accordingly,\n///\n///   such that all equations above still hold and all `result` limbs remain\n///   within range. In particular, when\n///\n///       lhs + rhs + MOD < 2^{MOD_BITS},\n///\n///   a malicious prover can \"hide\" an extra `MOD` inside the choice of\n///   `overflow_modulus`, `bf` and `cf`, so that the circuit is satisfied by a\n///   witness\n///\n/// Consequently, this function is only *conditionally* sound: we rely on the\n/// out-of-circuit implementation of `__add_with_flags` to provide the honest\n/// `(borrow_flags, carry_flags, overflow_modulus)` witness. Under that\n/// assumption, the constrained `result` matches `lhs + rhs (mod MOD)`.\n///\n/// ## Completeness\n///\n/// For inputs in the range `0 <= lhs, rhs < MOD` and honest flags from\n/// `__add_with_flags`, the constraints are complete: every valid `BigNum` sum\n/// `lhs + rhs (mod MOD)` admits a satisfying assignment.\n///\n/// Inputs with `lhs` or `rhs` in `[MOD, 2^{MOD_BITS})` are still representable\n/// as limb arrays and may admit satisfying witnesses, but then the operation\n/// no longer corresponds to a unique, well-defined addition in the field\n/// `Z / MOD Z`. Such uses are outside the intended semantics of this function.\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: no need to constrain in unconstrained runtime\n        unsafe {\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // Safety: compute borrow/carry flags out-of-circuit\n        let (result, carry_flags, borrow_flags, overflow_modulus): ([u128; N], [bool; N - 1], [bool; N - 1], bool) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        let mut subtrahend: [u128; N] = if overflow_modulus {\n            params.modulus\n        } else {\n            [0; N]\n        };\n\n        let result_limb: Field = (lhs[0] as Field) + (rhs[0] as Field)\n            - (result[0] as Field)\n            - (subtrahend[0] as Field)\n            + (borrow_flags[0] as Field) * (TWO_POW_120 as Field)\n            - (carry_flags[0] as Field) * (TWO_POW_120 as Field);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb: Field = (lhs[i] as Field) + (rhs[i] as Field)\n                - (result[i] as Field)\n                - (subtrahend[i] as Field)\n                - (borrow_flags[i - 1] as Field)\n                + (carry_flags[i - 1] as Field)\n                + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (carry_flags[i] as Field) * (TWO_POW_120 as Field);\n            assert(result_limb == 0);\n        }\n        let result_limb: Field = (lhs[N - 1] as Field) + (rhs[N - 1] as Field)\n            - (result[N - 1] as Field)\n            - (subtrahend[N - 1] as Field)\n            - (borrow_flags[N - 2] as Field)\n            + (carry_flags[N - 2] as Field);\n        assert(result_limb == 0);\n        result\n    }\n}\n\n/// Subtract two `BigNum` values\n///\n/// Computes `result = lhs - rhs` using limb-wise subtraction with borrow flags,\n/// and an optional addition of `MOD` using carry flags. The function then\n/// constrains:\n///   - all `result` limbs to be a valid `BigNum` value, and\n///   - the subtraction/addition relation with the carry/borrow flags and the\n///     `underflow_modulus` bit.\n///\n/// ## Assumptions\n/// - All limbs of `lhs`, `rhs` and `MOD` are valid `BigNum` limbs\n///   (120-bit for non-top limbs, `TOP_LIMB_BITS` for the top limb).\n/// - Semantically, we intend to use this only with `0 <= lhs, rhs < MOD`,\n///   even though the limb/range constraints allow values up to `< 2^{MOD_BITS}`.\n///\n/// ## Soundness (intended relation)\n/// This function constrains the following equations:\n///\n///     result[0]     = lhs[0]     - rhs[0]\n///                     + add[0]\n///                     + bf[0] * 2^{120}\n///                     - cf[0]                                        < 2^{120}\n///\n///     result[i]     = lhs[i]     - rhs[i]\n///                     + add[i]\n///                     + bf[i] * 2^{120}  - bf[i - 1]\n///                     - cf[i] * 2^{120}  + cf[i - 1]                 < 2^{120},\n///                     for i = 1..N-2\n///\n///     result[N - 1] = lhs[N - 1] - rhs[N - 1]\n///                     + add[N - 1]\n///                     - bf[N - 2]\n///                     + cf[N - 2]                                   < 2^{TOP_LIMB_BITS}\n///\n/// where:\n///   - `bf[i]` are the borrow flags of the subtraction,\n///   - `cf[i]` are the carry flags of the optional addition, and\n///   - `add` is either the zero vector or `MOD`, depending on the\n///     `underflow_modulus` flag:\n///         * `underflow_modulus = 0`  =>  `add = 0`\n///         * `underflow_modulus = 1`  =>  `add = MOD`\n///\n/// If `lhs`, `rhs` and `MOD` are valid `BigNum` limbs and the witness for\n/// `(bf, cf, underflow_modulus)` is the honest one produced by `__sub_with_flags`,\n/// these constraints enforce:\n///   - a valid limb-wise borrow chain for `lhs - rhs`, and\n///   - a valid limb-wise addition chain for either `lhs - rhs` or\n///     `lhs - rhs + MOD`, with no underflow in any limb.\n///\n/// Under these assumptions the constrained result equals:\n///\n///     result = lhs - rhs (mod MOD)\n///\n/// in the intended arithmetic.\n///\n/// ## Limitations / extra satisfying witnesses\n///\n/// The constraint system itself does **not** uniquely determine the carry/borrow\n/// flags nor the `underflow_modulus` bit:\n///\n/// - For each limb `i`, `bf[i]` and `cf[i]` only appear in the combination\n///   `bf[i] * 2^{120} - cf[i] * 2^{120}`. This means that both\n///\n///       (bf[i], cf[i]) = (0, 0)  and  (bf[i], cf[i]) = (1, 1)\n///\n///   give the same contribution to the equation. As a result, there are multiple\n///   valid flag assignments for the *same* `lhs`, `rhs`, `add` and `result`.\n///\n/// - More importantly, when `lhs < rhs`, the true field result is\n///\n///       lhs - rhs + MOD,\n///\n///   and as long as\n///\n///       lhs - rhs + MOD < 2^{MOD_BITS},\n///\n///   a malicious prover can:\n///     * set `underflow_modulus` inconsistently with the true underflow, and\n///     * adjust the `(bf, cf)` flags accordingly,\n///\n///   such that all equations above still hold and all `result` limbs remain\n///   within range. In other words, the circuit can be satisfied by a witness\n///   that does **not** correspond to the unique intended subtraction modulo\n///   `MOD` for some inputs with `lhs < rhs`.\n///\n/// Consequently, this function is only *conditionally* sound: we rely on the\n/// out-of-circuit implementation of `__sub_with_flags` to provide the honest\n/// `(borrow_flags, carry_flags, underflow_modulus)` witness. Under that\n/// assumption, the constrained `result` matches `lhs - rhs (mod MOD)`.\n///\n/// ## Completeness\n///\n/// For inputs in the range `0 <= lhs, rhs < MOD` and honest flags from\n/// `__sub_with_flags`, the constraints are complete: every valid `BigNum`\n/// difference `lhs - rhs (mod MOD)` admits a satisfying assignment.\n///\n/// Inputs with `lhs` or `rhs` in `[MOD, 2^{MOD_BITS})` are still representable\n/// as limb arrays and may admit satisfying witnesses, but then the operation\n/// no longer corresponds to a unique, well-defined subtraction in the field\n/// `Z / MOD Z`. Such uses are outside the intended semantics of this function.\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: no need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // Safety: we constrain carry, borrow, underflow and result immediately\n        let (result, carry_flags, borrow_flags, underflow_modulus): ([u128; N], [bool; N - 1], [bool; N - 1], bool) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        let mut addend: [u128; N] = if underflow_modulus {\n            params.modulus\n        } else {\n            [0; N]\n        };\n\n        let result_limb: Field = (lhs[0] as Field) - (rhs[0] as Field) - (result[0] as Field)\n            + (addend[0] as Field)\n            + (borrow_flags[0] as Field) * (TWO_POW_120 as Field)\n            - (carry_flags[0] as Field) * (TWO_POW_120 as Field);\n        assert(result_limb == 0);\n\n        for i in 1..N - 1 {\n            let result_limb: Field = (lhs[i] as Field) - (rhs[i] as Field) - (result[i] as Field)\n                + (addend[i] as Field)\n                + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (carry_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (borrow_flags[i - 1] as Field)\n                + (carry_flags[i - 1] as Field);\n            assert(result_limb == 0);\n        }\n        let result_limb: Field = (lhs[N - 1] as Field)\n            - (rhs[N - 1] as Field)\n            - (result[N - 1] as Field)\n            + (addend[N - 1] as Field)\n            - (borrow_flags[N - 2] as Field)\n            + (carry_flags[N - 2] as Field);\n        assert(result_limb == 0);\n        result\n    }\n}\n\n/// Compute the `BigNum` multiplication\n///\n/// Computes `result = lhs * rhs (mod MOD)` by:\n///   1. Computing `result` out of circuit via `__mul`.\n///   2. Constraining the quadratic relation `lhs * rhs - result = 0` with\n///      `evaluate_quadratic_expression`.\n///\n/// ## Soundness\n/// Soundness reduces to `evaluate_quadratic_expression` for the relation\n/// `lhs * rhs - result = 0`\n///\n/// ## Note\n/// When possible, prefer expressing your computation directly as a quadratic\n///   relation and calling `evaluate_quadratic_expression` instead of using `mul`\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    // Safety: we constrain the multiplication result immediately after\n    let result: [u128; N] = unsafe { __mul::<N, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        // lhs * rhs - result = 0\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n/// Compute the `BigNum` squaring\n///\n/// Computes `result = val * val (mod MOD)` by:\n///   1. Computing `result` out of circuit via `__sqr`.\n///   2. Constraining the quadratic relation `val * val - result = 0` with\n///      `evaluate_quadratic_expression`.\n///\n/// ## Soundness\n/// Soundness reduces to `evaluate_quadratic_expression` for the relation\n/// `val * val - result = 0`\n///\n/// ## Note\n/// When possible, prefer expressing your computation directly as a quadratic\n///   relation and calling `evaluate_quadratic_expression` instead of using `sqr`\npub(crate) fn sqr<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    // Safety: we constrain the multiplication result immediately after\n    let result: [u128; N] = unsafe { __sqr::<_, MOD_BITS>(params, val) };\n    if !std::runtime::is_unconstrained() {\n        // val * val - result = 0\n        evaluate_quadratic_expression(\n            params,\n            [[val]],\n            [[false]],\n            [[val]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n/// Compute the `BigNum` division\n///\n/// Computes `result = lhs * rhs^{-1} (mod MOD)` by:\n///   1. Computing `result` out of circuit via `__div`.\n///   2. Constraining the quadratic relation `result * rhs - lhs = 0` with\n///      `evaluate_quadratic_expression`.\n///   3. Enforcing `rhs != 0 (mod MOD)`.\n///\n/// ## Soundness\n/// Soundness reduces to `evaluate_quadratic_expression` for the relation\n/// `result * rhs - lhs = 0`, together with the non-zero check on `rhs` and the\n/// assumption that `MOD` has multiplicative inverses for all non-zero elements\n/// (`params.has_multiplicative_inverse = true`).\n///\n/// ## Note\n/// - This is **expensive** in witness time due to modular inversion.\n/// - When possible, prefer expressing your computation directly as a quadratic\n///   relation and calling `evaluate_quadratic_expression` instead of using `div`.\n/// - In the unconstrained runtime, the behavior of `__div` on zero divisors is\n///   not constrained by this function.\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    // Safety: We constrain the result of division immediately after\n    let result: [u128; N] = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        // result * rhs - lhs = 0\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n        assert_is_not_zero(params, rhs);\n    }\n    result\n}\n\n/// Compute the `BigNum` integer division with remainder\n///\n/// Computes `quotient = floor(numerator / divisor)` and\n/// `remainder = numerator % divisor` by:\n///   1. Computing `(quotient, remainder)` out of circuit via `__udiv_mod`.\n///   2. Constraining the quadratic relation\n///        quotient * divisor + remainder - numerator = 0\n///      with `validate_udiv_mod_expression`.\n///   3. Enforcing `remainder < divisor`.\n///\n/// ## Soundness\n/// Soundness reduces to `validate_udiv_mod_expression` for the relation\n///     quotient * divisor + remainder - numerator = 0,\n/// together with `remainder < divisor` check enforced via `validate_gt`.\n///\n/// Under these checks, any satisfying assignment corresponds to a valid\n/// integer division `numerator = quotient * divisor + remainder` with\n/// `0 <= remainder < divisor`\n///\n/// ## Note\n/// Enforcing `divisor != 0` is not necessary. `remainder < divisor`\n/// Already enforces this.\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    // Safety: We constrain the result of __udiv_mod immediately after\n    let (quotient, remainder): ([u128; N], [u128; N]) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // quotient * divisor + remainder - numerator = 0\n        validate_udiv_mod_expression::<N, MOD_BITS>(numerator, divisor, quotient, remainder);\n        // remainder < divisor\n        validate_gt::<N, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/// Compute the `BigNum` integer division\n///\n/// Returns `floor(numerator / divisor)`.\n/// All constraints and soundness details are handled inside `udiv_mod`.\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<N, MOD_BITS>(numerator, divisor).0\n}\n\n/// Compute the `BigNum` remainder\n///\n/// Returns `numerator % divisor`.\n/// All constraints and soundness details are handled inside `udiv_mod`.\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<N, MOD_BITS>(numerator, divisor).1\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/constrained_ops.nr"
    },
    "86": {
      "source": "use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\n\nuse crate::fns::constrained_ops::{validate_in_range, validate_quotient_in_range};\nuse crate::fns::unconstrained_helpers::__barrett_reduction;\nuse crate::fns::unconstrained_ops::__is_zero;\n\nuse crate::params::BigNumParams;\n\n// ------------------------------ UNCONSTRAINED EXPRESSIONS ------------------------------\n\n/// Compute the result of a linear combination of (possibly negative) `BigNum` values (unconstrained)\n///\n/// ## Note\n/// 1. `modulus2` is structured such that all limbs will be greater than `0`, even when subtracting.\n/// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n/// We know that, for a valid bignum element, the limbs in `x` will be < 2^{120}\n/// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n/// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\n///\n/// 2. Returns the `Field` values that are not normalized to be 120-bit\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    vals: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    let mut sum: [Field; N] = [0; N];\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field) - (vals[i][j] as Field);\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + (vals[i][j] as Field);\n            }\n        }\n    }\n    sum\n}\n\n/// Compute the limb products of a quadratic expression (unconstrained)\n///\n/// See `__compute_quadratic_expression_with_borrow_flags` for full description\n///\n/// ## Note\n/// Returns the `Field` values that are not normalized to be 120-bit\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += lhs[k][i] * rhs[k][j];\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/// Compute the borrow flags for a limb-wise subtraction `lhs - rhs` (unconstrained).\n///\n/// This helper operates on `N`-limb values where each limb is interpreted as a\n/// 120-bit chunk (base `B = 2^{120}`), but where intermediate limbs may exceed\n/// `2^{120}` due to sums of products.\n///\n/// Conceptually, we want to model the integer subtraction\n///\n///     lhs - rhs\n///\n/// as a base-`B` subtraction with borrows, without allowing any intermediate\n/// values to go negative in the circuit field. We achieve this by:\n///\n///   1. Working with widened 246-bit ranges per limb.\n///   2. Encoding a borrow from limb `i+1` into limb `i` by:\n///        - adding `2^{246}` into limb `i`,\n///        - subtracting `2^{126}` (= 2^{246 - 120}) from limb `i+1` after\n///          scaling by `2^{-120}`.\n///\n/// The returned `borrow_flags[i]` indicate whether the canonical integer\n/// subtraction would borrow from limb `i+1` into limb `i`. These flags are\n/// later re-applied in-circuit via `apply_borrow_flags`, and the resulting\n/// limbs are checked by `validate_expression_is_zero`.\nunconstrained fn __compute_borrow_flags<let N: u32>(\n    mut lhs_limbs: [Field; N],\n    rhs_limbs: [Field; N],\n) -> [bool; N - 1] {\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{126} = 2^{246 - 120}\n    let downshift_120: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    borrow_flags[0] = lhs_limbs[0].lt(rhs_limbs[0]);\n\n    // we have N - 1 borrow flags. The number of limbs is N\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits: Field =\n        (lhs_limbs[0] - rhs_limbs[0] + ((borrow_flags[0] as Field) * borrow_shift)) * downshift_120;\n\n    for i in 1..(N - 1) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        lhs_limbs[i] += hi_bits;\n\n        let subtrahend: Field = rhs_limbs[i] + (borrow_flags[i - 1] as Field) * borrow_carry;\n\n        // determine whether negative limb values are greater than positive limb values\n        borrow_flags[i] = lhs_limbs[i].lt(subtrahend);\n        let minuend: Field = lhs_limbs[i] + (borrow_flags[i] as Field) * borrow_shift;\n\n        hi_bits = (minuend - subtrahend) * downshift_120;\n    }\n    borrow_flags\n}\n\n/// Given a degree-2 `BigNum` expression that is equal to `0 mod MOD`, compute\n/// the quotient and the borrow flags (unconstrained).\n///\n/// The expression has the form:\n///\n///     sum_{k=0}^{NUM_PRODUCTS-1} (L_k * R_k) + sum_{i=0}^{ADD_N-1} A_i = quotient * MOD\n///\n/// where each `L_k`, `R_k`, `A_i` is an `N`-limb `BigNum` assembled from the\n/// `(terms, flags)` arrays.\n///\n/// This helper:\n///   1. Evaluates the quadratic expression into `mulout_p` as a `2N`-limb\n///      non-normalized value.\n///   2. Normalizes `mulout_p` into 120-bit limbs and applies Barrett\n///      reduction to obtain `(quotient, remainder)`.\n///   3. Asserts that the integer remainder is zero (debugging aid; range\n///      checks enforce this later).\n///   4. Reconstructs `mulout_n = quotient * MOD`.\n///   5. Computes `borrow_flags` for the limb-wise subtraction\n///        `mulout_p - mulout_n`,\n///      using the 2^{246}/2^{126} encoding described in\n///      `evaluate_quadratic_expression`.\n///\n/// The returned `quotient` and `borrow_flags` are later constrained\n/// in-circuit by `compute_quadratic_expression_with_modulus` and\n/// `evaluate_quadratic_expression`.\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [bool; 2 * N - 2]) {\n    let mulout_p: [Field; 2 * N] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    // `__normalize_limbs` will validate that we do not overflow 2N, normally we should not overflow 2N-1\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p);\n    let (quotient, remainder): ([u128; N], [u128; N]) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n\n    // This is verified later by the range checks but left for debugging purposes\n    assert(__is_zero(remainder));\n\n    // We do not normalize `mulout_n` so we won't fill the `2 * N - 1`\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += (quotient[i] as Field) * (params.modulus[j] as Field);\n        }\n    }\n\n    let borrow_flags: [bool; 2 * N - 1] = __compute_borrow_flags(mulout_p, mulout_n);\n\n    // We have to copy it because we know that borrow_flags[2 * N - 1] is always 0\n    // But we also have to provide 2 * N limbs to `__barrett_reduction`.\n    // And keep `__compute_borrow_flags` generic enough\n    let mut borrow_flags_real: [bool; 2 * N - 2] = [false; 2 * N - 2];\n    for i in 0..2 * N - 2 {\n        borrow_flags_real[i] = borrow_flags[i];\n    }\n\n    (quotient, borrow_flags_real)\n}\n\n/// Computes the quotient/remainder of a quadratic expression (unconstrained)\n///\n/// See `__compute_quadratic_expression_with_borrow_flags` for full description\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    let mulout: [Field; 2 * N] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    // __normalize_limbs will validate that we do not overflow 2N, normally we should not overflow 2N-1\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout);\n\n    let (quotient, remainder): ([u128; N], [u128; N]) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n\n    (quotient, remainder)\n}\n\n// ------------------------------ CONSTRAINED EXPRESSIONS ------------------------------\n\n/// Constrained version of `__add_linear_expression`\n///\n/// Computes all the linear parts of an expression in-circuit\n///\n/// ## Note\n/// 1. Negative terms are implemented by adding `double_modulus`\n/// `double_modulus` is chosen so that all limbs except the top one\n/// are > 2^{120}, which prevents underflows in intermediate computations.\n///\n/// 2. For the most significant limb we slightly reduce the padding (to keep the\n/// overall value equal to `2 * MOD`), so in principle there is a narrow edge\n/// case where that limb could underflow if enough negative contributions are\n/// accumulated and the top limb of `MOD` is very small. In practice, the\n/// global `BigNum` range and operand-count assumptions in\n/// `evaluate_quadratic_expression` rule out such patterns.\nfn compute_linear_expressions<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([[Field; N]; NUM_PRODUCTS], [[Field; N]; NUM_PRODUCTS], [Field; N]) {\n    // lhs linear terms\n    let mut lhs_linear: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    // rhs linear terms\n    let mut rhs_linear: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    // linear terms\n    let mut lin_expr: [Field; N] = [0; N];\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // Note: if lhs_flags[k][j] - `is_negative` is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    lhs_linear[k][i] -= lhs_terms[k][j][i] as Field;\n                    lhs_linear[k][i] += params.double_modulus[i] as Field;\n                } else {\n                    lhs_linear[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                // Note: if rhs_flags[k][j] - `is_negative` is not known at comptime this is very expensive\n                if (rhs_flags[k][j]) {\n                    rhs_linear[k][i] -= rhs_terms[k][j][i] as Field;\n                    rhs_linear[k][i] += params.double_modulus[i] as Field;\n                } else {\n                    rhs_linear[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n\n    for i in 0..N {\n        for j in 0..ADD_N {\n            // Note: if linear_flags[j] - `is_negative` is not known at comptime this is very expensive\n            if (linear_flags[j]) {\n                lin_expr[i] -= linear_terms[j][i] as Field;\n                lin_expr[i] += params.double_modulus[i] as Field;\n            } else {\n                lin_expr[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    (lhs_linear, rhs_linear, lin_expr)\n}\n\n/// Constrained version of `__compute_quadratic_expression_product`\n///\n/// Computes the following expression in-circuit:\n///     \\sum (L_i * R_i) + \\sum (A_i) - QUOTIENT * MOD\n///\n/// Because of the subtraction of `QUOTIENT * MODULUS`, the resulting limbs may\n/// underflow and represent *negative* values. To account for this, we allow the\n/// prover to choose a sequence of borrow flags and interpret the limbs with\n/// additional terms:\n///\n///   - for each limb `i` we may add `2^{246}` (via a flag at position `i`);\n///   - for each limb `i` we may subtract `2^{126 = 246 - 120}` (via the flag\n///     at position `i - 1`).\n///\n/// This corresponds to borrowing `2^{126}` from limb `i + 1` and adding\n/// `2^{246}` into limb `i`. After this adjustment, an honest prover can ensure\n/// that every limb lies in `[0, 2^{246})` and that the adjusted limbs encode\n/// the correct integer value.\n///\n/// Additionally, we constrain the quotient limbs via `validate_quotient_in_range`:\n///   - limbs `0..N-2` of `quotient` are < 2^{120};\n///   - the top limb is < 2^{TOP_LIMB_BITS + 6}.\n/// Which validates `quotient < 2^{MOD_BITS + 6}`\n///\n/// ## TODO\n/// Apply static or runtime checks in this method to validate that the effective\n/// `twiddle_factor` does not exceed 6 under the chosen parameters.\nfn compute_quadratic_expression_with_modulus<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N - 1] {\n    // Safety: use an unconstrained function to compute the value of the quotient and borrow_flags out-of-circuit\n    let (quotient, borrow_flags): ([u128; N], [bool; 2 * N - 2]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<N, MOD_BITS, LHS_N, RHS_N, NUM_PRODUCTS, ADD_N>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // Constrain the `quotient < 2^{MOD_BITS + 6}`\n    // By constraining limbs(0..N-2) to be < 2^120 and the the top limb < 2^{TOP_LIMB_BITS + 6}\n    validate_quotient_in_range::<N, MOD_BITS>(quotient);\n\n    // Compute the linear sums that represent L_i, R_i, A\n    let (lhs_linear, rhs_linear, lin_expr): ([[Field; N]; NUM_PRODUCTS], [[Field; N]; NUM_PRODUCTS], [Field; N]) = compute_linear_expressions::<N, MOD_BITS, LHS_N, RHS_N, NUM_PRODUCTS, ADD_N>(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    // We want to evaluate that L * R + A - Quotient * MOD = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow\n    let mut expression_limbs: [Field; 2 * N - 1] = [0; 2 * N - 1];\n\n    // Compute the product t0 * t1 + t4 - Quotient * MOD\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term: Field = lhs_linear[k][i] * rhs_linear[k][j]\n                        - (quotient[i] as Field) * (params.modulus[j] as Field);\n                    // width-4 optimization\n                    std::as_witness(new_term);\n                    expression_limbs[i + j] += new_term;\n                } else {\n                    expression_limbs[i + j] += lhs_linear[k][i] * rhs_linear[k][j];\n                }\n            }\n            // This is the fallback for pure linear expression\n            if (NUM_PRODUCTS == 0) {\n                expression_limbs[i + j] -= (quotient[i] as Field) * (params.modulus[j] as Field);\n            }\n        }\n        expression_limbs[i] += lin_expr[i];\n    }\n\n    apply_borrow_flags(expression_limbs, borrow_flags)\n}\n\n/// Apply a precomputed borrow chain to a limb array.\n///\n/// Given:\n///\n///   - `expression_limbs`: an `N`-limb array of `Field` values representing a\n///     (possibly non-normalized) degree-2-style expression, and\n///   - `borrow_flags[i]` indicating that we \"borrow\" from limb `i+1` into limb `i`,\n///\n/// this function applies the same 2^{246}/2^{126} encoding used in\n/// `__compute_borrow_flags` to produce an adjusted limb array\n///\n/// This matches the behavior of `__compute_borrow_flags`, which conceptually:\n///\n///   1. Adds `2^{246}` into a limb when a borrow is taken at that limb;\n///   2. After scaling by `2^{-120}`, contributes `2^{126}` into the next limb.\n///\n/// The resulting `expression_limbs` can then be passed to\n/// `validate_expression_is_zero`, which:\n///\n///   - right-shifts by 120 bits per limb,\n///   - enforces a 126-bit bound,\n///   - and propagates carries forward, finally checking that the most\n///     significant limb is zero.\n///\n/// ## Assumptions\n///\n/// - `borrow_flags` was computed consistently with the original construction\n///   of `expression_limbs` (e.g. via `__compute_borrow_flags` on the\n///   corresponding unconstrained expression).\n/// - The caller has ensured that each adjusted limb remains < 2^{246} for\n///   honest witnesses (e.g. via `NUM_PRODUCTS < 64`).\n///\n/// ## Note\n///\n/// This function does not itself enforce any bit-size bounds; it only applies\n/// the borrow encoding. The actual range checks happen later in\n/// `validate_expression_is_zero`.\n///\n/// ## TODO\n/// define trade-offs regarding the value of borrow_shift\n/// (the larger the value, the greater the range check that is required on product_limbs)\n/// (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n/// (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\nfn apply_borrow_flags<let N: u32>(\n    mut expression_limbs: [Field; N],\n    borrow_flags: [bool; N - 1],\n) -> [Field; N] {\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n\n    // Get the product_limbs into the form where each entry is a 246-bit value\n    expression_limbs[0] += (borrow_flags[0] as Field) * borrow_shift;\n    for i in 1..(N - 1) {\n        expression_limbs[i] += (borrow_flags[i] as Field) * borrow_shift\n            - (borrow_flags[i - 1] as Field) * borrow_carry;\n    }\n    expression_limbs[N - 1] -= (borrow_flags[N - 2] as Field) * borrow_carry;\n    expression_limbs\n}\n\n/// Validate that `limbs` represent the integer value `0`\n///\n/// ## Assumptions\n///     - `limbs` is an array of `Field` values that was derived arithmetically as\n///        a degree-2 expression\n///     - each limb satisfies `limbs[i] < 2^{246}`, as ensured by\n///       `compute_quadratic_expression_with_modulus` under its parameter bounds.\n///\n/// ## Details\n/// Each element `i` in `limbs` overlaps in bit-range with element `i+1`, EXCEPT for the low 120 bits\n/// i.e. we need to do the following for each limb `i`:\n///      1. validate the limb's low-120 bits equals zero\n///      2. compute the limb \"carry\" by right-shifting by 2^{120}\n///      3. propagate the \"carry\" into limb `i+1`\n/// We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n///\n/// If the low 120 bits are nonzero, there is no value in `[0, 2^{126})` that\n/// could have produced this limb after multiplying by `2^{120}`. Since\n/// multiplication by `2^{120}` is a bijection on the Field, any limb with\n/// non-zero low 120 bits must map outside the `[0, 2^{126})` range after\n/// scaling by `2^{-120}`.\n///\n/// The most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n///\n/// ## Note\n/// The constant 126 is not arbitrary. We use 120-bit limbs and allow up to 64\n/// products per limb, which contributes at most `log2(64) = 6` bits of headroom.\n/// After scaling by `2^{-120}`, honest witnesses fit in 126 bits. We could in\n/// principle go higher (up to roughly `CircuitModulusBits - 121`), but 126 is\n/// the minimal bound consistent with `NUM_PRODUCTS < 64` and is significantly\n/// cheaper than larger bounds for the barretenberg backend.\nfn validate_expression_is_zero<let N: u32>(mut limbs: [Field; N]) {\n    let hi_shift: Field = TWO_POW_120 as Field;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N - 1 {\n        limbs[i] *= hi_downshift;\n        std::as_witness(limbs[i]);\n        limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        limbs[i + 1] += limbs[i];\n    }\n    assert(limbs[N - 1] == 0);\n}\n\n/// Constrain a degree-2 `BigNum` expression to be equal to 0 (mod `MOD`)\n///\n//\n/// This method is intended for relations where the remainder term of the\n/// degree-2 expression is exactly zero as an integer relation. In other words,\n/// we use it only when we expect:\n///\n///     \\sum (L_i * R_i) + \\sum (A_i) - QUOTIENT * MOD = 0\n///\n/// as integers, not just modulo the circuit field or `BigNum` field.\n///\n/// ## Details\n///\n/// The constrained expression, viewed over the integers, is:\n///\n///       \\sum_{i=0}^{NUM_PRODUCTS-1} (L_i * R_i)\n///     + \\sum_{i=0}^{ADD_N-1} (A_i)\n///     - QUOTIENT * MOD\n///     = 0\n///\n/// Each `L_i`, `R_i`, `A_i` is an `N`-limb `BigNum` assembled from the\n/// `(terms, flags)` arrays. For example, for `i = 0`:\n///\n///     L_0 = \\sum_{j=0}^{LHS_N-1} lhs[0][j]    as a `BigNum`\n///     R_0 = \\sum_{j=0}^{RHS_N-1} rhs[0][j]    as a `BigNum`\n///\n/// The intent is to capture a generic degree-2 expression within Noir's\n/// limitations (no efficient dynamically sized vectors).\n///\n/// The expensive parts of this algorithm are:\n///   1. evaluating the limb products required to compute the `L_i * R_i` values;\n///   2. applying range constraints to validate that the result encodes 0.\n///\n/// ## Note\n/// When the expression is evaluated over `N`-limb `BigNum` values, the product\n/// has up to `2N - 1` significant limbs. Each limb is a sum of at most\n/// `NUM_PRODUCTS` products of `linear` 120-bit limbs and `quadratic` 240-bit-ish limbs\n///\n/// Note that:\n///   * limb-wise multiplication is not uniform across indices. For example:\n///\n///       [x0, x1, x2] * [y0, y1, y2] =\n///       [\n///         x0*y0,                               // 1 term\n///         x0*y1 + x1*y0,                       // 2 terms\n///         x0*y2 + x1*y1 + x2*y0,               // 3 terms\n///         x1*y2 + x2*y1,                       // 2 terms\n///         x2*y2                                // 1 term\n///       ]\n///       The number of partial products per limb grows linearly from 1 to N,\n///       then decreases linearly back to 1.\n///\n///   * we also allow linear combinations inside the products, which further increases the bound\n///     on a `quadratic` limb\n///\n///   * finally, when `is_negative` flag is set, we effectively add 2 * MOD to each limb, where\n///     2 * MOD limbs are structured in such a way that they all are > 2**120\n///\n/// We allow `NUM_PRODUCTS < 64` completeness-wise, but it certainly can overflow the 2^{240 + `twiddle_factor=6`} bound\n/// in edge cases. See completeness section for an example.\n///\n/// ## Assumptions\n///\n/// Each `BigNum` value used in this gadget is already range constrained:\n///   - limbs `0..N-2` satisfy `limb_i < 2^{120}`\n///   - limb `N-1` satisfies `limb_{N-1} < 2^{TOP_LIMB_BITS}`\n///\n/// ## Completeness\n/// If an honest prover supplies inputs that satisfy the assumptions above,\n/// it can always find a `quotient` and `borrow_flags` such that the integer\n/// relation holds and all constraints are satisfied.\n///\n/// The only possibility to break completeness is by providing too many inputs, for example:\n///\n///     (a0 + a1 + a2) * (b0 + b1 + b2) + ... (60 times), with each a_i having its limbs at maximum value of 2^{120} - 1\n///     The middle limb will contain a value that will definitely overflow the 2^{246} bound.\n///\n/// ## Soundness\n/// This function is conditionally sound: it enforces that the degree-2 relation\n/// holds modulo `MOD`, but it does not, by itself, enforce that any particular\n/// term (for example a result `z`) is a *canonical* representative in\n/// `[0, MOD)`.\n///\n/// In other words, if the surrounding relation is invariant under adding a\n/// multiple of `MOD` to one of its terms, then a dishonest prover can exploit\n/// this. For example, consider a multiplication relation:\n///\n///     x * y - z = 0 (mod MOD)\n///\n/// Internally we encode this as:\n///\n///     x * y + 2 * MOD - z - quotient * MOD = 0\n///\n/// which is equivalent to:\n///\n///     x * y - z = (quotient - 2) * MOD\n///\n/// Suppose the honest witness uses some `z` satisfying\n/// `0 <= z < MOD` and some `quotient`. If the `BigNum` encoding allows\n/// `z' = z + MOD` (i.e. `z' < 2^{MOD_BITS}` still holds), then a dishonest\n/// prover can instead provide:\n///\n///     z' = z + MOD\n///     quotient' = quotient - 1\n///\n/// and still satisfy:\n///\n///     x * y + 2 * MOD - z' - quotient' * MOD = 0\n///\n/// even though `z'` is no longer the canonical representative of `x * y mod MOD`.\n///\n/// The same consideration applies to almost every constrained `BigNum` relation:\n/// whenever a value participates *only* through a modular equality, and no\n/// separate range constraint is imposed on that value, the prover is free to\n/// shift it by an extra `MOD` as long as the resulting limb\n/// encoding still satisfies its bit-bounds. This is inherent in working with\n/// modular constraints; the responsibility for enforcing canonical\n/// representatives lies with the caller when it is required.\n///\n/// This is the same \"extra modulus\" phenomenon as in the `add`/`sub` functions:\n/// the constraints are sound for modular arithmetic, but any caller that\n/// requires canonical outputs in `[0, MOD)` must additionally enforce a\n/// range check (for example via `validate_in_field`) on the relevant terms.\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    assert(NUM_PRODUCTS < 64, f\"evaluate_quadratic_expression overflow in operands count\");\n    // NUM_PRODUCTS < 64 is a light bound that tries to ensure each limb sum < 2^{246} so that the 126-bit bound is valid.\n\n    lhs_terms.for_each(|lhs_limbs: [[u128; N]; LHS_N]| {\n        lhs_limbs.for_each(|term: [u128; N]| validate_in_range::<u128, N, MOD_BITS>(term))\n    });\n    rhs_terms.for_each(|rhs_limbs: [[u128; N]; RHS_N]| {\n        rhs_limbs.for_each(|term: [u128; N]| validate_in_range::<u128, N, MOD_BITS>(term))\n    });\n    linear_terms.for_each(|term: [u128; N]| validate_in_range::<u128, N, MOD_BITS>(term));\n\n    let expression_limbs: [Field; 2 * N - 1] = compute_quadratic_expression_with_modulus::<N, MOD_BITS, LHS_N, RHS_N, NUM_PRODUCTS, ADD_N>(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    validate_expression_is_zero(expression_limbs);\n}\n\n// ------------------------------ UDIV MOD EXPRESSION ------------------------------\n\n/// Given a `udiv_mod` `BigNum` expression that is equal to `0` over integers, compute the borrow flags (unconstrained)\n///\n/// Mirror function of `__compute_quadratic_expression_with_borrow_flags` optimized to compute borrow flags of an expression:\n///     divisor * quotient + remainder - numerator = 0\n/// see `__compute_quadratic_expression_with_borrow_flags` for details\n///\n/// The main differences from it are:\n///     1. `product_limbs` stores only the least-significant `N` limbs of\n///         `quotient * divisor + remainder`. This is sufficient to compute the\n///         borrow flags for the first `N` limbs of\n///             quotient * divisor + remainder - numerator.\n///\n///         For an honest `udiv_mod` relation we also have\n///             quotient * divisor <= numerator < B^N,\n///         so the true product fits into `N` limbs as an integer.\n///     2. Instead of subtracting `quotient * MOD` we subtract `numerator`. This is due to the fact that\n///        we no longer work over `MOD`, and we can't really do subtractions as we did previously: `double_modulus - x`\n///\n/// ## Note\n/// We leave the borrow values at 2^{246}, even though we should never reach this bound with just 3 terms\n/// The cases where it can happen are: N >= 64 (middle limb will have 64 additions). And it is a pure completeness issue\n/// But the rest of the library will probably not work with that massive number anyway\nunconstrained fn __compute_udiv_mod_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n    quotient: [u128; N],\n    remainder: [u128; N],\n) -> [bool; N - 1] {\n    let mut product_limbs: [Field; N] = [0; N];\n    let mut numerator_field: [Field; N] = [0; N];\n    for i in 0..N {\n        for j in 0..N - i {\n            product_limbs[i + j] += (quotient[i] as Field) * (divisor[j] as Field);\n        }\n        product_limbs[i] += (remainder[i] as Field);\n\n        numerator_field[i] = numerator[i] as Field;\n    }\n\n    __compute_borrow_flags(product_limbs, numerator_field)\n}\n\n/// Constrained version of `__compute_udiv_mod_expression_with_borrow_flags`\n///\n/// Computes the following expression in-circuit:\n///     quotient * divisor + remainder - numerator = 0\n///\n/// Mirror function of `compute_quadratic_expression_with_modulus`. See it for details.\n///\n/// ## Soundness note\n/// We compute the full convolution `quotient * divisor` into `2N - 1` limbs\n/// and then constrain all limbs with index `i >= N` to be zero. For `i >= N`\n/// the value `expression_limbs_full[i]` is a sum of products\n///     sum_{j+k=i} quotient[j] * divisor[k]\n/// with no contribution from `numerator` or `remainder`.\n///\n/// Every limb of `quotient` and `divisor` is range-constrained to be a 120-bit\n/// integer, so each product term is < 2^{240} and each coefficient of the\n/// convolution is strictly smaller than the field modulus. In this regime,\n/// the constraint `expression_limbs_full[i] == 0` in `Field` coincides with\n/// the same equality over the integers.\n///\n/// Vanishing of all high limbs `i >= N` is therefore an integer statement that\n/// the product has degree < N, i.e.\n///     quotient * divisor < 2^{120 * N},\n/// so `quotient * divisor` fits into `N` 120-bit limbs and does not overflow.\nfn compute_udiv_mod_expression<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n    quotient: [u128; N],\n    remainder: [u128; N],\n) -> [Field; N] {\n    // Safety: use an unconstrained function to compute the value of the quotient and borrow_flags out-of-circuit\n    let borrow_flags: [bool; N - 1] = unsafe {\n        __compute_udiv_mod_expression_with_borrow_flags::<N, MOD_BITS>(\n            numerator,\n            divisor,\n            quotient,\n            remainder,\n        )\n    };\n\n    let mut expression_limbs_full: [Field; 2 * N - 1] = [0; 2 * N - 1];\n    for i in 0..N {\n        for j in 0..N {\n            expression_limbs_full[i + j] += (quotient[i] as Field) * (divisor[j] as Field);\n        }\n        expression_limbs_full[i] += (remainder[i] as Field) - (numerator[i] as Field);\n    }\n\n    let mut expression_limbs: [Field; N] = [0; N];\n    for i in 0..N {\n        expression_limbs[i] = expression_limbs_full[i];\n    }\n    for i in N..2 * N - 1 {\n        assert(expression_limbs_full[i] == 0);\n    }\n\n    apply_borrow_flags(expression_limbs, borrow_flags)\n}\n\n/// Constrain a `udiv_mod` `BigNum` expression to be equal to 0\n///\n/// Mirror function of `evaluate_quadratic_expression`\n///\n/// ## Details\n///\n/// The constrained expression, viewed over the integers, is:\n///\n///     quotient * divisor + remainder - numerator = 0\n///\n/// ## Completeness\n/// If an honest prover supplies valid `BigNum` inputs that satisfy the equation,\n/// it can always find `borrow_flags` such that the integer\n/// relation holds and all constraints are satisfied.\n///\n/// The only possibility to break completeness is by providing a `BigNum` with `N >= 64`\n/// See `__compute_udiv_mod_expression_with_borrow_flags` for details\n///\n/// ## Soundness\n/// This function is conditionally sound: it enforces that the degree-2 relation\n/// holds over the integers, but it does not, by itself, enforce that\n/// this relation is unique for given `numerator` and `divisor`\n///\n/// For example, if the true relation is\n///     quotient * divisor + remainder - numerator = 0\n///\n/// then we can set quotient' = quotient - 1, remainder' = remainder + divisor\npub(crate) fn validate_udiv_mod_expression<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n    quotient: [u128; N],\n    remainder: [u128; N],\n) {\n    validate_in_range::<u128, N, MOD_BITS>(numerator);\n    validate_in_range::<u128, N, MOD_BITS>(divisor);\n    validate_in_range::<u128, N, MOD_BITS>(quotient);\n    validate_in_range::<u128, N, MOD_BITS>(remainder);\n\n    let expression_limbs: [Field; N] =\n        compute_udiv_mod_expression::<N, MOD_BITS>(numerator, divisor, quotient, remainder);\n    validate_expression_is_zero(expression_limbs);\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/expressions.nr"
    },
    "88": {
      "source": "use crate::utils::map::invert_array;\n\n// Conversions between big endian and little endian byte arrays and BigNum instances\n// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\n\n/// Construct a `BigNum` value from a big-endian byte array.\n///\n/// The input encodes an integer in base 256, which we split into `N` 120-bit limbs.\n///\n/// ## Note\n/// We only enforce that the value is < 2^MOD_BITS. We do not enforce that it is\n/// reduced modulo the field modulus.\n///\n/// Consistency between `N` and `MOD_BITS` is expected:\n///     - `N * 15 >= num_bytes`\n///     - `num_bytes > (N - 1) * 15`\n///\n/// Enforcing range constraints on each limb is crucial for efficiency.\n/// In principle, accumulating `u8` values already bounds the integer,\n/// but relying on Noir to infer a `u128` from a large linear combination\n/// would trigger a very general (and expensive) range checks\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bytes: u32 = (MOD_BITS + 7) / 8;\n\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes: u32 = N * 15 - num_bytes;\n    let last_limb_bytes: u32 = 15 - excess_bytes;\n\n    let mut limb: Field = 0;\n    for i in 0..last_limb_bytes {\n        limb *= 256;\n        limb += x[i] as Field;\n    }\n\n    // TODO: Figure out why is it more efficient to apply 120-bit range constraint here\n    // Rather than `MOD_BITS - 120 * (N - 1)`-bit constraint\n    limb.assert_max_bit_size::<120>();\n    result[N - 1] = limb as u128;\n\n    let mut byte_ptr: u32 = last_limb_bytes;\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _ in 0..15 {\n            limb *= 256;\n            limb += x[byte_ptr] as Field;\n            byte_ptr += 1;\n        }\n        limb.assert_max_bit_size::<120>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    if (MOD_BITS % 8 != 0) {\n        let most_significant_byte: Field = x[0] as Field;\n        most_significant_byte.assert_max_bit_size::<MOD_BITS % 8>();\n    }\n    result\n}\n\n/// Construct a big-endian byte array from a `BigNum` value.\n///\n/// The output contains `(MOD_BITS + 7) / 8` bytes. We serialize the most\n/// significant limb first, which may occupy fewer than 15 bytes, followed by\n/// the remaining full 15-byte limbs in big-endian order.\n///\n/// Consistency between `N` and `MOD_BITS` is expected:\n///     - the most significant limb contributes `((MOD_BITS + 7) / 8) - (N - 1) * 15` bytes;\n///     - all other limbs are serialized as full 15-byte chunks.\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n\n    let last_limb_num_bytes: u32 = (MOD_BITS + 7) / 8 - (N - 1) * 15;\n    let mut byte_ptr: u32 = last_limb_num_bytes;\n    // First we deal with the full limbs\n    for i in 0..N - 1 {\n        let idx: u32 = (N - 1) - i - 1;\n        let limb_bytes: [u8; 15] = (val[idx] as Field).to_be_bytes();\n        for j in 0..15 {\n            result[byte_ptr] = limb_bytes[j];\n            byte_ptr += 1;\n        }\n    }\n\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n    for i in 0..last_limb_num_bytes {\n        result[i] = last_limb_bytes[i];\n    }\n\n    result\n}\n\n/// Construct a `BigNum` value from little-endian byte array\n///\n/// Reverse an array and apply `from_be_bytes`\n///\n/// See `from_be_bytes` for details\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let be_x: [u8; (MOD_BITS + 7) / 8] = invert_array(x);\n    from_be_bytes(be_x)\n}\n\n/// Construct a little-endian byte array from a `BigNum` value\n///\n/// Apply `to_be_bytes` and reverse an array\n///\n/// See `to_be_bytes` for details\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    invert_array(result_be)\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/serialization.nr"
    },
    "89": {
      "source": "// This file contains the unconstrained helpers that are mostly used by unconstrained ops\n\nuse crate::constants::TWO_POW_120;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __gte, __mul, __neg, __pow, __sqr};\n\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::{__normalize_limbs, __split_120_bits};\n\nuse crate::params::BigNumParams;\n\n// ------------------------------ DERIVATION HELPER FUNCTIONS ------------------------------\n\n///  Construct a `1` BigNum value (unconstrained)\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Construct a BigNum value from Field (unconstrained)\n///\n/// Split the native `Field` value into `N` 120-bit limbs\npub(crate) unconstrained fn __from_field<let N: u32>(val: Field) -> [u128; N] {\n    let mut x: Field = val;\n    let mut result: [u128; N] = [0; N];\n\n    if (N == 1) {\n        let (first_limb, _): (u128, Field) = __split_120_bits(x);\n        result[0] = first_limb;\n    }\n\n    if (N == 2) {\n        let (first_limb, x): (u128, Field) = __split_120_bits(x);\n        let (second_limb, _): (u128, Field) = __split_120_bits(x);\n        result[0] = first_limb;\n        result[1] = second_limb;\n    }\n\n    if (N > 2) {\n        let (first_limb, x): (u128, Field) = __split_120_bits(x);\n        let (second_limb, x): (u128, Field) = __split_120_bits(x);\n        let (third_limb, _): (u128, Field) = __split_120_bits(x);\n        result[0] = first_limb;\n        result[1] = second_limb;\n        result[2] = third_limb;\n    }\n    result\n}\n\n// ------------------------------ ARITHMETIC WITH FLAGS HELPER FUNCTIONS ------------------------------\n// These are the functions that compute modular operations results as well as borrow and carry flags for constraints\n\n/// Compute the `MOD - val` and the corresponding borrow flags (unconstrained)\n///\n/// Negate the value and compute the flags indicating whether we need\n///      to borrow a `bit` from the upper limb when subtracting the value from modulus\n///\n/// ## Note\n/// The `borrow_in` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term: u128 = val[i] + borrow_in;\n        borrow_in = (sub_term > modulus[i]) as u128;\n        result[i] = borrow_in * TWO_POW_120 + modulus[i] - sub_term;\n        if (i < N - 1) {\n            borrow_flags[i] = (borrow_in != 0);\n        }\n    }\n    (result, borrow_flags)\n}\n\n/// Compute modular addition and the corresponding borrow and carry flags (unconstrained)\n///\n/// Given `x, y, MOD` compute x + y or x + y - MOD in case it overflows\n/// Additionally compute all the carries from addition (x + y)\n/// and borrows from subtraction  (- MOD)\n///\n/// ## Note\n/// The `borrow` must be equal to `carry` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N - 1], [bool; N - 1], bool) {\n    let mask: u128 = TWO_POW_120 - 1;\n\n    let add_res: [u128; N] = __helper_add(lhs, rhs);\n    let overflow: bool = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = if overflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N - 1] = [false; N - 1];\n\n    let mut carry: u128 = 0;\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + rhs[i] + carry;\n        carry = add_term >> 120;\n        add_term &= mask;\n\n        let sub_term: u128 = subtrahend[i] + borrow;\n        borrow = (sub_term > add_term) as u128;\n\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n\n        // Only set `borrow` and `carry` if they differ\n        // And if it's not the last limb\n        if (carry != borrow) & (i < N - 1) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\n/// Compute modular subtraction and the corresponding borrow and carry flags (unconstrained)\n///\n/// Given `x, y, MOD` compute x - y or x - y + MOD in case it overflows\n/// Additionally compute all the carries from addition (x + MOD)\n/// and borrows from subtraction  (- y)\n///\n/// ## Note\n/// The `borrow` must be equal to `carry` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N - 1], [bool; N - 1], bool) {\n    let mask: u128 = TWO_POW_120 - 1;\n\n    let underflow: bool = !__gte(lhs, rhs);\n\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N - 1] = [false; N - 1];\n\n    let mut carry: u128 = 0;\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry;\n        carry = add_term >> 120;\n        add_term &= mask;\n\n        let sub_term: u128 = rhs[i] + borrow;\n        borrow = (sub_term > add_term) as u128;\n\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n\n        // Only set `borrow` and `carry` if they differ\n        // And if it's not the last limb\n        if (carry != borrow) & (i < N - 1) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/// Validate that lhs - rhs does not underflow (unconstrained)\n///\n/// Same as `__validate_gte_with_flags`, but we don't compute the\n/// result of a subtraction\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N - 1] {\n    let modulus: [u128; N] = params.modulus;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    borrow_flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        borrow_flags[i] = modulus[i] < val[i] + (borrow_flags[i - 1] as u128);\n    }\n    borrow_flags\n}\n\n/// Validate that lhs - rhs does not underflow (unconstrained)\n///\n/// Compute underflow flag (lhs < rhs)\n///       then perform subtraction with borrow flags\n///\n/// ## Note\n/// The `borrow` must be equal to 0 at the end of the loop.\n/// And it can't be nonzero, since we swap the terms at the beginning\npub(crate) unconstrained fn __validate_gte_with_flags<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N - 1]) {\n    let mut a: [u128; N] = lhs;\n    let mut b: [u128; N] = rhs;\n\n    let underflow: bool = !__gte(lhs, rhs);\n    // swap a and b if there's an underflow\n    let (a, b): ([u128; N], [u128; N]) = if underflow { (b, a) } else { (a, b) };\n\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let mut add_term: u128 = a[i];\n\n        let sub_term: u128 = b[i] + borrow;\n        borrow = (sub_term > add_term) as u128;\n\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, borrow_flags)\n}\n\n// ------------------------------ BARRETT REDUCTION ------------------------------\n\n/// `BARRETT_REDUCTION_OVERFLOW_BITS` defines how large an input to barrett reduction can be\n///\n/// maximum value = modulus^2 << BARRETT_REDUCTION_OVERFLOW_BITS\n/// see __barrett_reduction for more details\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\n/// Optimized modular multiplication (unconstrained)\n///\n/// The trick is to approximate 1/p with m/2**r, because division by 2**r is much cheaper\n/// In our case m = redc_param = floor(2^{MOD_BITS * 2 + BARRET_REDUCTION_OVERFLOW_BITS} / p)\n///             r = MOD_BITS * 2 + BARRET_REDUCTION_OVERFLOW_BITS\n///\n/// When we apply the barrett reduction, the maximum value of the output will be <= p * (1 + x/2^{2k})\n/// where p = modulus,\n///       x = reduction input\n///\n/// If x > p * p, we need k to be larger than modulus_bits()\n/// We hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n/// This should be larger than most values put into `evaluate_quadratic_expression`\n///\n/// ## TODO\n/// Detect cases where x might be too large at comptime\n///\n/// ## Note\n/// very niche edge case error that we need to be aware of:\n///      N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n///      i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow\n///      when calling __barrett_reduction\n///\n/// ## Note on final reduction\n///\n/// Assumptions:\n///  - k = ceil(log2 p), so p <= 2^k\n///  - s = 4, m = redc_param = floor(2^{2*k + s}/p)\n///  - x < 16 * p^2 (x < 2^{2 * k + s})\n///\n/// Let m' = 2^{2*k + s} / p, and write m = m' - \\epsilon, \\epsilon \\in [0, 1)\n//\n/// quo = floor(x * m / 2^{2 * k + s}) = floor(x * m' / 2^{2 * k + s} - x * \\epsilon / 2^{2 * k + s}) =\n/// floor(x / p - x * \\epsilon / 2^{2 * k + s})\n///\n/// Bounds:\n///   quo <= floor(x / p)\n///\n///   floor(a - b) >= floor(a) - ceil(b) (known identity) =>\n///   quo >= floor(x / p) - ceil(x * \\epsilon / 2^{2 * k + s})\n///       >= floor(x / p) - ceil(x / 2^{2 * k + s}) (epsilon < 1)\n///\n/// x / 2^{2 * k + s} < C * p^2 / 2^{2 * k + s} <= C * 2^{2 * k} / 2^{2 * k + s} = C / 2^s\n///\n/// When the assumption holds (C = 16), ceil(x / 2^{2 * k + s}) = 1, for x > 0\n/// Therefore quo = {floor(x/p), floor(x/p) - 1}\n///\n/// In first case: rem = x - quo * p = x - floor(x/p) * p < p\n/// In second case: rem = x - (floor(x/p) - 1) * p = (x - floor(x/p) * p) + p -> need 1 subtraction\n///\n/// ### Note\n/// We allow 64 products to be summed inside the `evaluate_quadratic_expression`\n/// In that case x / 2^{2 * k + s} < 64 / 2^4 = 4 => hence we need to subtract modulus at most 4 times\n/// We can leave it 2 for now as it is unlikely to reach beyond 32 * p^2\n///\n/// In the worst case though, we will have the input > 64 * p^2\n/// (for example (a1 + b1) * (c1 + d1) + ... 64 times)\n/// This is highly unlikely though.\n///\n/// ### TODO:\n/// Possibly change the `BARRETT_REDUCTION_OVERFLOW_BITS` to 6, so that we need only 1 reduction here\n/// However we will have to recompute all the fields `redc_param`s and fix paramgen\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    // TODO: switch to __helper_mul, once the compiler is smart enough to handle this\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(2 * N) {\n        for j in 0..N {\n            mulout_field[i + j] += (x[i] as Field) * (redc_param[j] as Field);\n        }\n    }\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field);\n\n    let quotient: [u128; 3 * N] = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // Remove a bunch of zeros from the end\n    let mut smaller_quotient: [u128; N] = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // long_quotient_mul_modulus can never exceed input value `x` so can fit into size-2 array\n    let long_quotient_mul_modulus: [u128; 2 * N] = __helper_mul(smaller_quotient, modulus);\n    let long_remainder: [u128; 2 * N] = __helper_sub(x, long_quotient_mul_modulus);\n\n    // Remove a bunch of zeros from the end\n    let mut remainder: [u128; N] = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n\n    for _ in 0..2 {\n        if (__gte(remainder, modulus)) {\n            remainder = __helper_sub(remainder, modulus);\n            smaller_quotient = __increment(smaller_quotient);\n        }\n    }\n\n    (smaller_quotient, remainder)\n}\n\n// ------------------------------ ARITHMETIC HELPER FUNCTIONS ------------------------------\n// These are the functions that operate on limbs as if they were just big integers\n\n/// Adds `1` to the BigNum value without modular reduction (unconstrained)\n///\n/// ## Note\n/// The `carry` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mask: u128 = TWO_POW_120 - 1;\n\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let add_term: u128 = val[i] + carry;\n        carry = add_term >> 120;\n        result[i] = add_term & mask;\n    }\n    result\n}\n\n/// Adds two `BigNum` values without modular reduction (unconstrained).\n///\n/// ## Note\n/// The `carry` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry: u128 = 0;\n    let mask: u128 = TWO_POW_120 - 1;\n\n    for i in 0..N {\n        let add_term: u128 = lhs[i] + rhs[i] + carry;\n        carry = add_term >> 120;\n        result[i] = add_term & mask;\n    }\n    result\n}\n\n/// Subtracts two `BigNum` values without modular reduction (unconstrained).\n///\n/// ## Note\n/// The `borrow` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let subtrahend: u128 = rhs[i] + borrow;\n        borrow = (subtrahend > lhs[i]) as u128;\n        result[i] = (borrow << 120) + lhs[i] - subtrahend;\n    }\n    result\n}\n\n/// Multiplies two `BigNum` values without modular reduction (unconstrained).\n///\n/// Computes the full schoolbook product of two N-limb little-endian arrays\n///\n/// ## Note\n/// The mathematical product fits in `2 * N - 1` limbs, but we keep `2 * N`\n/// limbs intentionally as the extra high limb safely absorbs a possible single limb overflow\n/// for moduli close to `120 * N` bits.\npub(crate) unconstrained fn __helper_mul<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; 2 * N] {\n    let mut result: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            result[i + j] += (lhs[i] as Field) * (rhs[j] as Field);\n        }\n    }\n    __normalize_limbs(result)\n}\n\n// ------------------------------ LOGIC HELPER FUNCTIONS ------------------------------\n// These are the functions that operate on limbs as if they were just big integers\n\n/// Left-shifts a `BigNum` value by `shift` bits (unconstrained).\n///\n/// Performs a bitwise left shift across limbs.\n///\n/// ## Note\n/// The most significant limb is truncated to 120 bits after the shift.\n///\n/// No bounds check is performed on `num_shifted_limbs`.\n/// However, we use it only in `__udiv_mod`, where it is not possible to reach\n/// `num_shifted_limbs` > `N`\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs: u32 = shift / 120;\n    let limb_shift: u128 = (shift % 120) as u128;\n    let remainder_shift: u128 = 120 - limb_shift;\n\n    let mask: u128 = TWO_POW_120 - 1;\n    let mut remainder: u128 = input[0] >> remainder_shift;\n\n    result[num_shifted_limbs] = (input[0] << limb_shift) & mask;\n\n    for i in 1..(N - num_shifted_limbs) {\n        let value: u128 = input[i];\n        let upshift: u128 = ((value << limb_shift) | remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = value >> remainder_shift;\n    }\n    result\n}\n\n/// Right-shifts a `BigNum` value by `shift` bits (unconstrained).\n///\n/// Performs a bitwise right shift across limbs.\n///\n/// # Note\n/// No bounds check is performed on `num_shifted_limbs`.\n/// However, we use it only in `__tonelli_shanks_sqrt`, where it is not possible to reach\n/// `num_shifted_limbs` > `N`\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs: u32 = shift / 120;\n    let limb_shift: u128 = (shift % 120) as u128;\n\n    let remainder_shift: u128 = 120 - limb_shift;\n    let low_mask: u128 = (1 as u128 << limb_shift) - 1;\n\n    result[0] = input[num_shifted_limbs] >> limb_shift;\n    for i in 1..(N - num_shifted_limbs) {\n        let value: u128 = input[i + num_shifted_limbs];\n\n        let carry: u128 = (value & low_mask) << remainder_shift;\n        result[i - 1] |= carry;\n\n        result[i] = value >> limb_shift;\n    }\n    result\n}\n\n/// Right-shifts a `BigNum` value by `1` bit  (unconstrained)\n///\n/// # Note\n/// All the operations on limbs are executed in place\n/// to save opcodes\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value: u128 = input[N - 1];\n    let mut remainder: u128 = (value & 1) << 119;\n    input[N - 1] >>= 1;\n\n    for i in 1..N {\n        let value: u128 = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) | remainder;\n        remainder = (value & 1) << 119;\n    }\n    input\n}\n\n/// Returns the index of the most significant set bit in a `BigNum` value (unconstrained).\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count: u32 = 0;\n    for i in 0..N {\n        let idx: u32 = N - 1 - i;\n        let v: u128 = val[idx];\n        if (v > 0) {\n            count = 120 * idx + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\n/// Returns `true` if the bit at position `bit` is set in the `BigNum` (unconstrained).\n///\n/// ## Note\n/// No bounds check is performed on `bit`\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index: u128 = (bit % 120) as u128;\n\n    let limb: u128 = input[segment_index];\n    let value: u128 = (limb >> uint_index) & 1;\n    value == 1\n}\n\n// ------------------------------ SQRT HELPER FUNCTIONS ------------------------------\n// These are the functions that are used during taking a square root\n\n/// Compute the maximal power of 2 that divides the group order (unconstrained)\n///\n/// Find the maximum value s such that `MOD = 2^s * q + 1`, where `q` is odd\n///       This is needed for our Tonelli-Shanks sqrt algorithm\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n) -> u32 {\n    let mut target: [u128; N] = __helper_sub(params.modulus, __one());\n    let mut result: u32 = 0;\n    while !__get_bit(target, result) {\n        result += 1;\n    }\n    result\n}\n\n/// Find a quadratic non-residue `g` where `g` is the smallest such value (unconstrained)\n///       i.e. smallest `g` such that `g^{(p - 1)/2} = -1 (mod MOD)`\n///       or smallest `g`, such that `x^2 - g = 0 (mod MOD)` has no solutions\n///\n/// ## Note\n/// WARNING If the field is not prime, this function will enter an infinite loop!\npub(crate) unconstrained fn __quadratic_non_residue<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n) -> [u128; N] {\n    let one: [u128; N] = __one();\n    let neg_one: [u128; N] = __neg(params.modulus, one);\n\n    let p_minus_one_over_two: [u128; N] = __shr1(__helper_sub(params.modulus, __one()));\n\n    // We start with 2\n    let mut target: [u128; N] = __increment(one);\n    let mut expd: [u128; N] = __pow(params, target, p_minus_one_over_two);\n    while !__eq(expd, neg_one) {\n        target = __increment(target);\n        expd = __pow(params, target, p_minus_one_over_two);\n    }\n    target\n}\n\n/// Compute the smallest `i`, such that `t^{2^i} = 1, t^{2^{i-1}} = -1 (mod MOD)` (unconstrained)\n///\n/// ## Note\n/// Multiplicative order of t must divide 2^v2(MOD-1), otherwise you'll end up in an infinite loop!\npub(crate) unconstrained fn __tonelli_shanks_sqrt_find_i<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    t: [u128; N],\n) -> u32 {\n    let one: [u128; N] = __one();\n    let mut c: [u128; N] = t;\n\n    let mut i: u32 = 0;\n    // Compute t^{2^k} until it hits 1 for the first time\n    while !__eq(c, one) {\n        c = __sqr::<N, MOD_BITS>(params, c);\n        i += 1;\n    }\n    i\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/unconstrained_helpers.nr"
    },
    "90": {
      "source": "// This file contains the unconstrained operations that are used directly by BigNum class\n\nuse crate::fns::constrained_ops::derive_from_seed;\n\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_mul, __helper_sub,\n    __increment, __one, __primitive_root_log_size, __quadratic_non_residue, __shl, __shr, __shr1,\n    __tonelli_shanks_sqrt_find_i,\n};\n\nuse crate::constants::TWO_POW_120;\n\nuse crate::params::BigNumParams;\n\n// ------------------------------ DERIVATION FUNCTIONS ------------------------------\n\n/// Deterministically derives a `BigNum` from a seed value (unconstrained)\n///\n/// Takes a seed byte array and generates a `BigNum` in the range [0, modulus-1].\n///\n/// See more information in `constrained_ops.nr`: `derive_from_seed`\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed)\n}\n\n// ------------------------------ COMPARISON FUNCTIONS ------------------------------\n\n/// Compare two limb arrays for equality (unconstrained)\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\n/// Compare a limb array to a zero array (unconstrained)\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    limbs == [0; N]\n}\n\n/// Compare two little-endian limb arrays for `lhs >= rhs` over integers (unconstrained)\n///\n/// Starts from the most significant limb (`N - 1`) and returns true\n/// if `lhs` is greater or equal to `rhs`\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        let idx: u32 = N - 1 - i;\n        if (lhs[idx] != rhs[idx]) {\n            result = lhs[idx] > rhs[idx];\n            break;\n        }\n    }\n    result\n}\n\n// ------------------------------ ARITHMETIC FUNCTIONS ------------------------------\n\n/// Negates a `BigNum` value, returning `m - x` (unconstrained)\n///\n/// ## Note\n/// The input is assumed to be less than modulus\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\n/// Adds two `BigNum` values with modular reduction (unconstrained)\n///\n/// Sums the limbs one by one, keeping the carry.\n/// In case the result overflows the modulus, the modulus is subtracted once\n///\n/// ## Note\n/// The `carry` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    let mask: u128 = TWO_POW_120 - 1;\n\n    for i in 0..N {\n        let add_term: u128 = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        result[i] = add_term & mask;\n    }\n\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/// Subtracts two `BigNum` values with modular reduction (unconstrained).\n///\n/// Computes `x + (m - y)` (mod m)\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\n/// Multiply `x` and `y` and reduce via Barrett, returning (Q, R) (unconstrained).\n///\n/// For `BigNum` values `x` and `y` compute (`Q`, `R`) such that:\n///      x * y = R + Q * m, 0 <= R < m\n/// See `__barrett_reduction` for details.\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let to_reduce: [u128; N * 2] = __helper_mul(lhs, rhs);\n    let (q, r): ([u128; N], [u128; N]) =\n        __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\n/// Multiplies two `BigNum` values with modular reduction (unconstrained).\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __mul_with_quotient::<N, MOD_BITS>(params, lhs, rhs).1\n}\n\n/// Squares a `BigNum` value with modular reduction (unconstrained).\npub(crate) unconstrained fn __sqr<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    __mul_with_quotient::<N, MOD_BITS>(params, val, val).1\n}\n\n/// Modular exponentiation via square-and-multiply. LSB-first (unconstrained).\n///\n/// Computes `x^e mod m`\n///\n/// ## Note\n/// For the loop, we are using `MOD_BITS` instead of `__get_msb`\n/// because it is much much cheaper\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let mut accumulator: [u128; N] = __one();\n    let mut x: [u128; N] = val;\n    let num_bits: u32 = MOD_BITS + 1;\n\n    for i in 0..num_bits {\n        if __get_bit(exponent, i) {\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, x);\n        }\n        x = __sqr::<N, MOD_BITS>(params, x);\n    }\n    accumulator\n}\n\n/// Given a `BigNum` value `x` compute x^{-1} (mod m) (unconstrained)\n///\n/// x^{p-1} = 1 (mod p) (Fermat's little theorem)\n/// x^{p-2} = x^{-1} (mod p)\n///\n/// ## Note\n/// The input value must be nonzero and modulus has to be prime\n/// No explicit assertion is made, as this condition is validated during evaluation\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one: [u128; N] = __one();\n    let exp: [u128; N] = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<N, MOD_BITS>(params, val, exp)\n}\n\n/// Divides two `BigNum` values with modular reduction (unconstrained).\n///\n/// Computes `x * y^{-1}` (mod m)\n///\n/// ## Note\n/// The divisor must be nonzero\n/// No explicit assertion is made, as this condition is validated during evaluation\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<N, MOD_BITS>(params, divisor);\n    __mul::<N, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/// Given the `BigNum` inputs `x, y`, compute integer division x / y (unconstrained)\n///\n/// This function implements binary long division and outputs (`quotient`, `remainder`) such that:\n///   1. floor(numerator / divisor) = quotient\n///   2. numerator % divisor = remainder\n///   3. divisor * quotient + remainder = numerator\n///\n/// ## Note\n/// The divisor must be nonzero\n/// No explicit assertion is made, as this condition is validated during evaluation\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n    let b: [u128; N] = divisor;\n\n    let numerator_msb: u32 = __get_msb(numerator);\n    let divisor_msb: u32 = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference: u32 = __get_msb(remainder) - __get_msb(divisor);\n        let mut divisor: [u128; N] = __shl(divisor, bit_difference);\n        let mut accumulator: [u128; N] = __shl(__one(), bit_difference);\n\n        // The same as divisor > remainder\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        (quotient, remainder)\n    }\n}\n\n/// Batch modular inversion of `BigNum` values in an array (unconstrained)\n///\n/// Given values v[0..M), returns inv[0...M) with inv[i] = v[i]^{-1} (mod m)\n///\n/// We use the Montgomery trick:\n/// First we compute the partial products:\n///         T0 = 1\n///         T1 = v1,\n///         T2 = v1 * v2,\n///         ...\n///         T_{m - 1} = T_{m - 2} * v_{m - 1} = v1 * ... * v_{m - 1}\n///\n///         P = T_{m-1} * v_m = v1 * v2 * ... * v_m\n///\n/// Then we calculate a single inverse P^-1 = v1^-1 * v2^-1 * ... * v_m^-1\n/// Finally we compute\n///         v_m^-1       = (P^-1 * T_{m-1})\n///         v_{m - 1}^-1 = (P^-1 * v_m * T_{m - 2})\n///         ....\n///         v_2^-1       = (P^-1 * v_m * ... * v_3 * T_1)\n///         v_1^-1       = (P^-1 * v_m * ... * v_2 * T_0)\n///\n/// ## Note\n/// Zero elements are allowed and are left unchanged in the resulting array\n///\n/// This interacts poorly with `neg(zero)`:\n/// Calling `neg` on `zero` yields `modulus` rather than `0`.\n/// A value in this form will **not** satisfy\n/// the `__is_zero` check and will lead to incorrect results.\n///\n/// This edge case should be rare, but it's worth keeping in mind when\n/// composing operations or debugging unexpected behavior\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    vals: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    let mut accumulator: [u128; N] = __one();\n    let mut temporaries: [[u128; N]; M] = [[0; N]; M];\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(vals[i])) {\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<N, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx: u32 = M - 1 - i;\n        if (!__is_zero(vals[idx])) {\n            let T0: [u128; N] = __mul::<N, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/// Batch modular inversion of `BigNum` values in a slice (unconstrained)\n///\n/// See `batch_invert` for details\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    vals: [[u128; N]],\n) -> [[u128; N]] {\n    let mut accumulator: [u128; N] = __one();\n    let mut temporaries: [[u128; N]] = &[];\n\n    let M: u32 = vals.len();\n\n    for i in 0..M {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(vals[i])) {\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<N, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx: u32 = M - 1 - i;\n        if (!__is_zero(vals[idx])) {\n            let T0: [u128; N] = __mul::<N, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        }\n    }\n\n    result\n}\n\n/// Compute a modular square root in a prime field (unconstrained)\npub(crate) unconstrained fn __sqrt<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum::__sqrt: Must be a field to take square roots\",\n    );\n\n    if (__is_zero(input)) {\n        Option::some(input)\n    } else if (params.modulus[0] % 4 == 3) {\n        __easy_sqrt(params, input)\n    } else {\n        __tonelli_shanks_sqrt(params, input)\n    }\n}\n\n/// Compute a modular square root using the Tonelli-Shanks algorithm (unconstrained)\n///\n/// Solves `x^2 = a (mod MOD)` for odd prime MOD\n///\n/// ## Algorithm\n///\n/// Here p = MOD\n///\n/// Tonelli-Shanks setup\n///\n/// Write `p - 1 = 2^s * Q`, `Q` - odd\n/// Define:\n///    `R = a^{(Q+1)/2}`\n///    `t = a^Q`\n///\n/// so that `R^2 = a^{Q + 1} = a * a^Q = a * t`\n/// If t = 1, we are done\n///\n/// By Euler's criterion, `a` is a quadratic reside iff `a^{(p - 1)/2} = 1`\n/// Since `t = a^Q` and `(p - 1) / 2 = Q * 2^{s-1}` we have:\n///    `t^{2^{s-1}} = a^{Q * 2^{s-1}} = a^{(p-1)/2} = 1`, assuming `a` is a q.r.\n///\n/// To proceed with computing our square root, we want to transfer `t` into a smaller subgroup,\n/// specifically, the `2^(s-2)`'th roots of unity or lower.\n///\n/// We do this by finding some value `b`, such that\n/// `(t * b^2)^{2^{s-2}} = 1` and `R' = R * b`\n/// Finding such a `b` is trivial, because from Euler's criterion, we know that,\n/// for any quadratic non-residue `z`, `z^{(p - 1) / 2} = -1`\n/// i.e. `z^{Q * 2^{s-1}} = -1`\n/// => `z^Q` is a `2^{s-1}`'th root of `-1`\n/// => `z^{2 * Q}` is a `2^{s-2}`'th root of `-1`\n///\n/// Since `t^{2^{s-1}} = 1`, we know that for some `i`, `i <= s - 2: t^{2^{i-1}} = -1`\n/// => `t * z^{2 * Q}` is a `2^{s - 2}`'th root of unity.\n/// We can iteratively transform `t` into ever smaller subgroups, until `t = 1`.\n/// At each iteration, we need to find a new value for `b`, which we can obtain\n/// by repeatedly squaring `z^Q`\n///\n/// ## Note\n/// Only use for prime fields! Function may infinite loop if used for non-prime fields\n///\n/// The input is assumed to be a nonzero value\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    let mut result: Option<[u128; N]> = Option::none();\n\n    let one: [u128; N] = __one();\n    let s: u32 = __primitive_root_log_size::<N, MOD_BITS>(params); // p - 1 = 2^s * Q, where Q is odd\n    let Q: [u128; N] = __shr(__helper_sub(params.modulus, one), s);\n    let Q_minus_one_over_two: [u128; N] = __shr1(__helper_sub(Q, one)); // (Q - 1) / 2\n\n    let z: [u128; N] = __quadratic_non_residue::<N, MOD_BITS>(params);\n\n    // Initialize:\n    // b = a^{(Q - 1)/2}\n    // R = a * b = a^{(Q + 1) / 2} => R^2 = a * a^Q\n    // t = R * b = a^Q\n    let mut b: [u128; N] = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r: [u128; N] = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t: [u128; N] = __mul::<_, MOD_BITS>(params, r, b);\n\n    let mut check: [u128; N] = t;\n    // Assure t^{2^{s - 1}} = a^{(p -1)/2} = 1, otherwise we have met a non-residue\n    for _ in 0..s - 1 {\n        check = __sqr::<N, MOD_BITS>(params, check);\n    }\n    if (__eq(check, one)) {\n        let mut m: u32 = s;\n        let mut c: [u128; N] = __pow::<N, MOD_BITS>(params, z, Q); // z^Q - proper 2^{M}'th root of unity\n\n        // Tonelli-Shanks main loop\n\n        // At the beginning of each iteration we have:\n        // M - current exponent such that t lies in the subgroup of order 2^m\n        // t - element, whose order divides 2^m\n        // c - the proper 2^M'th root of unity\n        // R - accumulator with R^2 = a * t\n\n        // If t == 1, we are done and R is a square root\n        //\n        // Otherwise\n        // 1. We compute 1 <= i < M, such that t^{2^i} = 1, t^{2^{i - 1}} = -1\n        // 2. Set b = c^{2^{M - i - 1}}, so it becomes a proper 2^(i+1)'th root of unity\n        //      Then b^2 has order 2^i which matches the order of t\n        //\n        // 3. Update the state values:\n        //    R <- R * b\n        //    t <- t * b^2\n        //    c <- b^2 = c^{2^{M - i}}\n        //    M <- i\n        // reduces the order of t from 2^i to at most 2^{i - 1} and preserves R^2 = a * t\n        //\n        // The loop runs at most s times because M strictly decreases\n        for _ in 0..s {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let i: u32 = __tonelli_shanks_sqrt_find_i::<N, MOD_BITS>(params, t);\n            let mut j: u32 = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                b = __sqr(params, b);\n            }\n\n            let b2: [u128; N] = __sqr::<N, MOD_BITS>(params, b);\n            c = b2;\n            t = __mul::<N, MOD_BITS>(params, t, b2);\n            r = __mul::<N, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\n/// Compute a modular square root for MOD = 3 (mod 4) (unconstrained)\n///\n/// In case MOD = 3 (mod 4), the square root can be computed using the formula:\n///     `R = a^{(MOD + 1) / 4} (mod MOD)`\n///\n/// Then R^2 = a^{(MOD + 1)/ 4 * 2} = a^{(MOD + 1) / 2} = a^{(MOD - 1) / 2 + 1} = a\n///\n/// ## Note\n/// The input is assumed to be a nonzero value\n///\n/// This is much cheaper than `__tonelli_shanks_sqrt`\npub(crate) unconstrained fn __easy_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    let mut result: Option<[u128; N]> = Option::none();\n\n    let one: [u128; N] = __one();\n    let p_minus_one_over_two: [u128; N] = __shr1(__helper_sub(params.modulus, one));\n    let mut check: [u128; N] = __pow(params, input, p_minus_one_over_two);\n    if (__eq(check, one)) {\n        // a = (MOD - 1) / 2\n        // b = (a + 1) / 2 = ((MOD - 1) / 2 + 1) / 2 = (MOD + 1) / 4\n        let p_plus_one_over_four: [u128; N] = __shr1(__increment(p_minus_one_over_two));\n        result = Option::some(__pow(params, input, p_plus_one_over_four));\n    }\n    result\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/unconstrained_ops.nr"
    },
    "99": {
      "source": "use std::ops::WrappingMul;\n\nglobal MUL_DE_BRUIJN_BIT: [u32; 128] = [\n    1, 14, 2, 15, 26, 20, 3, 16, 68, 80, 27, 21, 56, 50, 4, 17, 65, 96, 69, 81, 105, 99, 28, 22, 86,\n    90, 57, 51, 72, 42, 5, 126, 18, 66, 48, 94, 97, 84, 70, 124, 82, 122, 106, 100, 114, 108, 29,\n    23, 77, 102, 87, 91, 119, 116, 58, 52, 61, 110, 73, 37, 43, 31, 6, 127, 13, 25, 19, 67, 79, 55,\n    49, 64, 95, 104, 98, 85, 89, 71, 41, 125, 47, 93, 83, 123, 121, 113, 107, 76, 101, 118, 115, 60,\n    109, 36, 30, 12, 24, 78, 54, 63, 103, 88, 40, 46, 92, 120, 112, 75, 117, 59, 35, 11, 53, 62, 39,\n    45, 111, 74, 34, 10, 38, 44, 33, 9, 32, 8, 7, 128,\n];\n\n/// Get the most significant bit position of a `val` (unconstrained)\n///\n/// Bit hack that uses De Bruijn sequence to calculate msb position in log(N)\n/// See [IntegerLog2DeBruijn](https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn)\npub(crate) unconstrained fn get_msb(x: u128) -> u32 {\n    let result: u32 = if x == 0 {\n        0\n    } else {\n        let mut v: u128 = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        v |= v >> 64;\n        let index: u128 = (v.wrapping_mul(0x1FC10C2FBCF471B913B14CD2595D6D5)) >> 121;\n        MUL_DE_BRUIJN_BIT[index as u32]\n    };\n    result\n}\n\nmod tests {\n    use crate::constants::{TWO_POW_120, TWO_POW_60};\n    use crate::fns::unconstrained_helpers::__get_msb;\n    use super::get_msb as get_msb128;\n    use std::ops::WrappingMul;\n\n    fn assert_msb_equal(x: u64) {\n        // Safety: test code\n        let msb64 = unsafe { get_msb64(x) };\n        // Safety: test code\n        let msb128 = unsafe { get_msb128(x as u128) };\n        assert_eq(msb64, msb128);\n    }\n\n    #[test]\n    /// Check that the msb functions are equivalent with de bruijn sequence for 64 bits and 128 bits\n    fn test_get_msb() {\n        // Test case 1: MSB at position 7\n        let x: u64 = 0x80; // binary: 10000000\n        assert_msb_equal(x);\n\n        // Test case 2: MSB at position 0\n        let x: u64 = 0x1; // binary: 00000001\n        assert_msb_equal(x);\n\n        // Test case 3: MSB at position 63\n        let x: u64 = 0x8000000000000000; // binary: 1000...0000 (63 zeros)\n        assert_msb_equal(x);\n\n        // Test case 4: Zero input\n        let x: u64 = 0x0;\n        assert_msb_equal(x);\n\n        // Test case 5: All bits set\n        let x: u64 = 0xFFFFFFFFFFFFFFFF;\n        assert_msb_equal(x);\n    }\n\n    /// Multiple entires in the `MUL_DE_BRUIJN_BIT` list do not map to a valid output of `v * 0x6c04f118e9966f6b`.\n    /// This is a dummy value to fill the gaps in the map.\n    global n1: u32 = 0xffffffff;\n\n    global MUL_DE_BRUIJN_BIT_64: [u32; 128] = [\n        0, // change to 1 if you want bitSize(0) = 1\n        48, n1, n1, 31, n1, 15, 51, n1, 63, 5, n1, n1, n1, 19, n1, 23, 28, n1, n1, n1, 40, 36, 46,\n        n1, 13, n1, n1, n1, 34, n1, 58, n1, 60, 2, 43, 55, n1, n1, n1, 50, 62, 4, n1, 18, 27, n1,\n        39, 45, n1, n1, 33, 57, n1, 1, 54, n1, 49, n1, 17, n1, n1, 32, n1, 53, n1, 16, n1, n1, 52,\n        n1, n1, n1, 64, 6, 7, 8, n1, 9, n1, n1, n1, 20, 10, n1, n1, 24, n1, 29, n1, n1, 21, n1, 11,\n        n1, n1, 41, n1, 25, 37, n1, 47, n1, 30, 14, n1, n1, n1, n1, 22, n1, n1, 35, 12, n1, n1, n1,\n        59, 42, n1, n1, 61, 3, 26, 38, 44, n1, 56,\n    ];\n\n    pub(crate) unconstrained fn get_msb64(x: u64) -> u32 {\n        let mut v: u64 = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        let index: u64 = (v.wrapping_mul(0x6c04f118e9966f6b)) >> 57;\n        (index as Field).assert_max_bit_size::<32>();\n        MUL_DE_BRUIJN_BIT_64[index as u32]\n    }\n\n    unconstrained fn __get_msb64<let N: u32>(val: [u128; N]) -> u32 {\n        let mut count: u32 = 0;\n        for i in 0..N {\n            let v: u128 = val[((N) - 1 - i)];\n            let v_low: u64 = v as u64 % TWO_POW_60 as u64;\n            let v_high: u64 = ((v - v_low as u128) / TWO_POW_60) as u64;\n            if (v_high > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n                break;\n            }\n            if (v_low > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n                break;\n            }\n        }\n        count\n    }\n\n    #[test]\n    // Check that the msb functions are equivalent with De Bruijn sequence for 64 bits and 128 bits\n    unconstrained fn test_get_msb_equivalence() {\n        // Test single limb (64-bit number)\n        let x: Field = 0x8000000000000000;\n        let arr: [u128; 4] = [0, 0, x as u128, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test multiple limbs (120-bit number)\n        let x: Field = 0x800000000000000000000000000000; // 120 bits number, 2^119\n        let arr: [u128; 4] = [0, 0, x as u128, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test zero\n        let arr: [u128; 4] = [0, 0, 0, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test all bits set (120 bits)\n        let x: Field = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // 120 bits, 2^120 - 1\n        let arr: [u128; 4] = [0, x as u128, 0, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test systematic bit positions\n        for i in 0..120 {\n            let x: u128 = 1;\n            let shifted: u128 = x << i;\n            let arr: [u128; 4] = [0, shifted, 0, 0];\n            let msb1: u32 = __get_msb64(arr);\n            let msb2: u32 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test random-like patterns (multiple bits set)\n        let patterns: [Field; 7] = [\n            0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // alternating bits\n            0x555555555555555555555555555555, // alternating bits (opposite)\n            0x1234567890ABCDEF1234567890ABCD, // some pattern\n            0xFEDCBA0987654321FEDCBA09876543, // some pattern\n            0x800000000000000000000000000001, // highest and lowest bits\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE, // all bits except lowest\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFF, // all bits except highest\n        ];\n        for i in 0..patterns.len() {\n            let arr: [u128; 4] = [0, patterns[i] as u128, 0, 0];\n            let msb1: u32 = __get_msb64(arr);\n            let msb2: u32 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test with MSB in different array positions (120 bits)\n        let x: Field = 0x800000000000000000000000000000; // 120 bits\n        let arr1: [u128; 4] = [x as u128, 0, 0, 0];\n        let arr2: [u128; 4] = [0, x as u128, 0, 0];\n        let arr3: [u128; 4] = [0, 0, x as u128, 0];\n        let arr4: [u128; 4] = [0, 0, 0, x as u128];\n        let msb1_1: u32 = __get_msb64(arr1);\n        let msb2_1: u32 = __get_msb(arr1);\n        assert_eq(msb1_1, msb2_1);\n\n        let msb1_2: u32 = __get_msb64(arr2);\n        let msb2_2: u32 = __get_msb(arr2);\n        assert_eq(msb1_2, msb2_2);\n\n        let msb1_3: u32 = __get_msb64(arr3);\n        let msb2_3: u32 = __get_msb(arr3);\n        assert_eq(msb1_3, msb2_3);\n\n        let msb1_4: u32 = __get_msb64(arr4);\n        let msb2_4: u32 = __get_msb(arr4);\n        assert_eq(msb1_4, msb2_4);\n    }\n\n    #[test]\n    unconstrained fn fuzz_get_msb(seed: [u128; 5]) {\n        let mut seed_copy: [u128; 5] = seed;\n        for i in 0..5 {\n            seed_copy[i] = seed_copy[i] & (TWO_POW_120 - 1);\n        }\n        let msb1: u32 = __get_msb64(seed_copy);\n        let msb2: u32 = __get_msb(seed_copy);\n        assert_eq(msb1, msb2);\n    }\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/utils/msb.nr"
    },
    "100": {
      "source": "use crate::constants::TWO_POW_120;\n\n/// Split the Field value into two 120-bit limbs (unconstrained)\n///\n/// Here we're taking advantage of truncating 120 bit limbs from the input field\n/// and then subtracting them from the input such that the field division is equivalent\n/// to integer division.\n///\n/// We return the lower 120-bit limb as a `u128` value,\n/// and the upper limbs as a `Field`, to avoid unnecessary conversions\n/// and potential overflows\npub(crate) unconstrained fn __split_120_bits(mut x: Field) -> (u128, Field) {\n    let low: u128 = (x as u128) % TWO_POW_120;\n    let high: Field = ((x - low as Field) / TWO_POW_120 as Field);\n    (low, high)\n}\n\n/// Normalize an array of Field values into 120-bit limbs (unconstrained)\n///\n/// Each Field element is split into two parts modulo 2^{120}\n/// The overflow from the lower limbs is carried into the higher limbs\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(input: [Field; N]) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(N - 1) {\n        let (lo, hi): (u128, Field) = __split_120_bits(next);\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    let (lo, hi): (u128, Field) = __split_120_bits(next);\n    normalized[N - 1] = lo;\n\n    // non-zero final carry <=> normalized value overflows the array length\n    assert(hi == 0);\n\n    normalized\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/utils/split_bits.nr"
    },
    "110": {
      "source": "mod scalar_field;\nmod test;\npub mod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    pub x: Field,\n    pub y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\npub trait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx = scalar.base4_slices[i] as u32;\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0] as u32;\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx = scalars[j].base4_slices[i] as u32;\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/lib.nr"
    },
    "111": {
      "source": "use std::static_assert;\n\n/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub global TWO_POW_128: Field = 0x100000000000000000000000000000000;\npub global PLO: Field = 0x2833e84879b9709143e1f593f0000001;\npub global PHI: Field = 0x30644e72e131a029b85045b68181585d;\n\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = to_le_radix_16(x);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices<let N: u32>(x: [u8; N], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..N {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\n\nunconstrained fn to_le_radix_16<let N: u32>(value: Field) -> [u8; N] {\n    // Round up on odd values of `N` to ensure space for last nibble.\n    let bytes = value.to_le_bytes::<(N + 1) / 2>();\n    let mut result: [u8; N] = [0; N];\n    for index in 0..(N / 2) {\n        result[index * 2] = bytes[index] & 0x0F; // Extract low nibble (bits 0-3)\n        result[index * 2 + 1] = (bytes[index] >> 4); // Extract high nibble (bits 4-7)\n    }\n    if (N & 1) == 1 {\n        let last_nibble = bytes[bytes.len() - 1];\n        // The last byte must have the top 4 bits empty.\n        (last_nibble as Field).assert_max_bit_size::<4>();\n        result[N - 1] = last_nibble;\n    }\n    result\n}\n\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        // the field elements have 254 bits max, so we do not need to support N > 64\n        static_assert(N <= 64, \"N must be at most 64\");\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = 0;\n            let mut hi: Field = 0;\n\n            for i in 0..32 {\n                lo *= 16;\n                lo += (slices[32 + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            // Safety: we assert that the absolute value has less than 128 bits\n            let is_positive: bool = unsafe { get_borrow_flag(lo, TWO_POW_128) };\n\n            let abs_lo = (is_positive as Field) * lo + (1 - is_positive as Field) * (-lo);\n\n            abs_lo.assert_max_bit_size::<128>();\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            let borrow = unsafe { get_borrow_flag(PLO, abs_lo) as Field };\n            // we only need to check the rlo has 128 bits or less if lo is positive. if negative, the lo is already less than PLO\n            let rlo = is_positive as Field * (PLO - lo + borrow * TWO_POW_128 - 1)\n                + (1 - is_positive as Field) * (-lo); // -1 because we are checking a strict <, not <=\n            // is lo is positive, we need to check the hi is less than phi with the borrow flag subtracted\n            // if lo is negative, we have to check that hi * 2^128 < phi * 2^128 + abs_lo + plo\n            // to do this we first make a flag to check that abs_lo + plo is larger than 2^128 or not\n            // if they are larger, we check that hi < phi + 1 and otherwise we check that hi < phi\n            // Safety: we assert the when the flag is positive we have less than 128 bits\n            let threshold_flag: bool = unsafe { get_borrow_flag(abs_lo + PLO, TWO_POW_128) };\n            (threshold_flag as Field * (abs_lo + PLO)).assert_max_bit_size::<128>();\n            let rhi = is_positive as Field * (PHI - hi - borrow)\n                + (1 - is_positive as Field) * (PHI - hi + threshold_flag as Field);\n            // the rlo value would have 128 bits or less if positive and more if negative as the modulus is 254 bits\n            rlo.assert_max_bit_size::<128>();\n            rhi.assert_max_bit_size::<128>();\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n\n#[test]\nunconstrained fn test_wnaf() {\n    let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n    let (t0, t1) = get_wnaf_slices::<64>(result);\n    let expected = from_wnaf_slices(t0, t1);\n    assert_eq(result, expected);\n}\n\n#[test]\nfn test_regression_wnaf() {\n    let a = 0x7b;\n    let s: ScalarField<64> = ScalarField::<64>::from(a);\n    let b: Field = ScalarField::<64>::into(s);\n    assert_eq(a, b);\n}\n\n#[test]\nunconstrained fn to_le_radix_16_works_with_odd_N() {\n    let input = 0x0f00;\n    let nibbles: [u8; 3] = to_le_radix_16(input);\n    assert_eq(nibbles, [0x0, 0x0, 0xf]);\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/scalar_field.nr"
    },
    "113": {
      "source": "use dep::bignum;\nuse dep::bignum::BigNum;\nuse dep::bignum::fields::U256::U256;\nuse dep::bignum::fields::U512::U512;\nuse edwards::bjj::{BabyJubJub, BabyJubJubParams};\nuse edwards::Curve;\nuse edwards::CurveTrait;\nuse edwards::ScalarField;\nuse std::field::bn254::assert_lt;\nuse std::{hash::blake2s, ops::Mul};\n\n// Generator point of Baby Jubjub curve.\n// ref: https://github.com/noir-lang/noir-edwards/blob/main/src/test.nr#L6C8-L6C13\nglobal BASE8: [Field; 2] = [\n    5299619240641551281634865583518297030282874472190772894086521144482721001553,\n    16950150798460657717958625567821834550301663161624707787222815936182638968203,\n];\n\nglobal generator: Curve<BabyJubJubParams> = BabyJubJub::from((BASE8[0], BASE8[1]));\n\n// Baby Jubjub curve order [251 bit value]\npub global BABY_JUBJUB_ORDER: Field =\n    2736030358979909402780800718157159386076813972158567259200215660948447373041;\npub global BABY_JUBJUB_ORDER_PLUS_ONE: Field = BABY_JUBJUB_ORDER + 1;\n\n/// Creates a Baby Jubjub point from a scalar, specifically a Baby Jubjub public key from a secret scalar.\npub fn field_scalar_to_point(value: Field) -> edwards::Curve<BabyJubJubParams> {\n    // Ensure 0 < value <= l.\n    assert(value != 0);\n    assert_lt(value, BABY_JUBJUB_ORDER_PLUS_ONE);\n\n    // ScalarField is parameterised by the number of 4-bit slices it contains.\n    // Since value is already known to be max 251 bits, there are 63 slices.\n    let value_scalar: ScalarField<63> = ScalarField::from(value);\n    let point = generator.mul(value_scalar);\n\n    point\n}\n\n/// Encrypts a field to a Baby Jubjub public key using ECDH encryption.\npub fn VerifyEncryptMessage_ECDH(\n    message: Field,\n    r: Field,\n    pubkey: edwards::Curve<BabyJubJubParams>,\n) -> (edwards::Curve<BabyJubJubParams>, Field) {\n    // Ensure 0 < message <= l.\n    assert(message != 0);\n    assert_lt(message, BABY_JUBJUB_ORDER_PLUS_ONE);\n    // Ensure 0 < r <= l.\n    assert(r != 0);\n    assert_lt(r, BABY_JUBJUB_ORDER_PLUS_ONE);\n\n    // R = r * G (G is the generator)\n    let R: Curve<BabyJubJubParams> = field_scalar_to_point(r);\n\n    // Convert the randomness to Scalar\n    // ScalarField is parameterised by the number of 4-bit slices it contains.\n    // Since r is already known to be max 251 bits, there are 63 slices.\n    let r_scalar: ScalarField<63> = ScalarField::from(r);\n\n    // Shared secret = H(r * pubkey)\n    let rP = pubkey.mul(r_scalar);\n    let rP_x: [u8; 32] = rP.x.to_be_bytes();\n    let rP_y: [u8; 32] = rP.y.to_be_bytes();\n    let pre_image_slice: [u8] = rP_x.as_slice().append(rP_y);\n    let pre_image_array: [u8; 64] = pre_image_slice.as_array();\n    let hash_bytes: [u8; 32] = blake2s(pre_image_array);\n    let hash_bytes_slice: [u8] = hash_bytes.as_slice();\n    // U256 from_be_bytes expects 32 bytes + 1 byte for potential overflow\n    // We add a leading 0u8 since our data won't use the full 256-bit range and is ignored in the modulo\n    let hash_bytes_33: [u8] = &[0].append(hash_bytes_slice);\n    let hash_bignum: U256 = U256::from_be_bytes(hash_bytes_33.as_array());\n\n    //Clamp to Baby Jubjub order\n    let l_bignum: U256 = U256::from(BABY_JUBJUB_ORDER);\n\n    let shared_secret_bignum: U256 = hash_bignum.umod(l_bignum);\n\n    let message_bignum: U256 = U256::from(message);\n    let cipher_bignum_over = shared_secret_bignum + message_bignum;\n    let cipher_bignum: U256 = cipher_bignum_over.umod(l_bignum);\n    let mut cipher: Field = bignum::bignum::to_field(cipher_bignum);\n    if cipher == 0 {\n        cipher = BABY_JUBJUB_ORDER;\n    }\n\n    (R, cipher)\n}\n\n/// Verify T_i [given previous VerifyCOF() and original VerifyWitness0()]\npub fn VerifyTi(T_i: edwards::Curve<BabyJubJubParams>, witness_i: Field) {\n    //Produce statement point\n    let public_key: Curve<BabyJubJubParams> = field_scalar_to_point(witness_i);\n    assert_eq(public_key, T_i);\n}\n\n// Ed25519 curve order  [>252 bit value]\nglobal ED25519_ORDER: Field =\n    7237005577332262213973186563042994240857116359379907606001950938285454250989;\n\npub fn VerifyEquivalentModulo(\n    challenge_bytes: [u8; 32],\n    blinding_DLEQ: Field,\n    witness_i: Field,\n    response_div_BabyJubJub: [u8; 32],\n    response_BabyJubJub: Field,\n    response_div_ed25519: [u8; 32],\n    response_ed25519: [u8; 32],\n) {\n    let challenge_bytes_slice: [u8] = challenge_bytes.as_slice();\n\n    // U512 from_be_bytes expects 64 bytes + 1 byte for potential overflow\n    let challenge_bytes_65: [u8] = &[0; 33].append(challenge_bytes_slice);\n    let challenge_U512: U512 = U512::from_be_bytes(challenge_bytes_65.as_array());\n\n    //response = (challenge * secret) - blinding;\n    let secret: U512 = U512::from(witness_i);\n    let challenge_secret_calc: U512 = challenge_U512.mul(secret);\n\n    let response_calc: U512 = challenge_secret_calc - U512::from(blinding_DLEQ);\n\n    //Baby Jubjub order [251 bit value]\n    let l_bignum: U512 = U512::from(BABY_JUBJUB_ORDER);\n\n    // U512 from_be_bytes expects 64 bytes + 1 byte for potential overflow\n    let response_div_BabyJubJub_bytes_65: [u8] =\n        &[0; 33].append(response_div_BabyJubJub.as_slice());\n    let response_div_BabyJubJub_bignum: U512 =\n        U512::from_be_bytes(response_div_BabyJubJub_bytes_65.as_array());\n\n    let response_BabyJubJub_bignum: U512 = U512::from(response_BabyJubJub);\n    let response_calc_BabyJubJub =\n        l_bignum.mul(response_div_BabyJubJub_bignum) + response_BabyJubJub_bignum;\n    assert_eq(response_calc_BabyJubJub, response_calc);\n\n    //Ed25519 order [>252 bit value]\n    let ed25519_order_bignum: U512 = U512::from(ED25519_ORDER);\n\n    // U512 from_be_bytes expects 64 bytes + 1 byte for potential overflow\n    let response_div_ed25519_bytes_65: [u8] = &[0; 33].append(response_div_ed25519.as_slice());\n    let response_div_ed25519_bignum: U512 =\n        U512::from_be_bytes(response_div_ed25519_bytes_65.as_array());\n\n    // U512 from_be_bytes expects 64 bytes + 1 byte for potential overflow\n    let response_ed25519_bytes_65: [u8] = &[0; 33].append(response_ed25519.as_slice());\n    let response_ed25519_bignum: U512 = U512::from_be_bytes(response_ed25519_bytes_65.as_array());\n\n    let response_calc_ed25519 =\n        ed25519_order_bignum.mul(response_div_ed25519_bignum) + response_ed25519_bignum;\n    assert_eq(response_calc_ed25519, response_calc);\n}\n",
      "path": "/home/code/projects/grease/circuits/library/src/lib.nr"
    }
  },
  "expression_width": {
    "Bounded": {
      "width": 4
    }
  }
}