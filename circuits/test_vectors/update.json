{
  "noir_version": "1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663",
  "hash": "5666875631140214439",
  "abi": {
    "parameters": [
      {
        "name": "T_im1",
        "type": {
          "kind": "struct",
          "path": "edwards::Curve",
          "fields": [
            {
              "name": "x",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "y",
              "type": {
                "kind": "field"
              }
            }
          ]
        },
        "visibility": "public"
      },
      {
        "name": "T_i",
        "type": {
          "kind": "struct",
          "path": "edwards::Curve",
          "fields": [
            {
              "name": "x",
              "type": {
                "kind": "field"
              }
            },
            {
              "name": "y",
              "type": {
                "kind": "field"
              }
            }
          ]
        },
        "visibility": "public"
      },
      {
        "name": "witness_im1",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "witness_i",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "challenge_bytes",
        "type": {
          "kind": "array",
          "length": 32,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "public"
      },
      {
        "name": "blinding_DLEQ",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "response_div_BabyJubJub",
        "type": {
          "kind": "array",
          "length": 32,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "response_BabyJubJub",
        "type": {
          "kind": "field"
        },
        "visibility": "private"
      },
      {
        "name": "response_div_ed25519",
        "type": {
          "kind": "array",
          "length": 32,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      },
      {
        "name": "response_ed25519",
        "type": {
          "kind": "array",
          "length": 32,
          "type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 8
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {
      "361444214588792908": {
        "error_kind": "string",
        "string": "attempt to multiply with overflow"
      },
      "1998584279744703196": {
        "error_kind": "string",
        "string": "attempt to subtract with overflow"
      },
      "3301098964710512891": {
        "error_kind": "fmtstring",
        "length": 56,
        "item_types": []
      },
      "9125450380484214683": {
        "error_kind": "string",
        "string": "validate_gt fail"
      },
      "11084314168516775404": {
        "error_kind": "string",
        "string": "assert_is_not_zero_integer fail"
      },
      "12469291177396340830": {
        "error_kind": "string",
        "string": "call to assert_max_bit_size"
      },
      "14990209321349310352": {
        "error_kind": "string",
        "string": "attempt to add with overflow"
      },
      "15764276373176857197": {
        "error_kind": "string",
        "string": "Stack too deep"
      },
      "15835548349546956319": {
        "error_kind": "string",
        "string": "Field failed to decompose into specified 32 limbs"
      },
      "16431471497789672479": {
        "error_kind": "string",
        "string": "Index out of bounds"
      }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "5": {
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n",
      "path": "std/cmp.nr"
    },
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "39": {
      "source": "use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_add(y as u8) as i8\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_add(y as u16) as i16\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_add(y as u32) as i32\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_add(y as u64) as i64\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_sub(y as u8) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_sub(y as u16) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_sub(y as u32) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_sub(y as u64) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_mul(y as u8) as i8\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_mul(y as u16) as i16\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_mul(y as u32) as i32\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_mul(y as u64) as i64\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        crate::static_assert(1 == 2, \"custom message\");\n    }\n\n    mod arithmetic {\n        use crate::ops::arith::{Add, Div, Mul, Neg, Rem, Sub};\n        #[test]\n        fn test_basic_arithmetic_traits() {\n            // add\n            assert_eq(5.add(3), 8);\n            assert_eq(0u8.add(255u8), 255u8);\n            assert_eq(42.add(58), 100);\n\n            // sub\n            assert_eq(10.sub(3), 7);\n            assert_eq(100.sub(42), 58);\n\n            // mul\n            assert_eq(6.mul(7), 42);\n\n            // div\n            assert_eq(15.div(3), 5);\n            assert_eq(10u8.div(3u8), 3u8);\n            assert_eq(15.div(3), 5);\n\n            // rem\n            assert_eq(17.rem(5), 2);\n            assert_eq(10u8.rem(3u8), 1u8);\n\n            // neg\n            assert_eq(42.neg(), -42);\n            assert_eq((-10).neg(), 10);\n            assert_eq(42.neg(), -42);\n        }\n\n        #[test]\n        fn test_division() {\n            // test division by one\n            assert_eq(42.div(1), 42);\n            assert_eq(0.div(1), 0);\n            assert_eq(255u8.div(1u8), 255u8);\n\n            // test division by self\n            assert_eq(42.div(42), 1);\n            assert_eq(1.div(1), 1);\n\n            // test remainder\n            assert_eq(42.rem(42), 0);\n            assert_eq(0.rem(42), 0);\n            assert_eq(1.rem(42), 1);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_sub_overflow_failure() {\n            let _ = 0u8.sub(1u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_add_overflow_failure() {\n            let _ = 255u8.add(1u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_mul_overflow_failure() {\n            let _ = 255u8.mul(2u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_sub_overflow_failure() {\n            let _ = 0u16.sub(1u16);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_add_overflow_failure() {\n            let _ = 65535u16.add(1u16);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_mul_overflow_failure() {\n            let _ = 65535u16.mul(2u16);\n        }\n\n        #[test(should_fail)]\n        fn test_signed_sub_overflow_failure() {\n            let val: i8 = -128;\n            let _ = val.sub(1i8);\n        }\n\n        #[test(should_fail)]\n        fn test_signed_overflow_failure() {\n            let _ = 127i8.add(1i8);\n        }\n\n        #[test]\n        fn test_field() {\n            let zero: Field = 0;\n            let one: Field = 1;\n\n            // test Field basic operations\n            assert_eq(zero.add(one), one);\n            assert_eq(one.add(zero), one);\n            assert_eq(one.sub(one), zero);\n            assert_eq(one.mul(one), one);\n            assert_eq(one.div(one), one);\n            assert_eq(zero.neg(), zero);\n            assert_eq(one.neg(), -one);\n        }\n\n    }\n\n    mod wrapping_arithmetic {\n        use crate::ops::arith::{Add, Div, Mul, Neg, Sub, WrappingAdd, WrappingMul, WrappingSub};\n        #[test]\n        fn test_wrapping_add() {\n            assert_eq(255u8.wrapping_add(1u8), 0u8);\n            assert_eq(255u8.wrapping_add(255u8), 254u8);\n            assert_eq(0u8.wrapping_add(0u8), 0u8);\n            assert_eq(128u8.wrapping_add(128u8), 0u8);\n\n            // test u16 wrapping add\n            assert_eq(65535u16.wrapping_add(1u16), 0u16);\n            assert_eq(65535u16.wrapping_add(65535u16), 65534u16);\n\n            // test u32 wrapping add\n            assert_eq(0xffffffffu32.wrapping_add(1u32), 0u32);\n            assert_eq(0xffffffffu32.wrapping_add(0xffffffffu32), 0xfffffffeu32);\n\n            // test u64 wrapping add\n            assert_eq(0xffffffffffffffffu64.wrapping_add(1u64), 0u64);\n            assert_eq(\n                0xffffffffffffffffu64.wrapping_add(0xffffffffffffffffu64),\n                0xfffffffffffffffeu64,\n            );\n\n            // test u128 wrapping add\n            assert_eq(0xffffffffffffffffffffffffffffffffu128.wrapping_add(1u128), 0u128);\n\n            // test signed types\n            assert_eq(127i8.wrapping_add(1i8), -128i8);\n            let val: i8 = -128;\n            assert_eq(val.wrapping_add(-1i8), 127i8);\n\n            // test Field wrapping add\n            let forty_two: Field = 42;\n            let fifty_eight: Field = 58;\n            let hundred: Field = 100;\n            let neg_two: Field = -2;\n            let two: Field = 2;\n            let zero: Field = 0;\n            let neg_two_hundred: Field = -200;\n            let neg_one_ninety_eight: Field = -198;\n            assert_eq(forty_two.wrapping_add(fifty_eight), hundred);\n            assert_eq(neg_two.wrapping_add(two), zero);\n            assert_eq(neg_two_hundred.wrapping_add(two), neg_one_ninety_eight);\n        }\n\n        #[test]\n        fn test_wrapping_sub() {\n            assert_eq(0u8.wrapping_sub(1u8), 255u8);\n            assert_eq(255u8.wrapping_sub(255u8), 0u8);\n            assert_eq(0u8.wrapping_sub(0u8), 0u8);\n            assert_eq(1u8.wrapping_sub(2u8), 255u8);\n\n            // test u16 wrapping sub\n            assert_eq(0u16.wrapping_sub(1u16), 65535u16);\n            assert_eq(65535u16.wrapping_sub(65535u16), 0u16);\n\n            // test u32 wrapping sub\n            assert_eq(0u32.wrapping_sub(1u32), 0xffffffffu32);\n            assert_eq(0xffffffffu32.wrapping_sub(0xffffffffu32), 0u32);\n\n            // test u64 wrapping sub\n            assert_eq(0u64.wrapping_sub(1u64), 0xffffffffffffffffu64);\n            assert_eq(0xffffffffffffffffu64.wrapping_sub(0xffffffffffffffffu64), 0u64);\n\n            // test u128 wrapping sub\n            assert_eq(0u128.wrapping_sub(1u128), 0xffffffffffffffffffffffffffffffffu128);\n\n            // test signed types\n            let val: i8 = -128;\n            assert_eq(val.wrapping_sub(1i8), 127i8);\n            assert_eq(127i8.wrapping_sub(-1i8), -128i8);\n\n            // test Field wrapping sub\n            let forty_two: Field = 42;\n            let fifty_eight: Field = 58;\n            let neg_sixteen: Field = -16;\n            assert_eq(forty_two.wrapping_sub(fifty_eight), neg_sixteen);\n        }\n\n        #[test]\n        fn test_wrapping_mul() {\n            let zero: u128 = 0;\n            let one: u128 = 1;\n            let two_pow_64: u128 = 0x10000000000000000;\n            let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n            assert_eq(zero, zero.wrapping_mul(one));\n            assert_eq(zero, one.wrapping_mul(zero));\n            assert_eq(one, one.wrapping_mul(one));\n            assert_eq(zero, zero.wrapping_mul(two_pow_64));\n            assert_eq(zero, two_pow_64.wrapping_mul(zero));\n            assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n            assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n            assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n            assert_eq(one, u128_max.wrapping_mul(u128_max));\n\n            // test u8 wrapping mul\n            assert_eq(255u8.wrapping_mul(2u8), 254u8);\n            assert_eq(255u8.wrapping_mul(255u8), 1u8);\n            assert_eq(128u8.wrapping_mul(2u8), 0u8);\n\n            // test u16 wrapping mul\n            assert_eq(65535u16.wrapping_mul(2u16), 65534u16);\n            assert_eq(65535u16.wrapping_mul(65535u16), 1u16);\n\n            // test u32 wrapping mul\n            assert_eq(0xffffffffu32.wrapping_mul(2u32), 0xfffffffeu32);\n            assert_eq(0xffffffffu32.wrapping_mul(0xffffffffu32), 1u32);\n\n            // test u64 wrapping mul\n            // 0xffffffffffffffffu64 is 2^64 - 1\n            assert_eq(0xffffffffffffffffu64.wrapping_mul(2u64), 0xfffffffffffffffeu64);\n            assert_eq(0xffffffffffffffffu64.wrapping_mul(0xffffffffffffffffu64), 1u64);\n\n            // test signed types\n            assert_eq(127i8.wrapping_mul(2i8), -2i8);\n            let val: i8 = -128;\n            assert_eq(val.wrapping_mul(-1i8), -128i8);\n\n            // test Field wrapping mul\n            let six: Field = 6;\n            let seven: Field = 7;\n            let forty_two: Field = 42;\n            let neg_two: Field = -2;\n            let two: Field = 2;\n            let neg_four: Field = -4;\n            assert_eq(six.wrapping_mul(seven), forty_two);\n            assert_eq(neg_two.wrapping_mul(two), neg_four);\n        }\n\n        #[test]\n        fn test_u1_behavior() {\n            // u1 wrapping add is XOR\n            assert_eq(0u1.wrapping_add(0u1), 0u1);\n            assert_eq(0u1.wrapping_add(1u1), 1u1);\n            assert_eq(1u1.wrapping_add(0u1), 1u1);\n            assert_eq(1u1.wrapping_add(1u1), 0u1);\n\n            // u1 wrapping sub is XOR\n            assert_eq(0u1.wrapping_sub(0u1), 0u1);\n            assert_eq(0u1.wrapping_sub(1u1), 1u1);\n            assert_eq(1u1.wrapping_sub(0u1), 1u1);\n            assert_eq(1u1.wrapping_sub(1u1), 0u1);\n\n            // u1 wrapping mul is AND\n            assert_eq(0u1.wrapping_mul(0u1), 0u1);\n            assert_eq(0u1.wrapping_mul(1u1), 0u1);\n            assert_eq(1u1.wrapping_mul(0u1), 0u1);\n            assert_eq(1u1.wrapping_mul(1u1), 1u1);\n        }\n\n        // test wrapping operations is the same as the regular operations\n        #[test]\n        fn test_wrapping_vs_regular() {\n            let u64_large = 0x123456789abcdef0u64;\n            let u128_large = 0x123456789abcdef0123456789abcdef0u128;\n\n            assert_eq(u64_large.wrapping_add(1u64), u64_large + 1u64);\n            assert_eq(u64_large.wrapping_sub(1u64), u64_large - 1u64);\n            assert_eq(u64_large.wrapping_mul(2u64), u64_large * 2u64);\n\n            assert_eq(u128_large.wrapping_add(1u128), u128_large + 1u128);\n            assert_eq(u128_large.wrapping_sub(1u128), u128_large - 1u128);\n            assert_eq(u128_large.wrapping_mul(2u128), u128_large * 2u128);\n        }\n\n        #[test]\n        fn test_field_wrapping_operations() {\n            let zero: Field = 0;\n            let one: Field = 1;\n            let large_val = 0xffffffffffffffff;\n\n            // test Field wrapping operations\n            assert_eq(zero.wrapping_add(one), one);\n            assert_eq(one.wrapping_add(large_val), one + large_val);\n            assert_eq(zero.wrapping_sub(one), -one);\n            assert_eq(one.wrapping_sub(large_val), one - large_val);\n            assert_eq(zero.wrapping_mul(one), zero);\n            assert_eq(one.wrapping_mul(large_val), large_val);\n\n            // test Field basic operations\n            assert_eq(zero.add(one), one);\n            assert_eq(one.add(zero), one);\n            assert_eq(one.sub(one), zero);\n            assert_eq(one.mul(one), one);\n            assert_eq(one.div(one), one);\n            assert_eq(zero.neg(), zero);\n            assert_eq(one.neg(), -one);\n        }\n\n    }\n\n    mod split_functions {\n\n        use crate::ops::arith::{split64, split_into_64_bit_limbs};\n\n        // test split64 and split_into_64_bit_limbs functions\n        #[test]\n        fn test_split_functions() {\n            let small_val = 0x123456789abcdefu128;\n            let large_val = 0x123456789abcdef0123456789abcdef0u128;\n            let max_val = 0xffffffffffffffffffffffffffffffffu128;\n\n            // test split64 (unconstrained)\n            // Safety: testing\n            unsafe {\n                let (lo, hi) = split64(small_val);\n                assert_eq(lo, 0x123456789abcdefu64);\n                assert_eq(hi, 0u64);\n\n                let (lo2, hi2) = split64(large_val);\n                assert_eq(lo2, 0x123456789abcdef0u64);\n                assert_eq(hi2, 0x123456789abcdef0u64);\n            }\n\n            // test split_into_64_bit_limbs (constrained)\n            let (lo3, hi3) = split_into_64_bit_limbs(small_val);\n            assert_eq(lo3, 0x123456789abcdefu64);\n            assert_eq(hi3, 0u64);\n\n            let (lo4, hi4) = split_into_64_bit_limbs(large_val);\n            assert_eq(lo4, 0x123456789abcdef0u64);\n            assert_eq(hi4, 0x123456789abcdef0u64);\n\n            let (lo5, hi5) = split_into_64_bit_limbs(max_val);\n            assert_eq(lo5, 0xffffffffffffffffu64);\n            assert_eq(hi5, 0xffffffffffffffffu64);\n        }\n    }\n}\n",
      "path": "std/ops/arith.nr"
    },
    "50": {
      "source": "use dep::bignum;\nuse dep::bignum::BigNum;\nuse dep::bignum::fields::U256::U256;\nuse edwards::bjj::BabyJubJubParams;\nuse std::hash::blake2s;\n\n// This is the constant for VCOF hashing\nglobal HASH_HEADER_CONSTANT: [u8; 32] = [0; 32]; //TODO: Create a domain-separation constant\n\n/// Verify COF [given VerifyWitness0() at initialization]\nfn VerifyCOF(\n    T_im1: edwards::Curve<BabyJubJubParams>,\n    T_i: edwards::Curve<BabyJubJubParams>,\n    witness_im1: Field,\n    witness_i: Field,\n) {\n    library::VerifyTi(T_im1, witness_im1);\n    library::VerifyTi(T_i, witness_i);\n\n    //Create hash (random oracle) from previous entropy\n    let constant_slice: [u8] = HASH_HEADER_CONSTANT.as_slice();\n    let witness_im1_array: [u8; 32] = witness_im1.to_be_bytes();\n    let pre_image_slice: [u8] = constant_slice.append(witness_im1_array);\n    let pre_image_array: [u8; 64] = pre_image_slice.as_array();\n    let hash_bytes: [u8; 32] = blake2s(pre_image_array);\n    let hash_bytes_slice: [u8] = hash_bytes.as_slice();\n    // U256 from_be_bytes expects 32 bytes + 1 byte for potential overflow\n    // We add a leading 0u8 since our data won't use the full 256-bit range and is ignored in the modulo\n    let hash_bytes_33: [u8] = &[0].append(hash_bytes_slice);\n    let hash_bignum: U256 = U256::from_be_bytes(hash_bytes_33.as_array());\n\n    //Clamp to Baby Jubjub order [251 bit value]\n    let l_bignum: U256 = U256::from(library::BABY_JUBJUB_ORDER);\n\n    let value_bignum = hash_bignum.umod(l_bignum);\n    let mut value_field: Field = bignum::bignum::to_field(value_bignum) as Field;\n    if value_field == 0 {\n        value_field = library::BABY_JUBJUB_ORDER;\n    }\n\n    assert_eq(value_field, witness_i);\n}\n\n/// Main function for update\nfn main(\n    T_im1: pub edwards::Curve<BabyJubJubParams>,\n    T_i: pub edwards::Curve<BabyJubJubParams>,\n    witness_im1: Field,\n    witness_i: Field,\n    challenge_bytes: pub [u8; 32],\n    blinding_DLEQ: Field,\n    response_div_BabyJubJub: [u8; 32],\n    response_BabyJubJub: Field,\n    response_div_ed25519: [u8; 32],\n    response_ed25519: [u8; 32],\n) {\n    VerifyCOF(T_im1, T_i, witness_im1, witness_i);\n\n    library::VerifyEquivalentModulo(\n        challenge_bytes,\n        blinding_DLEQ,\n        witness_i,\n        response_div_BabyJubJub,\n        response_BabyJubJub,\n        response_div_ed25519,\n        response_ed25519,\n    );\n}\n",
      "path": "/home/code/projects/grease/circuits/update/src/main.nr"
    },
    "53": {
      "source": "use crate::fns::constrained_ops::limbs_to_field;\nuse crate::params::BigNumParams;\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub trait BigNum: Neg + Add + Sub + Mul + Div + Eq {\n    let N: u32;\n    let MOD_BITS: u32;\n\n    fn params() -> BigNumParams<N, MOD_BITS>;\n    fn modulus_bits(_: Self) -> u32;\n    fn num_limbs(_: Self) -> u32;\n    fn modulus() -> Self;\n\n    fn new() -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn from_limbs(limbs: [u128; N]) -> Self;\n    fn get_limbs(self) -> [u128; N];\n    fn set_limb(self: &mut Self, idx: u32, value: u128);\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    fn from_be_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n    fn from_le_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n\n    fn get_limb(self: Self, idx: u32) -> u128 {\n        self.get_limbs()[idx]\n    }\n\n    unconstrained fn __eq(self: Self, other: Self) -> bool;\n\n    unconstrained fn __is_zero(self: Self) -> bool;\n\n    unconstrained fn __neg(self) -> Self;\n    unconstrained fn __add(self, other: Self) -> Self;\n    unconstrained fn __sub(self, other: Self) -> Self;\n    unconstrained fn __mul(self, other: Self) -> Self;\n    unconstrained fn __sqr(self) -> Self;\n    unconstrained fn __div(self, other: Self) -> Self;\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    unconstrained fn __invmod(self) -> Self;\n    unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n    unconstrained fn __sqrt(self) -> std::option::Option<Self>;\n\n    fn assert_is_not_equal(self: Self, other: Self);\n\n    fn validate_in_range(self);\n    fn validate_in_field(self);\n\n    fn sqr(self) -> Self;\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    fn udiv(self, divisor: Self) -> Self;\n    fn umod(self, divisor: Self) -> Self;\n\n    fn is_zero(self) -> bool;\n    fn is_zero_integer(self) -> bool;\n    fn assert_is_not_zero(self);\n    fn assert_is_not_zero_integer(self);\n}\n\n// we need macros that implement the BigNum, Default, From, Neg, Add, Sub, Mul, Div, Eq, Ord traits for each bignum type\npub comptime fn derive_bignum(\n    strukt: TypeDefinition,\n    N: u32,\n    MOD_BITS: u32,\n    params: Quoted,\n) -> Quoted {\n    let constrained_ops = quote { $crate::fns::constrained_ops };\n    let unconstrained_ops = quote { $crate::fns::unconstrained_ops };\n    let typ = strukt.as_type();\n    let serialization = quote { $crate::fns::serialization };\n    quote {\n\n        // implement BigNum for BigNum \n        impl $crate::BigNum for $typ {\n            let N: u32 = $N; \n            let MOD_BITS: u32 = $MOD_BITS;\n            \n            fn modulus_bits(_: Self) -> u32 {\n                $MOD_BITS\n            }\n            \n            fn num_limbs(_: Self) -> u32 {\n                $N\n            }\n\n            fn modulus() -> Self {\n                Self { limbs: Self::params().modulus }\n            }\n\n            fn new() -> Self {\n                Self {limbs: [0; $N]}\n            }\n\n            fn params() -> $crate::params::BigNumParams<$N, $MOD_BITS> {\n                $params\n            }\n\n            fn from_limbs(limbs: [u128; $N]) -> Self {\n                Self { limbs }\n            }\n\n            fn get_limbs(self: Self) -> [u128; $N] {\n                self.limbs\n            }\n\n            fn set_limb(self: &mut Self, idx: u32, value: u128) {\n                self.limbs[idx] = value;\n            }\n\n            fn zero() -> Self {\n                Self { limbs: [0; $N] }\n            }\n\n            fn one() -> Self {\n                let mut limbs = [0; $N];\n                limbs[0] = 1;\n                Self { limbs }\n            }\n\n            fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                $typ::from_limbs($constrained_ops::derive_from_seed::<_, $MOD_BITS, _>(params, seed))\n            }\n\n            unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                Self { limbs: $unconstrained_ops::__derive_from_seed::<_, $MOD_BITS, _>(params, seed) }\n            }\n\n            fn from_be_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_be_bytes::<_, $MOD_BITS>(x) }\n            }\n            \n            fn to_be_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_be_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            fn from_le_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_le_bytes::<_, $MOD_BITS>(x) }\n            }\n\n            fn to_le_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_le_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            unconstrained fn __eq(self: Self, other: Self) -> bool {\n                $crate::fns::unconstrained_ops::__eq(self.get_limbs(), other.get_limbs())\n            }\n\n            unconstrained fn __is_zero(self: Self) -> bool {\n                $crate::fns::unconstrained_ops::__is_zero(self.get_limbs())\n            }\n\n            unconstrained fn __neg(self: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__neg(params.modulus, self.get_limbs())}\n            }\n\n            unconstrained fn __add(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__add(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __sub(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__sub(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __mul(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__mul(params, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __sqr(self: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__sqr(params, self.get_limbs()) }\n            }\n\n            unconstrained fn __div(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__div(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            unconstrained fn __udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let (q, r) = $unconstrained_ops::__udiv_mod(self.get_limbs(), divisor.get_limbs());\n                (Self{limbs: q}, Self{limbs: r})\n            }\n\n            unconstrained fn __invmod(self: Self) -> Self {\n                let params = Self::params();\n                assert(params.has_multiplicative_inverse);\n                Self {limbs: $unconstrained_ops::__invmod(params, self.get_limbs())}\n            }\n\n            unconstrained fn __pow(self: Self, exponent: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__pow(params, self.get_limbs(), exponent.get_limbs())}\n            }\n\n            #[deprecated(\"use __sqrt\")]\n            unconstrained fn __tonelli_shanks_sqrt(self: Self) -> std::option::Option<Self> {\n                let params = Self::params();\n                let maybe_limbs = $unconstrained_ops::__sqrt(params, self.get_limbs());\n                maybe_limbs.map(|limbs| Self {limbs: limbs})\n            }\n\n            unconstrained fn __sqrt(self: Self) -> std::option::Option<Self> {\n                let params = Self::params();\n                let maybe_limbs = $unconstrained_ops::__sqrt(params, self.get_limbs());\n                maybe_limbs.map(|limbs| Self {limbs: limbs })\n            }\n\n            fn assert_is_not_equal(self: Self, other: Self) {\n                let params = Self::params();\n                $crate::fns::constrained_ops::assert_is_not_equal(\n                    params,\n                    self.get_limbs(),\n                    other.get_limbs(),\n                );\n            }\n\n            fn validate_in_field(self: Self) {\n                let params = Self::params();\n                $constrained_ops::validate_in_field::<_, $MOD_BITS>(params, self.get_limbs());\n            }\n\n            fn validate_in_range(self: Self) {\n                $constrained_ops::validate_in_range::<_, _, $MOD_BITS>(self.get_limbs());\n            }\n\n            fn sqr(self: Self) -> Self {\n                let params = Self::params();\n                Self { limbs: $constrained_ops::sqr::<$N, $MOD_BITS>(params, self.get_limbs()) }\n            }\n\n            fn udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let (q, r) = $constrained_ops::udiv_mod::<$N, $MOD_BITS>(self.get_limbs(), divisor.get_limbs());\n                (Self {limbs: q}, Self {limbs: r})\n            }\n\n            fn udiv(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::udiv::<$N, $MOD_BITS>(self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn umod(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::umod::<$N, $MOD_BITS>(self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn is_zero(self: Self) -> bool {\n                let params = Self::params();\n                $constrained_ops::is_zero::<$N, $MOD_BITS>(params, self.get_limbs())\n            }\n\n            fn is_zero_integer(self: Self) -> bool {\n                $constrained_ops::is_zero_integer(self.get_limbs())\n            }\n\n            fn assert_is_not_zero(self: Self) {\n                let params = Self::params();\n                $constrained_ops::assert_is_not_zero::<$N, $MOD_BITS>(params, self.get_limbs());\n            }\n\n            fn assert_is_not_zero_integer(self: Self) {\n                $constrained_ops::assert_is_not_zero_integer(self.get_limbs());\n            }\n        }\n\n        // implement Default for BigNum\n        impl Default for $typ {\n            fn default() -> Self {\n                $typ::from_limbs([0; $N])\n            }\n        }\n\n        impl std::convert::From<Field> for $typ {\n            fn from(input: Field) -> Self {\n                $typ { limbs: $constrained_ops::from_field::<$N, $MOD_BITS>($params, input) }\n            }\n        }\n\n        impl std::ops::Neg for $typ {\n            fn neg(self) -> Self {\n                $typ { limbs: $constrained_ops::neg::<$N, $MOD_BITS>($params, self.limbs) }\n            }\n        }\n\n        impl std::ops::Add for $typ {\n            fn add(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::add::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Sub for $typ {\n            fn sub(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::sub::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Mul for $typ {\n            fn mul(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::mul::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Div for $typ {\n            fn div(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::div::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::cmp::Eq for $typ {\n            fn eq(self, other: Self) -> bool {\n                $constrained_ops::eq::<$N, $MOD_BITS>($params, self.limbs, other.limbs)\n            }\n        }\n\n        impl std::cmp::Ord for $typ {\n            fn cmp(self, other: Self) -> std::cmp::Ordering {\n                $constrained_ops::cmp::<$N, $MOD_BITS>(self.limbs, other.limbs)\n            }\n        }\n\n    }\n}\n\npub fn conditional_select<T: BigNum>(lhs: T, rhs: T, predicate: bool) -> T {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub unconstrained fn compute_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (T, T) {\n    let params = T::params();\n    let (q_limbs, r_limbs) = crate::fns::expressions::__compute_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    );\n    (T::from_limbs(q_limbs), T::from_limbs(r_limbs))\n}\n\npub fn evaluate_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    let params = T::params();\n    crate::fns::expressions::evaluate_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    )\n}\n\npub unconstrained fn batch_invert<T: BigNum, let M: u32>(x: [T; M]) -> [T; M] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert(params, x.map(|bn: T| bn.get_limbs())).map(|limbs| {\n        T::from_limbs(limbs)\n    })\n}\n\npub unconstrained fn batch_invert_slice<T: BigNum>(x: [T]) -> [T] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert_slice(params, x.map(|bn: T| bn.get_limbs()))\n        .map(|limbs| T::from_limbs(limbs))\n}\n\npub fn to_field<T: BigNum>(bn: T) -> Field {\n    let params = T::params();\n    limbs_to_field(params, bn.get_limbs())\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/bignum.nr"
    },
    "85": {
      "source": "use crate::constants::{GRUMPKIN_MODULUS, TWO_POW_120, TWO_POW_240};\n\nuse crate::fns::{\n    expressions::{evaluate_quadratic_expression, validate_udiv_mod_expression},\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags,\n        __validate_gte_with_flags, __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sqr, __sub, __udiv_mod},\n};\n\nuse crate::params::BigNumParams;\n\nuse std::cmp::Ordering;\n\n/// Lift the limbs of a `BigNum` value onto the circuit `Field`\n///\n/// Descent the `BigNum` value back into the `Field` and\n///    - check that it's a proper `BigNum` value\n///    - validate the limbs sum up to a `Field` value\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: BigNumParams<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    validate_in_range::<u128, N, MOD_BITS>(limbs);\n    if N > 2 {\n        // validate that the `BigNum` is less than the Grumpkin modulus\n        let mut grumpkin_modulus: [u128; N] = [0; N];\n        grumpkin_modulus[0] = GRUMPKIN_MODULUS[0];\n        grumpkin_modulus[1] = GRUMPKIN_MODULUS[1];\n        grumpkin_modulus[2] = GRUMPKIN_MODULUS[2];\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n    }\n\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        (limbs[0] as Field) + (limbs[1] as Field) * (TWO_POW_120 as Field)\n    } else {\n        (limbs[0] as Field)\n            + (limbs[1] as Field) * (TWO_POW_120 as Field)\n            + (limbs[2] as Field) * TWO_POW_240\n    }\n}\n\n/// Construct a `BigNum` value from a native `Field`\n///\n/// Decomposes the `Field` value into 120-bit limbs\n/// then we have three cases:\n///     - MOD_BITS < 253 (grumpkin_mod_bits - 1): it is enough to call for `validate_in_field`, which is basically `val <= MOD`\n///     - MOD_BITS > 253: we need to verify that the obtained `BigNum` `val < GRUMPKIN_MODULUS`\n///     - MOD_BITS = 253: verify that `val < min(MOD, GRUMPKIN_MODULUS)`\n/// Next we verify that all the limbs are properly ranged\n/// and that the accumulated limbs are equal to the input `Field` value\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: BigNumParams<N, MOD_BITS>,\n    val: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(val) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            let mut grumpkin_modulus: [u128; N] = [0; N];\n            grumpkin_modulus[0] = GRUMPKIN_MODULUS[0];\n            grumpkin_modulus[1] = GRUMPKIN_MODULUS[1];\n            grumpkin_modulus[2] = GRUMPKIN_MODULUS[2];\n\n            if MOD_BITS > 253 {\n                // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n                // also for correct params N is always larger than 3 here\n                validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            } else {\n                // this is the tricky part, when MOD_BITS = 253, we have to compare the limbs of the modulus to the grumpkin modulus limbs\n                // any `BigNum` with 253 bits will have 3 limbs\n\n                // if MOD is less than grumpkin modulus, this will be true\n                let mut mod_lt_grumpkin: bool = false;\n                for i in 0..3 {\n                    if !mod_lt_grumpkin & (_params.modulus[2 - i] < grumpkin_modulus[2 - i]) {\n                        mod_lt_grumpkin = true;\n                    }\n                }\n                let min_modulus: [u128; N] = if mod_lt_grumpkin {\n                    _params.modulus\n                } else {\n                    grumpkin_modulus\n                };\n                validate_gt::<N, MOD_BITS>(min_modulus, result);\n            }\n        }\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        // validate the limbs sum up to the field value\n        let field_val: Field = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            (result[0] as Field) + (result[1] as Field) * (TWO_POW_120 as Field)\n        } else {\n            (result[0] as Field)\n                + (result[1] as Field) * (TWO_POW_120 as Field)\n                + (result[2] as Field) * TWO_POW_240\n        };\n        assert_eq(field_val, val);\n    }\n\n    result\n}\n\n/// Given an input seed, generate a pseudorandom `BigNum` value\n///\n/// This function *should* produce a uniformly randomly distributed value modulo `MOD`\n///\n///  First we take the seed and pack it's 31-byte chunks into `Field`s\n///  We use a hash function that can be modelled as a random oracle\n///  We hash the packed seed using Poseidon2 to produce `MOD_BITS * 2` bits of entropy\n///\n///  From these bits we construct 4(in case N = 2) or 3(N > 2) `BigNum` values:\n///  - We fill first `N - 1` limbs and leave the top limb empty\n///\n///  Then we accumulate the resulting BigNum values using:\n///  B = 2^{120 * (N - 1)}\n///  res = x3 + B * x2 + B^2 * x1 + B^3 * x0\n///\n/// ## Note\n/// This function will always produce an `x3` `BigNum`\n/// If `MOD = 2^{120 * (N - 1)}`\n/// It will use only `MOD_BITS - 1` bits of entropy\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    // Pack seed bytes into Fields.\n    // For the seed of length M, we construct a rolling_hash_field of size ceil(M / 31).\n    // i.e.  31 bytes per Field\n    // NOTE: the Fields produced are 248 bits in size\n    let mut rolling_hash_fields: [Field; (SeedBytes + 30) / 31] = [0; (SeedBytes + 30) / 31];\n    let mut seed_ptr: u32 = 0;\n    for i in 0..(SeedBytes + 30) / 31 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed: Field =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes + 30) / 31);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    // 120 bit limb has 15 bytes in it\n    // we buffer (N * 15) * 2 bytes for 2N limbs\n    let mut hash_buffer: [u8; N * 15 * 2] = [0; N * 15 * 2];\n\n    // We produce 32 bytes (254 bits) per hash iteration\n    // We take only 30 bytes, so we need ceil(N * 2 * 15 / 30) hashes to fill them up\n    for i in 0..N {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    let num_bits: u32 = MOD_BITS * 2;\n    let num_bytes: u32 = (num_bits + 7) / 8;\n\n    // Truncate the final byte that will be used in `BigNum` creation\n    let bits_in_last_byte: u8 = (num_bits as u8) % 8;\n    if bits_in_last_byte != 0 {\n        let last_byte_mask: u8 = ((1 as u8) << bits_in_last_byte) - 1;\n        hash_buffer[num_bytes - 1] &= last_byte_mask;\n    }\n\n    let num_bigfield_chunks: u32 = if N == 2 { 4 } else { 3 };\n    let mut byte_ptr: u32 = 0;\n\n    // We want to convert our hash_buffer into bigfield chunks, with each `BigNum` having at most N - 1 limbs filled\n    // We sample only N - 1 limbs mostly because we do not wont to deal with accidental overflows in the top limb\n    // In any case the security is preserved\n    //\n    // For all integer values N > 1, the number of chunks is either 4(for N = 2) or 3(for N > 2) (ceil(2*N / (N - 1)))\n    //\n    // To determine the exact number of chunks, we need the `!=` or `>` operator which is not available when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n\n        // Before the current limb, we filled out (N - 1) limbs, k times\n        // 15 bytes per limb\n        // resulting in total of 15 * k * (N - 1)\n        let mut num_filled_bytes: u32 = 15 * k * (N - 1);\n        if num_bytes > num_filled_bytes {\n            // Static assert for completeness\n            assert(num_filled_bytes == byte_ptr);\n\n            let mut num_remaining_bytes_to_sample: u32 = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs_to_sample: u32 = (num_remaining_bytes_to_sample + 14) / 15;\n\n            // Sample at most (N - 1) limbs from hash_buffer\n            let mut num_limbs_to_sample: u32 = if num_remaining_limbs_to_sample > (N - 1) {\n                N - 1\n            } else {\n                num_remaining_limbs_to_sample\n            };\n\n            for j in 0..num_limbs_to_sample {\n                let mut limb: Field = 0;\n                // Construct a 120 bit limb\n                for _ in 0..15 {\n                    if byte_ptr < num_bytes {\n                        let mut byte: u8 = hash_buffer[byte_ptr];\n                        limb *= 256;\n                        limb += byte as Field;\n                        byte_ptr += 1;\n                    }\n                }\n                // crucial for performance\n                limb.assert_max_bit_size::<120>();\n                // Accumulate limbs from top to bottom\n                bigfield_limbs[num_limbs_to_sample - 1 - j] = limb as u128;\n            }\n            // Accumulate `BigNum` values from top to bottom\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    // B = 2^{120 * (N - 1)}, we know it is \\leq `MOD`, since the top limb\n    // have to be at least one\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n\n    let mut result: [u128; N] = bigfield_chunks[0];\n\n    for i in 1..num_bigfield_chunks {\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_chunks[i]);\n    }\n\n    result\n}\n\n// ------------------------------ COMPARISON FUNCTIONS ------------------------------\n\n/// Validate lhs != rhs\n///\n/// We compare `A` and `B` via their encodings in the circuit `Field`\n///\n/// Under our range assumptions, equality in `Field` implies equality of the underlying\n/// `BigNum` values, hence equality (mod `MOD`)\n///\n/// In this library it is possible that A or B is a little bit greater than `MOD`\n/// So A == B (mod `MOD`) implies that A == B, A == B + MOD or A == B - MOD over the integers\n/// Hence we can compute everything (mod p) and constrain that\n/// (A - B) * (A - B + MOD) * (A - B - MOD) != 0 (mod p)\n///\n/// ## Soundness\n/// This method is *sound* for checking `A != B (mod MOD)`\n///\n/// If `A == B (mod MOD)`, then `A - B` is in `{0, +-MOD}` as an integer,\n/// so one of the factors `A-B`, `A-B+MOD`, `A-B-MOD` is zero in `Field`, and the product is zero\n/// Therefore, whenever the assertion `target != 0` holds, we must have `A != B (mod MOD)`\n/// under our range assumptions\n///\n/// ## Completeness\n/// In general, this method is not *complete*: if the admissible range of `A` and `B`\n/// is large enough relative to the circuit `Field` prime `p`, an honest prover with\n/// `A != B (mod MOD)` can still hit an alias where\n///     (A - B) * (A - B + MOD) * (A - B - MOD) == 0 (mod p),\n/// i.e.\n///     - A = B       (mod p), or\n///     - A = B + MOD (mod p), or\n///     - A = B - MOD (mod p).\n///\n/// For random `A, B` in such a wide range, the probability of this collision is\n/// roughly 3/p.\n///\n/// In case `MOD` < `p` this function becomes *complete*\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_p: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_p *= TWO_POW_120 as Field;\n\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_p += params.modulus[N - i - 1] as Field;\n    }\n\n    let diff: Field = l - r;\n    let target: Field = diff * (diff + modulus_mod_p) * (diff - modulus_mod_p);\n    assert(target != 0, \"assert_is_not_equal fail\");\n}\n\n/// Compute equality flag\n///\n/// A == B (mod MOD)\n/// We compute A - B and check whether it is `0` or `MOD`\n/// This is due to subtract constrains the diff value to be < 2^MOD_BITS, not < `MOD`\n///\n/// ## Soundness\n/// This function is conditionally *sound*. See `sub` for details\n///\n/// ## Completeness\n/// This function is *complete*. An honest prover will always be able to execute it.\n///\n/// ## TODO\n/// can do this more efficiently via witngen in unconstrained functions?\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff: [u128; N] = sub::<N, MOD_BITS>(params, lhs, rhs);\n    is_zero::<N, MOD_BITS>(params, diff)\n}\n\n/// Validate that `val` is not equal to zero when interpreted as an integer.\n///\n/// This enforces that at least one limb of `val` is non-zero.\n/// It does *not* check \"BigNum zero\" in the modular sense (e.g. it\n/// treats `MOD` as non-zero).\n///\n/// ## Assumptions\n/// * Each limb of `val` is range-constrained to be a 120-bit value:\n///   `0 <= val[i] < 2^120`.\n/// * For our concrete fields and limb counts we have `N * 2^120 < p`,\n///   so the sum of all limbs fits strictly inside the field modulus.\n///\n/// ## Completeness\n/// If `val` is non-zero as an integer, then at least one limb is non-zero,\n/// so the integer sum of the limbs satisfies `0 < limb_sum < p`. In this\n/// case `limb_sum != 0` in the `Field`, and the assertion passes.\n///\n/// ## Soundness\n/// If all limbs of `val` are zero, then `limb_sum` is zero as an integer\n/// and as a field element, so the assertion fails. A witness representing\n/// the zero integer can never satisfy this check.\n///\n/// ## Note\n/// This is slightly cheaper than doing `val != [0; N]`, as we avoid\n/// creating per-limb boolean equalities and chaining them with `and`s.\npub(crate) fn assert_is_not_zero_integer<let N: u32>(val: [u128; N]) {\n    let mut limb_sum: Field = 0;\n    for i in 0..N {\n        limb_sum += val[i] as Field;\n    }\n    assert(limb_sum != 0, \"assert_is_not_zero_integer fail\");\n}\n\n/// Check whether `val` is the zero `BigNum` in the integer sense.\n///\n/// This returns `true` iff all limbs of `val` are zero. It does *not*\n/// treat `MOD` as zero; for modular `BigNum` zero use `is_zero`.\n///\n/// See `assert_is_not_zero_integer` for the underlying assumptions.\n///\n/// ## Note\n/// This is slightly cheaper than testing `val == [0; N]`, as we avoid\n/// creating per-limb boolean equalities and chaining them with `and`s.\npub(crate) fn is_zero_integer<let N: u32>(val: [u128; N]) -> bool {\n    let mut limb_sum: Field = 0;\n    for i in 0..N {\n        limb_sum += val[i] as Field;\n    }\n    limb_sum == 0\n}\n\n/// Validate that a `BigNum` value is not zero modulo `MOD`.\n///\n/// Convenience wrapper around `assert_is_not_equal`.\npub(crate) fn assert_is_not_zero<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    assert_is_not_equal::<N, MOD_BITS>(params, val, [0; N]);\n}\n\n/// Check whether a `BigNum` value is zero modulo `MOD`.\n///\n/// This treats both the all-zero limb vector and `params.modulus` as\n/// representing zero. It assumes that all valid `BigNum` values are\n/// range-constrained so that no other representatives of `0 (mod MOD)`\n/// can appear.\n///\n/// ## Note\n/// This is cheaper than calling `eq(val, [0; N])`\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> bool {\n    is_zero_integer(val) | (val == params.modulus)\n}\n\n/// Validate a `BigNum` instance is correctly range constrained to contain no more than `MOD_BITS` bits\n///\n/// Constrain the `BigNum` instance to be < 2^MOD_BITS by:\n///     - Constraining each limb(0..N-2) to be 120-bit limb\n///     - Constraining the last limb to be `MOD_BITS - 120 * (N - 1)`\n///\n/// ## Note\n/// This can be a very expensive function, when the `TOP_LIMB_BITS` is uncommon\n///\n/// For example: BLS12_377Fr, with `TOP_LIMB_BITS`=13\n/// It creates a new 13-bit range table, which consists of roughly 3k variables\n/// And ~2k circuit gates\n///\n/// Compare this to BLS12_377Fq, with `TOP_LIMB_BITS`=17\n/// It is nicely decomposed into\n/// 14-bit range check and 3-bit range check - much much cheaper, since 14-bit range checks\n/// are already pretty common for 120-bit range checks\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/// Validate quotient produced from `evaluate_quadratic_expression` is well-formed\n///\n/// Because the inputs into `evaluate_quadratic_expression` may cause the quotient to extend beyond `Params::modulus_bits`.\n///           We allow the quotient to extend `6` bits beyond `Params::modulus_bits()`\n///           Why is this?\n///           several factors:    1. quotient * modulus , limbs cannot overflow `Field` boundary (254 bits)\n///                               2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n///                                  limbs cannot exceed `246` bits (246 magic number due to a higher number adding extra range check gates)\n///           because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be > 126 bits\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N - 1) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - (N - 1) * 120 + 6>();\n}\n\n/// Validate that `lhs - rhs` does not underflow i.e. that lhs > rhs over the integers\n///\n/// Compute `result = lhs - rhs` along with `borrow_flags`,\n/// then constrain `result` to be a valid `BigNum` value.\n///\n/// ## Completeness\n/// This function is complete and will work only if `lhs > rhs` over the integers.\n///\n/// ## Soundness\n/// This function is sound:\n///     result[0]     = lhs[0]     - rhs[0]     + bf[0] * 2^{120}             < 2^{120}\n///     result[i]     = lhs[i]     - rhs[i]     + bf[i] * 2^{120} - bf[i - 1] < 2^{120},  i = 1..N-2\n///     result[N - 1] = lhs[N - 1] - rhs[N - 1]                   - bf[N - 2] < 2^{TOP_LIMB_BITS}\n///     result != 0\n///\n/// If `lhs < rhs`, then some limb of `result` would have to borrow from a higher limb,\n/// which is impossible because the top limb cannot borrow\n/// Without the extra borrow, the resulting difference will be wrapped around the `Field` modulus\n/// And won't satisfy the range constraint, since all the limbs are < 2^120\n///\n/// ## Note\n/// `assert_is_not_zero_integer(result)` is crucial. Without it, we could always provide\n/// two identical inputs `x`, `x` and set `borrow_flags = [false; N]`,\n/// which would satisfy the limb constraints.\n///\n/// Also note that `underflow` is not properly constrained, so it just hangs there for\n/// completeness\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // Safety: compute borrow flags out-of-circuit\n    let (underflow, result, borrow_flags): (bool, [u128; N], [bool; N - 1]) =\n        unsafe { __validate_gte_with_flags(lhs, rhs) };\n\n    // Completeness: require that no underflow occurred\n    assert(!underflow, \"validate_gt fail\");\n\n    // Constrain the `result` to be a valid `BigNum` value\n    validate_in_range::<u128, N, MOD_BITS>(result);\n    // Constrain it to be strict inequality\n    assert_is_not_zero_integer(result);\n\n    // Constrain `result` and `borrow_flags` to match the expected arithmetic\n    check_gte_with_flags(lhs, rhs, result, borrow_flags);\n}\n\n/// Constraining function for the results of `__validate_gte_with_flags`,\n/// used by both `cmp` and `validate gt`\n///\n/// This function checks the relations between `lhs`, `rhs`, `result` adn `borrow_flags`:\n///     lhs[0]     - rhs[0]     - result[0]     + bf[0] * 2^{120}             = 0\n///     lhs[i]     - rhs[i]     - result[i]     + bf[i] * 2^{120} - bf[i - 1] = 0,  i = 1..N-2\n///     lhs[N - 1] - rhs[N - 1] - result[N - 1]                   - bf[N - 2] = 0\npub(crate) fn check_gte_with_flags<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N - 1],\n) {\n    let result_limb: Field = (lhs[0] as Field) - (rhs[0] as Field) - (result[0] as Field)\n        + (borrow_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb: Field = (lhs[i] as Field) - (rhs[i] as Field) - (result[i] as Field)\n            + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n            - (borrow_flags[i - 1] as Field);\n        assert(result_limb == 0);\n    }\n\n    let result_limb: Field = (lhs[N - 1] as Field)\n        - (rhs[N - 1] as Field)\n        - (result[N - 1] as Field)\n        - (borrow_flags[N - 2] as Field);\n    assert(result_limb == 0);\n}\n\n/// Validate that `val` <= `MOD`\n///\n/// Compute `result = MOD - val` along with `borrow_flags`,\n/// then constrain `result` to be a valid `BigNum` value.\n///\n/// Basically the same as `validate_gt` but we compute the result on the fly\n/// It is just a bit more optimized as we expect each `BigNum` value to be \\leq `MOD`\n///\n/// ## Note\n/// In contrast to `validate_gt`, we allow the value to be `MOD`\n/// Since it is consistent with the rest of the library\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    let modulus: [u128; N] = params.modulus;\n\n    // Safety: compute borrow flags out-of-circuit\n    let borrow_flags: [bool; (N - 1)] =\n        unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n\n    let mut p_minus_self: [Field; N] = [0; N];\n    p_minus_self[0] = (modulus[0] as Field) - (val[0] as Field)\n        + (borrow_flags[0] as Field) * (TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] = (modulus[i] as Field) - (val[i] as Field)\n            + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n            - (borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] =\n        (modulus[N - 1] as Field) - (val[N - 1] as Field) - (borrow_flags[N - 2] as Field);\n    validate_in_range::<Field, N, MOD_BITS>(p_minus_self);\n}\n\n/// Compare two `BigNum` values\n///\n/// Returns `lhs > rhs`\n///\n/// ## Note\n/// This is a strict value comparison over the integers,\n/// the values do not have to be reduced modulo `MOD`.\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    // Safety: we constrain:\n    //        - `result` and `borrow_flags` with `check_gte_with_flags`\n    //        - `borrow_flags` are also booleans\n    //        - `underflow` with the following swap and (bool)\n    let (underflow, result, borrow_flags): (bool, [u128; N], [bool; N - 1]) =\n        unsafe { __validate_gte_with_flags(lhs, rhs) };\n\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs): ([u128; N], [u128; N]) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    // Constrain the `result` to be a valid `BigNum` value\n    validate_in_range::<u128, N, MOD_BITS>(result);\n\n    // Constrain subtraction: result = lhs - rhs with borrow_flags\n    check_gte_with_flags(lhs, rhs, result, borrow_flags);\n\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// ------------------------------ ARITHMETIC FUNCTIONS ------------------------------\n\n/// Negate a `BigNum` value\n///\n/// Computes `result = MOD - val` using limb-wise subtraction with borrow flags,\n/// then constrains:\n///   - all `result` limbs to be a valid `BigNum` value, and\n///   - the subtraction relation with the borrow flags\n///\n/// ## Assumptions\n/// - `val` is a valid `BigNum` in the range `0 <= val <= MOD`.\n///\n/// ## Soundness\n/// This function constrains the following relations:\n///     result[0]     = MOD[0]     - val[0]     + bf[0] * 2^{120}             < 2^{120}\n///     result[i]     = MOD[i]     - val[i]     + bf[i] * 2^{120} - bf[i - 1] < 2^{120},  i = 1..N-2\n///     result[N - 1] = MOD[N - 1] - val[N - 1]                   - bf[N - 2] < 2^{TOP_LIMB_BITS}\n///\n/// If all `MOD` and `val` limbs are valid `BigNum` limbs, these constraints\n/// ensure that:\n///   - the borrow flags `bf[i]` form a valid limb-wise subtraction chain, and\n///   - no underflow can occur in the subtraction `MOD - val`.\n///\n/// ## Completeness\n/// This function is complete for inputs in the range `0 <= val <= MOD`.\n/// If a value `val > MOD` is passed in (while still `< 2^{MOD_BITS}`), the\n/// constraints above will fail, since there is no valid borrow chain making\n/// `MOD - val` a well-formed `BigNum`.\n///\n/// In practice, honest provers should not hit this case: all functions in this\n/// module are expected to return values `< MOD`.\n///\n/// ## Note\n/// This function returns `MOD` when `val` is zero.\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: no need to constrain in an unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // Safety: compute borrow flags out-of-circuit\n        let (result, borrow_flags): ([u128; N], [bool; N - 1]) =\n            unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        let result_limb: Field = (params.modulus[0] as Field)\n            - (val[0] as Field)\n            - (result[0] as Field)\n            + (borrow_flags[0] as Field) * (TWO_POW_120 as Field);\n        assert(result_limb == 0);\n\n        for i in 1..N - 1 {\n            let result_limb: Field = (params.modulus[i] as Field)\n                - (val[i] as Field)\n                - (result[i] as Field)\n                + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (borrow_flags[i - 1] as Field);\n            assert(result_limb == 0);\n        }\n\n        let result_limb: Field = (params.modulus[N - 1] as Field)\n            - (val[N - 1] as Field)\n            - (result[N - 1] as Field)\n            - (borrow_flags[N - 2] as Field);\n        assert(result_limb == 0);\n        result\n    }\n}\n\n/// Add two `BigNum` values\n///\n/// Computes `result = lhs + rhs` using limb-wise addition with carry flags,\n/// and an optional subtraction of `MOD` using borrow flags. The function then\n/// constrains:\n///   - all `result` limbs to be a valid `BigNum` value, and\n///   - the addition/subtraction relation with the carry/borrow flags and the\n///     `overflow_modulus` bit.\n///\n/// ## Assumptions\n/// - All limbs of `lhs`, `rhs` and `MOD` are valid `BigNum` limbs\n///   (120-bit for non-top limbs, `TOP_LIMB_BITS` for the top limb).\n/// - Semantically, we intend to use this only with `0 <= lhs, rhs < MOD`,\n///   even though the limb/range constraints allow values up to `< 2^{MOD_BITS}`.\n///\n/// ## Soundness (intended relation)\n/// This function constrains the following equations:\n///\n///     result[0]     = lhs[0]     + rhs[0]\n///                     - sub[0]\n///                     + bf[0] * 2^{120}\n///                     - cf[0]                                        < 2^{120}\n///\n///     result[i]     = lhs[i]     + rhs[i]\n///                     - sub[i]\n///                     + bf[i] * 2^{120}  - bf[i - 1]\n///                     - cf[i] * 2^{120}  + cf[i - 1]                 < 2^{120},\n///                     for i = 1..N-2\n///\n///     result[N - 1] = lhs[N - 1] + rhs[N - 1]\n///                     - sub[N - 1]\n///                     - bf[N - 2]\n///                     + cf[N - 2]                                   < 2^{TOP_LIMB_BITS}\n///\n/// where:\n///   - `bf[i]` are the borrow flags of the optional subtraction,\n///   - `cf[i]` are the carry flags of the addition, and\n///   - `sub` is either the zero vector or `MOD`, depending on the\n///     `overflow_modulus` flag:\n///         * `overflow_modulus = 0`  =>  `sub = 0`\n///         * `overflow_modulus = 1`  =>  `sub = MOD`\n///\n/// If `lhs`, `rhs` and `MOD` are valid `BigNum` limbs and the witness for\n/// `(bf, cf, overflow_modulus)` is the honest one produced by `__add_with_flags`,\n/// these constraints enforce:\n///   - a valid limb-wise carry chain for `lhs + rhs`, and\n///   - a valid limb-wise subtraction chain for either `lhs + rhs` or\n///     `lhs + rhs - MOD`, with no underflow in any limb.\n///\n/// Under these assumptions the constrained result equals:\n///\n///     result = lhs + rhs (mod MOD)\n///\n/// in the intended arithmetic.\n///\n/// ## Limitations / extra satisfying witnesses\n///\n/// The constraint system itself does **not** uniquely determine the carry/borrow\n/// flags nor the `overflow_modulus` bit:\n///\n/// - For each limb `i`, `bf[i]` and `cf[i]` only appear in the combination\n///   `bf[i] * 2^{120} - cf[i] * 2^{120}`. This means that both\n///\n///       (bf[i], cf[i]) = (0, 0)  and  (bf[i], cf[i]) = (1, 1)\n///\n///   give the same contribution to the equation. As a result, there are multiple\n///   valid flag assignments for the *same* `lhs`, `rhs`, `sub` and `result`.\n///\n/// - More importantly, if `lhs + rhs` is greater than `MOD` but still strictly\n///   less than `2^{MOD_BITS}`, there exist *spurious* witnesses where:\n///     * `overflow_modulus` is set inconsistently with the true arithmetic\n///       overflow, and\n///     * the `(bf, cf)` flags are adjusted accordingly,\n///\n///   such that all equations above still hold and all `result` limbs remain\n///   within range. In particular, when\n///\n///       lhs + rhs + MOD < 2^{MOD_BITS},\n///\n///   a malicious prover can \"hide\" an extra `MOD` inside the choice of\n///   `overflow_modulus`, `bf` and `cf`, so that the circuit is satisfied by a\n///   witness\n///\n/// Consequently, this function is only *conditionally* sound: we rely on the\n/// out-of-circuit implementation of `__add_with_flags` to provide the honest\n/// `(borrow_flags, carry_flags, overflow_modulus)` witness. Under that\n/// assumption, the constrained `result` matches `lhs + rhs (mod MOD)`.\n///\n/// ## Completeness\n///\n/// For inputs in the range `0 <= lhs, rhs < MOD` and honest flags from\n/// `__add_with_flags`, the constraints are complete: every valid `BigNum` sum\n/// `lhs + rhs (mod MOD)` admits a satisfying assignment.\n///\n/// Inputs with `lhs` or `rhs` in `[MOD, 2^{MOD_BITS})` are still representable\n/// as limb arrays and may admit satisfying witnesses, but then the operation\n/// no longer corresponds to a unique, well-defined addition in the field\n/// `Z / MOD Z`. Such uses are outside the intended semantics of this function.\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: no need to constrain in unconstrained runtime\n        unsafe {\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // Safety: compute borrow/carry flags out-of-circuit\n        let (result, carry_flags, borrow_flags, overflow_modulus): ([u128; N], [bool; N - 1], [bool; N - 1], bool) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        let mut subtrahend: [u128; N] = if overflow_modulus {\n            params.modulus\n        } else {\n            [0; N]\n        };\n\n        let result_limb: Field = (lhs[0] as Field) + (rhs[0] as Field)\n            - (result[0] as Field)\n            - (subtrahend[0] as Field)\n            + (borrow_flags[0] as Field) * (TWO_POW_120 as Field)\n            - (carry_flags[0] as Field) * (TWO_POW_120 as Field);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb: Field = (lhs[i] as Field) + (rhs[i] as Field)\n                - (result[i] as Field)\n                - (subtrahend[i] as Field)\n                - (borrow_flags[i - 1] as Field)\n                + (carry_flags[i - 1] as Field)\n                + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (carry_flags[i] as Field) * (TWO_POW_120 as Field);\n            assert(result_limb == 0);\n        }\n        let result_limb: Field = (lhs[N - 1] as Field) + (rhs[N - 1] as Field)\n            - (result[N - 1] as Field)\n            - (subtrahend[N - 1] as Field)\n            - (borrow_flags[N - 2] as Field)\n            + (carry_flags[N - 2] as Field);\n        assert(result_limb == 0);\n        result\n    }\n}\n\n/// Subtract two `BigNum` values\n///\n/// Computes `result = lhs - rhs` using limb-wise subtraction with borrow flags,\n/// and an optional addition of `MOD` using carry flags. The function then\n/// constrains:\n///   - all `result` limbs to be a valid `BigNum` value, and\n///   - the subtraction/addition relation with the carry/borrow flags and the\n///     `underflow_modulus` bit.\n///\n/// ## Assumptions\n/// - All limbs of `lhs`, `rhs` and `MOD` are valid `BigNum` limbs\n///   (120-bit for non-top limbs, `TOP_LIMB_BITS` for the top limb).\n/// - Semantically, we intend to use this only with `0 <= lhs, rhs < MOD`,\n///   even though the limb/range constraints allow values up to `< 2^{MOD_BITS}`.\n///\n/// ## Soundness (intended relation)\n/// This function constrains the following equations:\n///\n///     result[0]     = lhs[0]     - rhs[0]\n///                     + add[0]\n///                     + bf[0] * 2^{120}\n///                     - cf[0]                                        < 2^{120}\n///\n///     result[i]     = lhs[i]     - rhs[i]\n///                     + add[i]\n///                     + bf[i] * 2^{120}  - bf[i - 1]\n///                     - cf[i] * 2^{120}  + cf[i - 1]                 < 2^{120},\n///                     for i = 1..N-2\n///\n///     result[N - 1] = lhs[N - 1] - rhs[N - 1]\n///                     + add[N - 1]\n///                     - bf[N - 2]\n///                     + cf[N - 2]                                   < 2^{TOP_LIMB_BITS}\n///\n/// where:\n///   - `bf[i]` are the borrow flags of the subtraction,\n///   - `cf[i]` are the carry flags of the optional addition, and\n///   - `add` is either the zero vector or `MOD`, depending on the\n///     `underflow_modulus` flag:\n///         * `underflow_modulus = 0`  =>  `add = 0`\n///         * `underflow_modulus = 1`  =>  `add = MOD`\n///\n/// If `lhs`, `rhs` and `MOD` are valid `BigNum` limbs and the witness for\n/// `(bf, cf, underflow_modulus)` is the honest one produced by `__sub_with_flags`,\n/// these constraints enforce:\n///   - a valid limb-wise borrow chain for `lhs - rhs`, and\n///   - a valid limb-wise addition chain for either `lhs - rhs` or\n///     `lhs - rhs + MOD`, with no underflow in any limb.\n///\n/// Under these assumptions the constrained result equals:\n///\n///     result = lhs - rhs (mod MOD)\n///\n/// in the intended arithmetic.\n///\n/// ## Limitations / extra satisfying witnesses\n///\n/// The constraint system itself does **not** uniquely determine the carry/borrow\n/// flags nor the `underflow_modulus` bit:\n///\n/// - For each limb `i`, `bf[i]` and `cf[i]` only appear in the combination\n///   `bf[i] * 2^{120} - cf[i] * 2^{120}`. This means that both\n///\n///       (bf[i], cf[i]) = (0, 0)  and  (bf[i], cf[i]) = (1, 1)\n///\n///   give the same contribution to the equation. As a result, there are multiple\n///   valid flag assignments for the *same* `lhs`, `rhs`, `add` and `result`.\n///\n/// - More importantly, when `lhs < rhs`, the true field result is\n///\n///       lhs - rhs + MOD,\n///\n///   and as long as\n///\n///       lhs - rhs + MOD < 2^{MOD_BITS},\n///\n///   a malicious prover can:\n///     * set `underflow_modulus` inconsistently with the true underflow, and\n///     * adjust the `(bf, cf)` flags accordingly,\n///\n///   such that all equations above still hold and all `result` limbs remain\n///   within range. In other words, the circuit can be satisfied by a witness\n///   that does **not** correspond to the unique intended subtraction modulo\n///   `MOD` for some inputs with `lhs < rhs`.\n///\n/// Consequently, this function is only *conditionally* sound: we rely on the\n/// out-of-circuit implementation of `__sub_with_flags` to provide the honest\n/// `(borrow_flags, carry_flags, underflow_modulus)` witness. Under that\n/// assumption, the constrained `result` matches `lhs - rhs (mod MOD)`.\n///\n/// ## Completeness\n///\n/// For inputs in the range `0 <= lhs, rhs < MOD` and honest flags from\n/// `__sub_with_flags`, the constraints are complete: every valid `BigNum`\n/// difference `lhs - rhs (mod MOD)` admits a satisfying assignment.\n///\n/// Inputs with `lhs` or `rhs` in `[MOD, 2^{MOD_BITS})` are still representable\n/// as limb arrays and may admit satisfying witnesses, but then the operation\n/// no longer corresponds to a unique, well-defined subtraction in the field\n/// `Z / MOD Z`. Such uses are outside the intended semantics of this function.\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: no need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // Safety: we constrain carry, borrow, underflow and result immediately\n        let (result, carry_flags, borrow_flags, underflow_modulus): ([u128; N], [bool; N - 1], [bool; N - 1], bool) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        let mut addend: [u128; N] = if underflow_modulus {\n            params.modulus\n        } else {\n            [0; N]\n        };\n\n        let result_limb: Field = (lhs[0] as Field) - (rhs[0] as Field) - (result[0] as Field)\n            + (addend[0] as Field)\n            + (borrow_flags[0] as Field) * (TWO_POW_120 as Field)\n            - (carry_flags[0] as Field) * (TWO_POW_120 as Field);\n        assert(result_limb == 0);\n\n        for i in 1..N - 1 {\n            let result_limb: Field = (lhs[i] as Field) - (rhs[i] as Field) - (result[i] as Field)\n                + (addend[i] as Field)\n                + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (carry_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (borrow_flags[i - 1] as Field)\n                + (carry_flags[i - 1] as Field);\n            assert(result_limb == 0);\n        }\n        let result_limb: Field = (lhs[N - 1] as Field)\n            - (rhs[N - 1] as Field)\n            - (result[N - 1] as Field)\n            + (addend[N - 1] as Field)\n            - (borrow_flags[N - 2] as Field)\n            + (carry_flags[N - 2] as Field);\n        assert(result_limb == 0);\n        result\n    }\n}\n\n/// Compute the `BigNum` multiplication\n///\n/// Computes `result = lhs * rhs (mod MOD)` by:\n///   1. Computing `result` out of circuit via `__mul`.\n///   2. Constraining the quadratic relation `lhs * rhs - result = 0` with\n///      `evaluate_quadratic_expression`.\n///\n/// ## Soundness\n/// Soundness reduces to `evaluate_quadratic_expression` for the relation\n/// `lhs * rhs - result = 0`\n///\n/// ## Note\n/// When possible, prefer expressing your computation directly as a quadratic\n///   relation and calling `evaluate_quadratic_expression` instead of using `mul`\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    // Safety: we constrain the multiplication result immediately after\n    let result: [u128; N] = unsafe { __mul::<N, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        // lhs * rhs - result = 0\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n/// Compute the `BigNum` squaring\n///\n/// Computes `result = val * val (mod MOD)` by:\n///   1. Computing `result` out of circuit via `__sqr`.\n///   2. Constraining the quadratic relation `val * val - result = 0` with\n///      `evaluate_quadratic_expression`.\n///\n/// ## Soundness\n/// Soundness reduces to `evaluate_quadratic_expression` for the relation\n/// `val * val - result = 0`\n///\n/// ## Note\n/// When possible, prefer expressing your computation directly as a quadratic\n///   relation and calling `evaluate_quadratic_expression` instead of using `sqr`\npub(crate) fn sqr<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    // Safety: we constrain the multiplication result immediately after\n    let result: [u128; N] = unsafe { __sqr::<_, MOD_BITS>(params, val) };\n    if !std::runtime::is_unconstrained() {\n        // val * val - result = 0\n        evaluate_quadratic_expression(\n            params,\n            [[val]],\n            [[false]],\n            [[val]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n/// Compute the `BigNum` division\n///\n/// Computes `result = lhs * rhs^{-1} (mod MOD)` by:\n///   1. Computing `result` out of circuit via `__div`.\n///   2. Constraining the quadratic relation `result * rhs - lhs = 0` with\n///      `evaluate_quadratic_expression`.\n///   3. Enforcing `rhs != 0 (mod MOD)`.\n///\n/// ## Soundness\n/// Soundness reduces to `evaluate_quadratic_expression` for the relation\n/// `result * rhs - lhs = 0`, together with the non-zero check on `rhs` and the\n/// assumption that `MOD` has multiplicative inverses for all non-zero elements\n/// (`params.has_multiplicative_inverse = true`).\n///\n/// ## Note\n/// - This is **expensive** in witness time due to modular inversion.\n/// - When possible, prefer expressing your computation directly as a quadratic\n///   relation and calling `evaluate_quadratic_expression` instead of using `div`.\n/// - In the unconstrained runtime, the behavior of `__div` on zero divisors is\n///   not constrained by this function.\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    // Safety: We constrain the result of division immediately after\n    let result: [u128; N] = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        // result * rhs - lhs = 0\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n        assert_is_not_zero(params, rhs);\n    }\n    result\n}\n\n/// Compute the `BigNum` integer division with remainder\n///\n/// Computes `quotient = floor(numerator / divisor)` and\n/// `remainder = numerator % divisor` by:\n///   1. Computing `(quotient, remainder)` out of circuit via `__udiv_mod`.\n///   2. Constraining the quadratic relation\n///        quotient * divisor + remainder - numerator = 0\n///      with `validate_udiv_mod_expression`.\n///   3. Enforcing `remainder < divisor`.\n///\n/// ## Soundness\n/// Soundness reduces to `validate_udiv_mod_expression` for the relation\n///     quotient * divisor + remainder - numerator = 0,\n/// together with `remainder < divisor` check enforced via `validate_gt`.\n///\n/// Under these checks, any satisfying assignment corresponds to a valid\n/// integer division `numerator = quotient * divisor + remainder` with\n/// `0 <= remainder < divisor`\n///\n/// ## Note\n/// Enforcing `divisor != 0` is not necessary. `remainder < divisor`\n/// Already enforces this.\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    // Safety: We constrain the result of __udiv_mod immediately after\n    let (quotient, remainder): ([u128; N], [u128; N]) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // quotient * divisor + remainder - numerator = 0\n        validate_udiv_mod_expression::<N, MOD_BITS>(numerator, divisor, quotient, remainder);\n        // remainder < divisor\n        validate_gt::<N, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/// Compute the `BigNum` integer division\n///\n/// Returns `floor(numerator / divisor)`.\n/// All constraints and soundness details are handled inside `udiv_mod`.\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<N, MOD_BITS>(numerator, divisor).0\n}\n\n/// Compute the `BigNum` remainder\n///\n/// Returns `numerator % divisor`.\n/// All constraints and soundness details are handled inside `udiv_mod`.\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<N, MOD_BITS>(numerator, divisor).1\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/constrained_ops.nr"
    },
    "86": {
      "source": "use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\n\nuse crate::fns::constrained_ops::{validate_in_range, validate_quotient_in_range};\nuse crate::fns::unconstrained_helpers::__barrett_reduction;\nuse crate::fns::unconstrained_ops::__is_zero;\n\nuse crate::params::BigNumParams;\n\n// ------------------------------ UNCONSTRAINED EXPRESSIONS ------------------------------\n\n/// Compute the result of a linear combination of (possibly negative) `BigNum` values (unconstrained)\n///\n/// ## Note\n/// 1. `modulus2` is structured such that all limbs will be greater than `0`, even when subtracting.\n/// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n/// We know that, for a valid bignum element, the limbs in `x` will be < 2^{120}\n/// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n/// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\n///\n/// 2. Returns the `Field` values that are not normalized to be 120-bit\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    vals: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    let mut sum: [Field; N] = [0; N];\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field) - (vals[i][j] as Field);\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + (vals[i][j] as Field);\n            }\n        }\n    }\n    sum\n}\n\n/// Compute the limb products of a quadratic expression (unconstrained)\n///\n/// See `__compute_quadratic_expression_with_borrow_flags` for full description\n///\n/// ## Note\n/// Returns the `Field` values that are not normalized to be 120-bit\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += lhs[k][i] * rhs[k][j];\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/// Compute the borrow flags for a limb-wise subtraction `lhs - rhs` (unconstrained).\n///\n/// This helper operates on `N`-limb values where each limb is interpreted as a\n/// 120-bit chunk (base `B = 2^{120}`), but where intermediate limbs may exceed\n/// `2^{120}` due to sums of products.\n///\n/// Conceptually, we want to model the integer subtraction\n///\n///     lhs - rhs\n///\n/// as a base-`B` subtraction with borrows, without allowing any intermediate\n/// values to go negative in the circuit field. We achieve this by:\n///\n///   1. Working with widened 246-bit ranges per limb.\n///   2. Encoding a borrow from limb `i+1` into limb `i` by:\n///        - adding `2^{246}` into limb `i`,\n///        - subtracting `2^{126}` (= 2^{246 - 120}) from limb `i+1` after\n///          scaling by `2^{-120}`.\n///\n/// The returned `borrow_flags[i]` indicate whether the canonical integer\n/// subtraction would borrow from limb `i+1` into limb `i`. These flags are\n/// later re-applied in-circuit via `apply_borrow_flags`, and the resulting\n/// limbs are checked by `validate_expression_is_zero`.\nunconstrained fn __compute_borrow_flags<let N: u32>(\n    mut lhs_limbs: [Field; N],\n    rhs_limbs: [Field; N],\n) -> [bool; N - 1] {\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{126} = 2^{246 - 120}\n    let downshift_120: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    borrow_flags[0] = lhs_limbs[0].lt(rhs_limbs[0]);\n\n    // we have N - 1 borrow flags. The number of limbs is N\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits: Field =\n        (lhs_limbs[0] - rhs_limbs[0] + ((borrow_flags[0] as Field) * borrow_shift)) * downshift_120;\n\n    for i in 1..(N - 1) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        lhs_limbs[i] += hi_bits;\n\n        let subtrahend: Field = rhs_limbs[i] + (borrow_flags[i - 1] as Field) * borrow_carry;\n\n        // determine whether negative limb values are greater than positive limb values\n        borrow_flags[i] = lhs_limbs[i].lt(subtrahend);\n        let minuend: Field = lhs_limbs[i] + (borrow_flags[i] as Field) * borrow_shift;\n\n        hi_bits = (minuend - subtrahend) * downshift_120;\n    }\n    borrow_flags\n}\n\n/// Given a degree-2 `BigNum` expression that is equal to `0 mod MOD`, compute\n/// the quotient and the borrow flags (unconstrained).\n///\n/// The expression has the form:\n///\n///     sum_{k=0}^{NUM_PRODUCTS-1} (L_k * R_k) + sum_{i=0}^{ADD_N-1} A_i = quotient * MOD\n///\n/// where each `L_k`, `R_k`, `A_i` is an `N`-limb `BigNum` assembled from the\n/// `(terms, flags)` arrays.\n///\n/// This helper:\n///   1. Evaluates the quadratic expression into `mulout_p` as a `2N`-limb\n///      non-normalized value.\n///   2. Normalizes `mulout_p` into 120-bit limbs and applies Barrett\n///      reduction to obtain `(quotient, remainder)`.\n///   3. Asserts that the integer remainder is zero (debugging aid; range\n///      checks enforce this later).\n///   4. Reconstructs `mulout_n = quotient * MOD`.\n///   5. Computes `borrow_flags` for the limb-wise subtraction\n///        `mulout_p - mulout_n`,\n///      using the 2^{246}/2^{126} encoding described in\n///      `evaluate_quadratic_expression`.\n///\n/// The returned `quotient` and `borrow_flags` are later constrained\n/// in-circuit by `compute_quadratic_expression_with_modulus` and\n/// `evaluate_quadratic_expression`.\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [bool; 2 * N - 2]) {\n    let mulout_p: [Field; 2 * N] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    // `__normalize_limbs` will validate that we do not overflow 2N, normally we should not overflow 2N-1\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p);\n    let (quotient, remainder): ([u128; N], [u128; N]) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n\n    // This is verified later by the range checks but left for debugging purposes\n    assert(__is_zero(remainder));\n\n    // We do not normalize `mulout_n` so we won't fill the `2 * N - 1`\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += (quotient[i] as Field) * (params.modulus[j] as Field);\n        }\n    }\n\n    let borrow_flags: [bool; 2 * N - 1] = __compute_borrow_flags(mulout_p, mulout_n);\n\n    // We have to copy it because we know that borrow_flags[2 * N - 1] is always 0\n    // But we also have to provide 2 * N limbs to `__barrett_reduction`.\n    // And keep `__compute_borrow_flags` generic enough\n    let mut borrow_flags_real: [bool; 2 * N - 2] = [false; 2 * N - 2];\n    for i in 0..2 * N - 2 {\n        borrow_flags_real[i] = borrow_flags[i];\n    }\n\n    (quotient, borrow_flags_real)\n}\n\n/// Computes the quotient/remainder of a quadratic expression (unconstrained)\n///\n/// See `__compute_quadratic_expression_with_borrow_flags` for full description\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    let mulout: [Field; 2 * N] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    // __normalize_limbs will validate that we do not overflow 2N, normally we should not overflow 2N-1\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout);\n\n    let (quotient, remainder): ([u128; N], [u128; N]) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n\n    (quotient, remainder)\n}\n\n// ------------------------------ CONSTRAINED EXPRESSIONS ------------------------------\n\n/// Constrained version of `__add_linear_expression`\n///\n/// Computes all the linear parts of an expression in-circuit\n///\n/// ## Note\n/// 1. Negative terms are implemented by adding `double_modulus`\n/// `double_modulus` is chosen so that all limbs except the top one\n/// are > 2^{120}, which prevents underflows in intermediate computations.\n///\n/// 2. For the most significant limb we slightly reduce the padding (to keep the\n/// overall value equal to `2 * MOD`), so in principle there is a narrow edge\n/// case where that limb could underflow if enough negative contributions are\n/// accumulated and the top limb of `MOD` is very small. In practice, the\n/// global `BigNum` range and operand-count assumptions in\n/// `evaluate_quadratic_expression` rule out such patterns.\nfn compute_linear_expressions<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([[Field; N]; NUM_PRODUCTS], [[Field; N]; NUM_PRODUCTS], [Field; N]) {\n    // lhs linear terms\n    let mut lhs_linear: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    // rhs linear terms\n    let mut rhs_linear: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    // linear terms\n    let mut lin_expr: [Field; N] = [0; N];\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // Note: if lhs_flags[k][j] - `is_negative` is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    lhs_linear[k][i] -= lhs_terms[k][j][i] as Field;\n                    lhs_linear[k][i] += params.double_modulus[i] as Field;\n                } else {\n                    lhs_linear[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                // Note: if rhs_flags[k][j] - `is_negative` is not known at comptime this is very expensive\n                if (rhs_flags[k][j]) {\n                    rhs_linear[k][i] -= rhs_terms[k][j][i] as Field;\n                    rhs_linear[k][i] += params.double_modulus[i] as Field;\n                } else {\n                    rhs_linear[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n\n    for i in 0..N {\n        for j in 0..ADD_N {\n            // Note: if linear_flags[j] - `is_negative` is not known at comptime this is very expensive\n            if (linear_flags[j]) {\n                lin_expr[i] -= linear_terms[j][i] as Field;\n                lin_expr[i] += params.double_modulus[i] as Field;\n            } else {\n                lin_expr[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    (lhs_linear, rhs_linear, lin_expr)\n}\n\n/// Constrained version of `__compute_quadratic_expression_product`\n///\n/// Computes the following expression in-circuit:\n///     \\sum (L_i * R_i) + \\sum (A_i) - QUOTIENT * MOD\n///\n/// Because of the subtraction of `QUOTIENT * MODULUS`, the resulting limbs may\n/// underflow and represent *negative* values. To account for this, we allow the\n/// prover to choose a sequence of borrow flags and interpret the limbs with\n/// additional terms:\n///\n///   - for each limb `i` we may add `2^{246}` (via a flag at position `i`);\n///   - for each limb `i` we may subtract `2^{126 = 246 - 120}` (via the flag\n///     at position `i - 1`).\n///\n/// This corresponds to borrowing `2^{126}` from limb `i + 1` and adding\n/// `2^{246}` into limb `i`. After this adjustment, an honest prover can ensure\n/// that every limb lies in `[0, 2^{246})` and that the adjusted limbs encode\n/// the correct integer value.\n///\n/// Additionally, we constrain the quotient limbs via `validate_quotient_in_range`:\n///   - limbs `0..N-2` of `quotient` are < 2^{120};\n///   - the top limb is < 2^{TOP_LIMB_BITS + 6}.\n/// Which validates `quotient < 2^{MOD_BITS + 6}`\n///\n/// ## TODO\n/// Apply static or runtime checks in this method to validate that the effective\n/// `twiddle_factor` does not exceed 6 under the chosen parameters.\nfn compute_quadratic_expression_with_modulus<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N - 1] {\n    // Safety: use an unconstrained function to compute the value of the quotient and borrow_flags out-of-circuit\n    let (quotient, borrow_flags): ([u128; N], [bool; 2 * N - 2]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<N, MOD_BITS, LHS_N, RHS_N, NUM_PRODUCTS, ADD_N>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // Constrain the `quotient < 2^{MOD_BITS + 6}`\n    // By constraining limbs(0..N-2) to be < 2^120 and the the top limb < 2^{TOP_LIMB_BITS + 6}\n    validate_quotient_in_range::<N, MOD_BITS>(quotient);\n\n    // Compute the linear sums that represent L_i, R_i, A\n    let (lhs_linear, rhs_linear, lin_expr): ([[Field; N]; NUM_PRODUCTS], [[Field; N]; NUM_PRODUCTS], [Field; N]) = compute_linear_expressions::<N, MOD_BITS, LHS_N, RHS_N, NUM_PRODUCTS, ADD_N>(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    // We want to evaluate that L * R + A - Quotient * MOD = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow\n    let mut expression_limbs: [Field; 2 * N - 1] = [0; 2 * N - 1];\n\n    // Compute the product t0 * t1 + t4 - Quotient * MOD\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term: Field = lhs_linear[k][i] * rhs_linear[k][j]\n                        - (quotient[i] as Field) * (params.modulus[j] as Field);\n                    // width-4 optimization\n                    std::as_witness(new_term);\n                    expression_limbs[i + j] += new_term;\n                } else {\n                    expression_limbs[i + j] += lhs_linear[k][i] * rhs_linear[k][j];\n                }\n            }\n            // This is the fallback for pure linear expression\n            if (NUM_PRODUCTS == 0) {\n                expression_limbs[i + j] -= (quotient[i] as Field) * (params.modulus[j] as Field);\n            }\n        }\n        expression_limbs[i] += lin_expr[i];\n    }\n\n    apply_borrow_flags(expression_limbs, borrow_flags)\n}\n\n/// Apply a precomputed borrow chain to a limb array.\n///\n/// Given:\n///\n///   - `expression_limbs`: an `N`-limb array of `Field` values representing a\n///     (possibly non-normalized) degree-2-style expression, and\n///   - `borrow_flags[i]` indicating that we \"borrow\" from limb `i+1` into limb `i`,\n///\n/// this function applies the same 2^{246}/2^{126} encoding used in\n/// `__compute_borrow_flags` to produce an adjusted limb array\n///\n/// This matches the behavior of `__compute_borrow_flags`, which conceptually:\n///\n///   1. Adds `2^{246}` into a limb when a borrow is taken at that limb;\n///   2. After scaling by `2^{-120}`, contributes `2^{126}` into the next limb.\n///\n/// The resulting `expression_limbs` can then be passed to\n/// `validate_expression_is_zero`, which:\n///\n///   - right-shifts by 120 bits per limb,\n///   - enforces a 126-bit bound,\n///   - and propagates carries forward, finally checking that the most\n///     significant limb is zero.\n///\n/// ## Assumptions\n///\n/// - `borrow_flags` was computed consistently with the original construction\n///   of `expression_limbs` (e.g. via `__compute_borrow_flags` on the\n///   corresponding unconstrained expression).\n/// - The caller has ensured that each adjusted limb remains < 2^{246} for\n///   honest witnesses (e.g. via `NUM_PRODUCTS < 64`).\n///\n/// ## Note\n///\n/// This function does not itself enforce any bit-size bounds; it only applies\n/// the borrow encoding. The actual range checks happen later in\n/// `validate_expression_is_zero`.\n///\n/// ## TODO\n/// define trade-offs regarding the value of borrow_shift\n/// (the larger the value, the greater the range check that is required on product_limbs)\n/// (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n/// (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\nfn apply_borrow_flags<let N: u32>(\n    mut expression_limbs: [Field; N],\n    borrow_flags: [bool; N - 1],\n) -> [Field; N] {\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n\n    // Get the product_limbs into the form where each entry is a 246-bit value\n    expression_limbs[0] += (borrow_flags[0] as Field) * borrow_shift;\n    for i in 1..(N - 1) {\n        expression_limbs[i] += (borrow_flags[i] as Field) * borrow_shift\n            - (borrow_flags[i - 1] as Field) * borrow_carry;\n    }\n    expression_limbs[N - 1] -= (borrow_flags[N - 2] as Field) * borrow_carry;\n    expression_limbs\n}\n\n/// Validate that `limbs` represent the integer value `0`\n///\n/// ## Assumptions\n///     - `limbs` is an array of `Field` values that was derived arithmetically as\n///        a degree-2 expression\n///     - each limb satisfies `limbs[i] < 2^{246}`, as ensured by\n///       `compute_quadratic_expression_with_modulus` under its parameter bounds.\n///\n/// ## Details\n/// Each element `i` in `limbs` overlaps in bit-range with element `i+1`, EXCEPT for the low 120 bits\n/// i.e. we need to do the following for each limb `i`:\n///      1. validate the limb's low-120 bits equals zero\n///      2. compute the limb \"carry\" by right-shifting by 2^{120}\n///      3. propagate the \"carry\" into limb `i+1`\n/// We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n///\n/// If the low 120 bits are nonzero, there is no value in `[0, 2^{126})` that\n/// could have produced this limb after multiplying by `2^{120}`. Since\n/// multiplication by `2^{120}` is a bijection on the Field, any limb with\n/// non-zero low 120 bits must map outside the `[0, 2^{126})` range after\n/// scaling by `2^{-120}`.\n///\n/// The most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n///\n/// ## Note\n/// The constant 126 is not arbitrary. We use 120-bit limbs and allow up to 64\n/// products per limb, which contributes at most `log2(64) = 6` bits of headroom.\n/// After scaling by `2^{-120}`, honest witnesses fit in 126 bits. We could in\n/// principle go higher (up to roughly `CircuitModulusBits - 121`), but 126 is\n/// the minimal bound consistent with `NUM_PRODUCTS < 64` and is significantly\n/// cheaper than larger bounds for the barretenberg backend.\nfn validate_expression_is_zero<let N: u32>(mut limbs: [Field; N]) {\n    let hi_shift: Field = TWO_POW_120 as Field;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N - 1 {\n        limbs[i] *= hi_downshift;\n        std::as_witness(limbs[i]);\n        limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        limbs[i + 1] += limbs[i];\n    }\n    assert(limbs[N - 1] == 0);\n}\n\n/// Constrain a degree-2 `BigNum` expression to be equal to 0 (mod `MOD`)\n///\n//\n/// This method is intended for relations where the remainder term of the\n/// degree-2 expression is exactly zero as an integer relation. In other words,\n/// we use it only when we expect:\n///\n///     \\sum (L_i * R_i) + \\sum (A_i) - QUOTIENT * MOD = 0\n///\n/// as integers, not just modulo the circuit field or `BigNum` field.\n///\n/// ## Details\n///\n/// The constrained expression, viewed over the integers, is:\n///\n///       \\sum_{i=0}^{NUM_PRODUCTS-1} (L_i * R_i)\n///     + \\sum_{i=0}^{ADD_N-1} (A_i)\n///     - QUOTIENT * MOD\n///     = 0\n///\n/// Each `L_i`, `R_i`, `A_i` is an `N`-limb `BigNum` assembled from the\n/// `(terms, flags)` arrays. For example, for `i = 0`:\n///\n///     L_0 = \\sum_{j=0}^{LHS_N-1} lhs[0][j]    as a `BigNum`\n///     R_0 = \\sum_{j=0}^{RHS_N-1} rhs[0][j]    as a `BigNum`\n///\n/// The intent is to capture a generic degree-2 expression within Noir's\n/// limitations (no efficient dynamically sized vectors).\n///\n/// The expensive parts of this algorithm are:\n///   1. evaluating the limb products required to compute the `L_i * R_i` values;\n///   2. applying range constraints to validate that the result encodes 0.\n///\n/// ## Note\n/// When the expression is evaluated over `N`-limb `BigNum` values, the product\n/// has up to `2N - 1` significant limbs. Each limb is a sum of at most\n/// `NUM_PRODUCTS` products of `linear` 120-bit limbs and `quadratic` 240-bit-ish limbs\n///\n/// Note that:\n///   * limb-wise multiplication is not uniform across indices. For example:\n///\n///       [x0, x1, x2] * [y0, y1, y2] =\n///       [\n///         x0*y0,                               // 1 term\n///         x0*y1 + x1*y0,                       // 2 terms\n///         x0*y2 + x1*y1 + x2*y0,               // 3 terms\n///         x1*y2 + x2*y1,                       // 2 terms\n///         x2*y2                                // 1 term\n///       ]\n///       The number of partial products per limb grows linearly from 1 to N,\n///       then decreases linearly back to 1.\n///\n///   * we also allow linear combinations inside the products, which further increases the bound\n///     on a `quadratic` limb\n///\n///   * finally, when `is_negative` flag is set, we effectively add 2 * MOD to each limb, where\n///     2 * MOD limbs are structured in such a way that they all are > 2**120\n///\n/// We allow `NUM_PRODUCTS < 64` completeness-wise, but it certainly can overflow the 2^{240 + `twiddle_factor=6`} bound\n/// in edge cases. See completeness section for an example.\n///\n/// ## Assumptions\n///\n/// Each `BigNum` value used in this gadget is already range constrained:\n///   - limbs `0..N-2` satisfy `limb_i < 2^{120}`\n///   - limb `N-1` satisfies `limb_{N-1} < 2^{TOP_LIMB_BITS}`\n///\n/// ## Completeness\n/// If an honest prover supplies inputs that satisfy the assumptions above,\n/// it can always find a `quotient` and `borrow_flags` such that the integer\n/// relation holds and all constraints are satisfied.\n///\n/// The only possibility to break completeness is by providing too many inputs, for example:\n///\n///     (a0 + a1 + a2) * (b0 + b1 + b2) + ... (60 times), with each a_i having its limbs at maximum value of 2^{120} - 1\n///     The middle limb will contain a value that will definitely overflow the 2^{246} bound.\n///\n/// ## Soundness\n/// This function is conditionally sound: it enforces that the degree-2 relation\n/// holds modulo `MOD`, but it does not, by itself, enforce that any particular\n/// term (for example a result `z`) is a *canonical* representative in\n/// `[0, MOD)`.\n///\n/// In other words, if the surrounding relation is invariant under adding a\n/// multiple of `MOD` to one of its terms, then a dishonest prover can exploit\n/// this. For example, consider a multiplication relation:\n///\n///     x * y - z = 0 (mod MOD)\n///\n/// Internally we encode this as:\n///\n///     x * y + 2 * MOD - z - quotient * MOD = 0\n///\n/// which is equivalent to:\n///\n///     x * y - z = (quotient - 2) * MOD\n///\n/// Suppose the honest witness uses some `z` satisfying\n/// `0 <= z < MOD` and some `quotient`. If the `BigNum` encoding allows\n/// `z' = z + MOD` (i.e. `z' < 2^{MOD_BITS}` still holds), then a dishonest\n/// prover can instead provide:\n///\n///     z' = z + MOD\n///     quotient' = quotient - 1\n///\n/// and still satisfy:\n///\n///     x * y + 2 * MOD - z' - quotient' * MOD = 0\n///\n/// even though `z'` is no longer the canonical representative of `x * y mod MOD`.\n///\n/// The same consideration applies to almost every constrained `BigNum` relation:\n/// whenever a value participates *only* through a modular equality, and no\n/// separate range constraint is imposed on that value, the prover is free to\n/// shift it by an extra `MOD` as long as the resulting limb\n/// encoding still satisfies its bit-bounds. This is inherent in working with\n/// modular constraints; the responsibility for enforcing canonical\n/// representatives lies with the caller when it is required.\n///\n/// This is the same \"extra modulus\" phenomenon as in the `add`/`sub` functions:\n/// the constraints are sound for modular arithmetic, but any caller that\n/// requires canonical outputs in `[0, MOD)` must additionally enforce a\n/// range check (for example via `validate_in_field`) on the relevant terms.\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    assert(NUM_PRODUCTS < 64, f\"evaluate_quadratic_expression overflow in operands count\");\n    // NUM_PRODUCTS < 64 is a light bound that tries to ensure each limb sum < 2^{246} so that the 126-bit bound is valid.\n\n    lhs_terms.for_each(|lhs_limbs: [[u128; N]; LHS_N]| {\n        lhs_limbs.for_each(|term: [u128; N]| validate_in_range::<u128, N, MOD_BITS>(term))\n    });\n    rhs_terms.for_each(|rhs_limbs: [[u128; N]; RHS_N]| {\n        rhs_limbs.for_each(|term: [u128; N]| validate_in_range::<u128, N, MOD_BITS>(term))\n    });\n    linear_terms.for_each(|term: [u128; N]| validate_in_range::<u128, N, MOD_BITS>(term));\n\n    let expression_limbs: [Field; 2 * N - 1] = compute_quadratic_expression_with_modulus::<N, MOD_BITS, LHS_N, RHS_N, NUM_PRODUCTS, ADD_N>(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    validate_expression_is_zero(expression_limbs);\n}\n\n// ------------------------------ UDIV MOD EXPRESSION ------------------------------\n\n/// Given a `udiv_mod` `BigNum` expression that is equal to `0` over integers, compute the borrow flags (unconstrained)\n///\n/// Mirror function of `__compute_quadratic_expression_with_borrow_flags` optimized to compute borrow flags of an expression:\n///     divisor * quotient + remainder - numerator = 0\n/// see `__compute_quadratic_expression_with_borrow_flags` for details\n///\n/// The main differences from it are:\n///     1. `product_limbs` stores only the least-significant `N` limbs of\n///         `quotient * divisor + remainder`. This is sufficient to compute the\n///         borrow flags for the first `N` limbs of\n///             quotient * divisor + remainder - numerator.\n///\n///         For an honest `udiv_mod` relation we also have\n///             quotient * divisor <= numerator < B^N,\n///         so the true product fits into `N` limbs as an integer.\n///     2. Instead of subtracting `quotient * MOD` we subtract `numerator`. This is due to the fact that\n///        we no longer work over `MOD`, and we can't really do subtractions as we did previously: `double_modulus - x`\n///\n/// ## Note\n/// We leave the borrow values at 2^{246}, even though we should never reach this bound with just 3 terms\n/// The cases where it can happen are: N >= 64 (middle limb will have 64 additions). And it is a pure completeness issue\n/// But the rest of the library will probably not work with that massive number anyway\nunconstrained fn __compute_udiv_mod_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n    quotient: [u128; N],\n    remainder: [u128; N],\n) -> [bool; N - 1] {\n    let mut product_limbs: [Field; N] = [0; N];\n    let mut numerator_field: [Field; N] = [0; N];\n    for i in 0..N {\n        for j in 0..N - i {\n            product_limbs[i + j] += (quotient[i] as Field) * (divisor[j] as Field);\n        }\n        product_limbs[i] += (remainder[i] as Field);\n\n        numerator_field[i] = numerator[i] as Field;\n    }\n\n    __compute_borrow_flags(product_limbs, numerator_field)\n}\n\n/// Constrained version of `__compute_udiv_mod_expression_with_borrow_flags`\n///\n/// Computes the following expression in-circuit:\n///     quotient * divisor + remainder - numerator = 0\n///\n/// Mirror function of `compute_quadratic_expression_with_modulus`. See it for details.\n///\n/// ## Soundness note\n/// We compute the full convolution `quotient * divisor` into `2N - 1` limbs\n/// and then constrain all limbs with index `i >= N` to be zero. For `i >= N`\n/// the value `expression_limbs_full[i]` is a sum of products\n///     sum_{j+k=i} quotient[j] * divisor[k]\n/// with no contribution from `numerator` or `remainder`.\n///\n/// Every limb of `quotient` and `divisor` is range-constrained to be a 120-bit\n/// integer, so each product term is < 2^{240} and each coefficient of the\n/// convolution is strictly smaller than the field modulus. In this regime,\n/// the constraint `expression_limbs_full[i] == 0` in `Field` coincides with\n/// the same equality over the integers.\n///\n/// Vanishing of all high limbs `i >= N` is therefore an integer statement that\n/// the product has degree < N, i.e.\n///     quotient * divisor < 2^{120 * N},\n/// so `quotient * divisor` fits into `N` 120-bit limbs and does not overflow.\nfn compute_udiv_mod_expression<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n    quotient: [u128; N],\n    remainder: [u128; N],\n) -> [Field; N] {\n    // Safety: use an unconstrained function to compute the value of the quotient and borrow_flags out-of-circuit\n    let borrow_flags: [bool; N - 1] = unsafe {\n        __compute_udiv_mod_expression_with_borrow_flags::<N, MOD_BITS>(\n            numerator,\n            divisor,\n            quotient,\n            remainder,\n        )\n    };\n\n    let mut expression_limbs_full: [Field; 2 * N - 1] = [0; 2 * N - 1];\n    for i in 0..N {\n        for j in 0..N {\n            expression_limbs_full[i + j] += (quotient[i] as Field) * (divisor[j] as Field);\n        }\n        expression_limbs_full[i] += (remainder[i] as Field) - (numerator[i] as Field);\n    }\n\n    let mut expression_limbs: [Field; N] = [0; N];\n    for i in 0..N {\n        expression_limbs[i] = expression_limbs_full[i];\n    }\n    for i in N..2 * N - 1 {\n        assert(expression_limbs_full[i] == 0);\n    }\n\n    apply_borrow_flags(expression_limbs, borrow_flags)\n}\n\n/// Constrain a `udiv_mod` `BigNum` expression to be equal to 0\n///\n/// Mirror function of `evaluate_quadratic_expression`\n///\n/// ## Details\n///\n/// The constrained expression, viewed over the integers, is:\n///\n///     quotient * divisor + remainder - numerator = 0\n///\n/// ## Completeness\n/// If an honest prover supplies valid `BigNum` inputs that satisfy the equation,\n/// it can always find `borrow_flags` such that the integer\n/// relation holds and all constraints are satisfied.\n///\n/// The only possibility to break completeness is by providing a `BigNum` with `N >= 64`\n/// See `__compute_udiv_mod_expression_with_borrow_flags` for details\n///\n/// ## Soundness\n/// This function is conditionally sound: it enforces that the degree-2 relation\n/// holds over the integers, but it does not, by itself, enforce that\n/// this relation is unique for given `numerator` and `divisor`\n///\n/// For example, if the true relation is\n///     quotient * divisor + remainder - numerator = 0\n///\n/// then we can set quotient' = quotient - 1, remainder' = remainder + divisor\npub(crate) fn validate_udiv_mod_expression<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n    quotient: [u128; N],\n    remainder: [u128; N],\n) {\n    validate_in_range::<u128, N, MOD_BITS>(numerator);\n    validate_in_range::<u128, N, MOD_BITS>(divisor);\n    validate_in_range::<u128, N, MOD_BITS>(quotient);\n    validate_in_range::<u128, N, MOD_BITS>(remainder);\n\n    let expression_limbs: [Field; N] =\n        compute_udiv_mod_expression::<N, MOD_BITS>(numerator, divisor, quotient, remainder);\n    validate_expression_is_zero(expression_limbs);\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/expressions.nr"
    },
    "88": {
      "source": "use crate::utils::map::invert_array;\n\n// Conversions between big endian and little endian byte arrays and BigNum instances\n// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\n\n/// Construct a `BigNum` value from a big-endian byte array.\n///\n/// The input encodes an integer in base 256, which we split into `N` 120-bit limbs.\n///\n/// ## Note\n/// We only enforce that the value is < 2^MOD_BITS. We do not enforce that it is\n/// reduced modulo the field modulus.\n///\n/// Consistency between `N` and `MOD_BITS` is expected:\n///     - `N * 15 >= num_bytes`\n///     - `num_bytes > (N - 1) * 15`\n///\n/// Enforcing range constraints on each limb is crucial for efficiency.\n/// In principle, accumulating `u8` values already bounds the integer,\n/// but relying on Noir to infer a `u128` from a large linear combination\n/// would trigger a very general (and expensive) range checks\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bytes: u32 = (MOD_BITS + 7) / 8;\n\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes: u32 = N * 15 - num_bytes;\n    let last_limb_bytes: u32 = 15 - excess_bytes;\n\n    let mut limb: Field = 0;\n    for i in 0..last_limb_bytes {\n        limb *= 256;\n        limb += x[i] as Field;\n    }\n\n    // TODO: Figure out why is it more efficient to apply 120-bit range constraint here\n    // Rather than `MOD_BITS - 120 * (N - 1)`-bit constraint\n    limb.assert_max_bit_size::<120>();\n    result[N - 1] = limb as u128;\n\n    let mut byte_ptr: u32 = last_limb_bytes;\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _ in 0..15 {\n            limb *= 256;\n            limb += x[byte_ptr] as Field;\n            byte_ptr += 1;\n        }\n        limb.assert_max_bit_size::<120>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    if (MOD_BITS % 8 != 0) {\n        let most_significant_byte: Field = x[0] as Field;\n        most_significant_byte.assert_max_bit_size::<MOD_BITS % 8>();\n    }\n    result\n}\n\n/// Construct a big-endian byte array from a `BigNum` value.\n///\n/// The output contains `(MOD_BITS + 7) / 8` bytes. We serialize the most\n/// significant limb first, which may occupy fewer than 15 bytes, followed by\n/// the remaining full 15-byte limbs in big-endian order.\n///\n/// Consistency between `N` and `MOD_BITS` is expected:\n///     - the most significant limb contributes `((MOD_BITS + 7) / 8) - (N - 1) * 15` bytes;\n///     - all other limbs are serialized as full 15-byte chunks.\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n\n    let last_limb_num_bytes: u32 = (MOD_BITS + 7) / 8 - (N - 1) * 15;\n    let mut byte_ptr: u32 = last_limb_num_bytes;\n    // First we deal with the full limbs\n    for i in 0..N - 1 {\n        let idx: u32 = (N - 1) - i - 1;\n        let limb_bytes: [u8; 15] = (val[idx] as Field).to_be_bytes();\n        for j in 0..15 {\n            result[byte_ptr] = limb_bytes[j];\n            byte_ptr += 1;\n        }\n    }\n\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n    for i in 0..last_limb_num_bytes {\n        result[i] = last_limb_bytes[i];\n    }\n\n    result\n}\n\n/// Construct a `BigNum` value from little-endian byte array\n///\n/// Reverse an array and apply `from_be_bytes`\n///\n/// See `from_be_bytes` for details\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let be_x: [u8; (MOD_BITS + 7) / 8] = invert_array(x);\n    from_be_bytes(be_x)\n}\n\n/// Construct a little-endian byte array from a `BigNum` value\n///\n/// Apply `to_be_bytes` and reverse an array\n///\n/// See `to_be_bytes` for details\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    invert_array(result_be)\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/serialization.nr"
    },
    "89": {
      "source": "// This file contains the unconstrained helpers that are mostly used by unconstrained ops\n\nuse crate::constants::TWO_POW_120;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __gte, __mul, __neg, __pow, __sqr};\n\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::{__normalize_limbs, __split_120_bits};\n\nuse crate::params::BigNumParams;\n\n// ------------------------------ DERIVATION HELPER FUNCTIONS ------------------------------\n\n///  Construct a `1` BigNum value (unconstrained)\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Construct a BigNum value from Field (unconstrained)\n///\n/// Split the native `Field` value into `N` 120-bit limbs\npub(crate) unconstrained fn __from_field<let N: u32>(val: Field) -> [u128; N] {\n    let mut x: Field = val;\n    let mut result: [u128; N] = [0; N];\n\n    if (N == 1) {\n        let (first_limb, _): (u128, Field) = __split_120_bits(x);\n        result[0] = first_limb;\n    }\n\n    if (N == 2) {\n        let (first_limb, x): (u128, Field) = __split_120_bits(x);\n        let (second_limb, _): (u128, Field) = __split_120_bits(x);\n        result[0] = first_limb;\n        result[1] = second_limb;\n    }\n\n    if (N > 2) {\n        let (first_limb, x): (u128, Field) = __split_120_bits(x);\n        let (second_limb, x): (u128, Field) = __split_120_bits(x);\n        let (third_limb, _): (u128, Field) = __split_120_bits(x);\n        result[0] = first_limb;\n        result[1] = second_limb;\n        result[2] = third_limb;\n    }\n    result\n}\n\n// ------------------------------ ARITHMETIC WITH FLAGS HELPER FUNCTIONS ------------------------------\n// These are the functions that compute modular operations results as well as borrow and carry flags for constraints\n\n/// Compute the `MOD - val` and the corresponding borrow flags (unconstrained)\n///\n/// Negate the value and compute the flags indicating whether we need\n///      to borrow a `bit` from the upper limb when subtracting the value from modulus\n///\n/// ## Note\n/// The `borrow_in` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term: u128 = val[i] + borrow_in;\n        borrow_in = (sub_term > modulus[i]) as u128;\n        result[i] = borrow_in * TWO_POW_120 + modulus[i] - sub_term;\n        if (i < N - 1) {\n            borrow_flags[i] = (borrow_in != 0);\n        }\n    }\n    (result, borrow_flags)\n}\n\n/// Compute modular addition and the corresponding borrow and carry flags (unconstrained)\n///\n/// Given `x, y, MOD` compute x + y or x + y - MOD in case it overflows\n/// Additionally compute all the carries from addition (x + y)\n/// and borrows from subtraction  (- MOD)\n///\n/// ## Note\n/// The `borrow` must be equal to `carry` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N - 1], [bool; N - 1], bool) {\n    let mask: u128 = TWO_POW_120 - 1;\n\n    let add_res: [u128; N] = __helper_add(lhs, rhs);\n    let overflow: bool = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = if overflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N - 1] = [false; N - 1];\n\n    let mut carry: u128 = 0;\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + rhs[i] + carry;\n        carry = add_term >> 120;\n        add_term &= mask;\n\n        let sub_term: u128 = subtrahend[i] + borrow;\n        borrow = (sub_term > add_term) as u128;\n\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n\n        // Only set `borrow` and `carry` if they differ\n        // And if it's not the last limb\n        if (carry != borrow) & (i < N - 1) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\n/// Compute modular subtraction and the corresponding borrow and carry flags (unconstrained)\n///\n/// Given `x, y, MOD` compute x - y or x - y + MOD in case it overflows\n/// Additionally compute all the carries from addition (x + MOD)\n/// and borrows from subtraction  (- y)\n///\n/// ## Note\n/// The `borrow` must be equal to `carry` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N - 1], [bool; N - 1], bool) {\n    let mask: u128 = TWO_POW_120 - 1;\n\n    let underflow: bool = !__gte(lhs, rhs);\n\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N - 1] = [false; N - 1];\n\n    let mut carry: u128 = 0;\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry;\n        carry = add_term >> 120;\n        add_term &= mask;\n\n        let sub_term: u128 = rhs[i] + borrow;\n        borrow = (sub_term > add_term) as u128;\n\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n\n        // Only set `borrow` and `carry` if they differ\n        // And if it's not the last limb\n        if (carry != borrow) & (i < N - 1) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/// Validate that lhs - rhs does not underflow (unconstrained)\n///\n/// Same as `__validate_gte_with_flags`, but we don't compute the\n/// result of a subtraction\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N - 1] {\n    let modulus: [u128; N] = params.modulus;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    borrow_flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        borrow_flags[i] = modulus[i] < val[i] + (borrow_flags[i - 1] as u128);\n    }\n    borrow_flags\n}\n\n/// Validate that lhs - rhs does not underflow (unconstrained)\n///\n/// Compute underflow flag (lhs < rhs)\n///       then perform subtraction with borrow flags\n///\n/// ## Note\n/// The `borrow` must be equal to 0 at the end of the loop.\n/// And it can't be nonzero, since we swap the terms at the beginning\npub(crate) unconstrained fn __validate_gte_with_flags<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N - 1]) {\n    let mut a: [u128; N] = lhs;\n    let mut b: [u128; N] = rhs;\n\n    let underflow: bool = !__gte(lhs, rhs);\n    // swap a and b if there's an underflow\n    let (a, b): ([u128; N], [u128; N]) = if underflow { (b, a) } else { (a, b) };\n\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let mut add_term: u128 = a[i];\n\n        let sub_term: u128 = b[i] + borrow;\n        borrow = (sub_term > add_term) as u128;\n\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, borrow_flags)\n}\n\n// ------------------------------ BARRETT REDUCTION ------------------------------\n\n/// `BARRETT_REDUCTION_OVERFLOW_BITS` defines how large an input to barrett reduction can be\n///\n/// maximum value = modulus^2 << BARRETT_REDUCTION_OVERFLOW_BITS\n/// see __barrett_reduction for more details\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\n/// Optimized modular multiplication (unconstrained)\n///\n/// The trick is to approximate 1/p with m/2**r, because division by 2**r is much cheaper\n/// In our case m = redc_param = floor(2^{MOD_BITS * 2 + BARRET_REDUCTION_OVERFLOW_BITS} / p)\n///             r = MOD_BITS * 2 + BARRET_REDUCTION_OVERFLOW_BITS\n///\n/// When we apply the barrett reduction, the maximum value of the output will be <= p * (1 + x/2^{2k})\n/// where p = modulus,\n///       x = reduction input\n///\n/// If x > p * p, we need k to be larger than modulus_bits()\n/// We hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n/// This should be larger than most values put into `evaluate_quadratic_expression`\n///\n/// ## TODO\n/// Detect cases where x might be too large at comptime\n///\n/// ## Note\n/// very niche edge case error that we need to be aware of:\n///      N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n///      i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow\n///      when calling __barrett_reduction\n///\n/// ## Note on final reduction\n///\n/// Assumptions:\n///  - k = ceil(log2 p), so p <= 2^k\n///  - s = 4, m = redc_param = floor(2^{2*k + s}/p)\n///  - x < 16 * p^2 (x < 2^{2 * k + s})\n///\n/// Let m' = 2^{2*k + s} / p, and write m = m' - \\epsilon, \\epsilon \\in [0, 1)\n//\n/// quo = floor(x * m / 2^{2 * k + s}) = floor(x * m' / 2^{2 * k + s} - x * \\epsilon / 2^{2 * k + s}) =\n/// floor(x / p - x * \\epsilon / 2^{2 * k + s})\n///\n/// Bounds:\n///   quo <= floor(x / p)\n///\n///   floor(a - b) >= floor(a) - ceil(b) (known identity) =>\n///   quo >= floor(x / p) - ceil(x * \\epsilon / 2^{2 * k + s})\n///       >= floor(x / p) - ceil(x / 2^{2 * k + s}) (epsilon < 1)\n///\n/// x / 2^{2 * k + s} < C * p^2 / 2^{2 * k + s} <= C * 2^{2 * k} / 2^{2 * k + s} = C / 2^s\n///\n/// When the assumption holds (C = 16), ceil(x / 2^{2 * k + s}) = 1, for x > 0\n/// Therefore quo = {floor(x/p), floor(x/p) - 1}\n///\n/// In first case: rem = x - quo * p = x - floor(x/p) * p < p\n/// In second case: rem = x - (floor(x/p) - 1) * p = (x - floor(x/p) * p) + p -> need 1 subtraction\n///\n/// ### Note\n/// We allow 64 products to be summed inside the `evaluate_quadratic_expression`\n/// In that case x / 2^{2 * k + s} < 64 / 2^4 = 4 => hence we need to subtract modulus at most 4 times\n/// We can leave it 2 for now as it is unlikely to reach beyond 32 * p^2\n///\n/// In the worst case though, we will have the input > 64 * p^2\n/// (for example (a1 + b1) * (c1 + d1) + ... 64 times)\n/// This is highly unlikely though.\n///\n/// ### TODO:\n/// Possibly change the `BARRETT_REDUCTION_OVERFLOW_BITS` to 6, so that we need only 1 reduction here\n/// However we will have to recompute all the fields `redc_param`s and fix paramgen\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    // TODO: switch to __helper_mul, once the compiler is smart enough to handle this\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(2 * N) {\n        for j in 0..N {\n            mulout_field[i + j] += (x[i] as Field) * (redc_param[j] as Field);\n        }\n    }\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field);\n\n    let quotient: [u128; 3 * N] = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // Remove a bunch of zeros from the end\n    let mut smaller_quotient: [u128; N] = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // long_quotient_mul_modulus can never exceed input value `x` so can fit into size-2 array\n    let long_quotient_mul_modulus: [u128; 2 * N] = __helper_mul(smaller_quotient, modulus);\n    let long_remainder: [u128; 2 * N] = __helper_sub(x, long_quotient_mul_modulus);\n\n    // Remove a bunch of zeros from the end\n    let mut remainder: [u128; N] = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n\n    for _ in 0..2 {\n        if (__gte(remainder, modulus)) {\n            remainder = __helper_sub(remainder, modulus);\n            smaller_quotient = __increment(smaller_quotient);\n        }\n    }\n\n    (smaller_quotient, remainder)\n}\n\n// ------------------------------ ARITHMETIC HELPER FUNCTIONS ------------------------------\n// These are the functions that operate on limbs as if they were just big integers\n\n/// Adds `1` to the BigNum value without modular reduction (unconstrained)\n///\n/// ## Note\n/// The `carry` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mask: u128 = TWO_POW_120 - 1;\n\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let add_term: u128 = val[i] + carry;\n        carry = add_term >> 120;\n        result[i] = add_term & mask;\n    }\n    result\n}\n\n/// Adds two `BigNum` values without modular reduction (unconstrained).\n///\n/// ## Note\n/// The `carry` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry: u128 = 0;\n    let mask: u128 = TWO_POW_120 - 1;\n\n    for i in 0..N {\n        let add_term: u128 = lhs[i] + rhs[i] + carry;\n        carry = add_term >> 120;\n        result[i] = add_term & mask;\n    }\n    result\n}\n\n/// Subtracts two `BigNum` values without modular reduction (unconstrained).\n///\n/// ## Note\n/// The `borrow` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let subtrahend: u128 = rhs[i] + borrow;\n        borrow = (subtrahend > lhs[i]) as u128;\n        result[i] = (borrow << 120) + lhs[i] - subtrahend;\n    }\n    result\n}\n\n/// Multiplies two `BigNum` values without modular reduction (unconstrained).\n///\n/// Computes the full schoolbook product of two N-limb little-endian arrays\n///\n/// ## Note\n/// The mathematical product fits in `2 * N - 1` limbs, but we keep `2 * N`\n/// limbs intentionally as the extra high limb safely absorbs a possible single limb overflow\n/// for moduli close to `120 * N` bits.\npub(crate) unconstrained fn __helper_mul<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; 2 * N] {\n    let mut result: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            result[i + j] += (lhs[i] as Field) * (rhs[j] as Field);\n        }\n    }\n    __normalize_limbs(result)\n}\n\n// ------------------------------ LOGIC HELPER FUNCTIONS ------------------------------\n// These are the functions that operate on limbs as if they were just big integers\n\n/// Left-shifts a `BigNum` value by `shift` bits (unconstrained).\n///\n/// Performs a bitwise left shift across limbs.\n///\n/// ## Note\n/// The most significant limb is truncated to 120 bits after the shift.\n///\n/// No bounds check is performed on `num_shifted_limbs`.\n/// However, we use it only in `__udiv_mod`, where it is not possible to reach\n/// `num_shifted_limbs` > `N`\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs: u32 = shift / 120;\n    let limb_shift: u128 = (shift % 120) as u128;\n    let remainder_shift: u128 = 120 - limb_shift;\n\n    let mask: u128 = TWO_POW_120 - 1;\n    let mut remainder: u128 = input[0] >> remainder_shift;\n\n    result[num_shifted_limbs] = (input[0] << limb_shift) & mask;\n\n    for i in 1..(N - num_shifted_limbs) {\n        let value: u128 = input[i];\n        let upshift: u128 = ((value << limb_shift) | remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = value >> remainder_shift;\n    }\n    result\n}\n\n/// Right-shifts a `BigNum` value by `shift` bits (unconstrained).\n///\n/// Performs a bitwise right shift across limbs.\n///\n/// # Note\n/// No bounds check is performed on `num_shifted_limbs`.\n/// However, we use it only in `__tonelli_shanks_sqrt`, where it is not possible to reach\n/// `num_shifted_limbs` > `N`\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs: u32 = shift / 120;\n    let limb_shift: u128 = (shift % 120) as u128;\n\n    let remainder_shift: u128 = 120 - limb_shift;\n    let low_mask: u128 = (1 as u128 << limb_shift) - 1;\n\n    result[0] = input[num_shifted_limbs] >> limb_shift;\n    for i in 1..(N - num_shifted_limbs) {\n        let value: u128 = input[i + num_shifted_limbs];\n\n        let carry: u128 = (value & low_mask) << remainder_shift;\n        result[i - 1] |= carry;\n\n        result[i] = value >> limb_shift;\n    }\n    result\n}\n\n/// Right-shifts a `BigNum` value by `1` bit  (unconstrained)\n///\n/// # Note\n/// All the operations on limbs are executed in place\n/// to save opcodes\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value: u128 = input[N - 1];\n    let mut remainder: u128 = (value & 1) << 119;\n    input[N - 1] >>= 1;\n\n    for i in 1..N {\n        let value: u128 = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) | remainder;\n        remainder = (value & 1) << 119;\n    }\n    input\n}\n\n/// Returns the index of the most significant set bit in a `BigNum` value (unconstrained).\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count: u32 = 0;\n    for i in 0..N {\n        let idx: u32 = N - 1 - i;\n        let v: u128 = val[idx];\n        if (v > 0) {\n            count = 120 * idx + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\n/// Returns `true` if the bit at position `bit` is set in the `BigNum` (unconstrained).\n///\n/// ## Note\n/// No bounds check is performed on `bit`\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index: u128 = (bit % 120) as u128;\n\n    let limb: u128 = input[segment_index];\n    let value: u128 = (limb >> uint_index) & 1;\n    value == 1\n}\n\n// ------------------------------ SQRT HELPER FUNCTIONS ------------------------------\n// These are the functions that are used during taking a square root\n\n/// Compute the maximal power of 2 that divides the group order (unconstrained)\n///\n/// Find the maximum value s such that `MOD = 2^s * q + 1`, where `q` is odd\n///       This is needed for our Tonelli-Shanks sqrt algorithm\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n) -> u32 {\n    let mut target: [u128; N] = __helper_sub(params.modulus, __one());\n    let mut result: u32 = 0;\n    while !__get_bit(target, result) {\n        result += 1;\n    }\n    result\n}\n\n/// Find a quadratic non-residue `g` where `g` is the smallest such value (unconstrained)\n///       i.e. smallest `g` such that `g^{(p - 1)/2} = -1 (mod MOD)`\n///       or smallest `g`, such that `x^2 - g = 0 (mod MOD)` has no solutions\n///\n/// ## Note\n/// WARNING If the field is not prime, this function will enter an infinite loop!\npub(crate) unconstrained fn __quadratic_non_residue<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n) -> [u128; N] {\n    let one: [u128; N] = __one();\n    let neg_one: [u128; N] = __neg(params.modulus, one);\n\n    let p_minus_one_over_two: [u128; N] = __shr1(__helper_sub(params.modulus, __one()));\n\n    // We start with 2\n    let mut target: [u128; N] = __increment(one);\n    let mut expd: [u128; N] = __pow(params, target, p_minus_one_over_two);\n    while !__eq(expd, neg_one) {\n        target = __increment(target);\n        expd = __pow(params, target, p_minus_one_over_two);\n    }\n    target\n}\n\n/// Compute the smallest `i`, such that `t^{2^i} = 1, t^{2^{i-1}} = -1 (mod MOD)` (unconstrained)\n///\n/// ## Note\n/// Multiplicative order of t must divide 2^v2(MOD-1), otherwise you'll end up in an infinite loop!\npub(crate) unconstrained fn __tonelli_shanks_sqrt_find_i<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    t: [u128; N],\n) -> u32 {\n    let one: [u128; N] = __one();\n    let mut c: [u128; N] = t;\n\n    let mut i: u32 = 0;\n    // Compute t^{2^k} until it hits 1 for the first time\n    while !__eq(c, one) {\n        c = __sqr::<N, MOD_BITS>(params, c);\n        i += 1;\n    }\n    i\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/unconstrained_helpers.nr"
    },
    "90": {
      "source": "// This file contains the unconstrained operations that are used directly by BigNum class\n\nuse crate::fns::constrained_ops::derive_from_seed;\n\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_mul, __helper_sub,\n    __increment, __one, __primitive_root_log_size, __quadratic_non_residue, __shl, __shr, __shr1,\n    __tonelli_shanks_sqrt_find_i,\n};\n\nuse crate::constants::TWO_POW_120;\n\nuse crate::params::BigNumParams;\n\n// ------------------------------ DERIVATION FUNCTIONS ------------------------------\n\n/// Deterministically derives a `BigNum` from a seed value (unconstrained)\n///\n/// Takes a seed byte array and generates a `BigNum` in the range [0, modulus-1].\n///\n/// See more information in `constrained_ops.nr`: `derive_from_seed`\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed)\n}\n\n// ------------------------------ COMPARISON FUNCTIONS ------------------------------\n\n/// Compare two limb arrays for equality (unconstrained)\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\n/// Compare a limb array to a zero array (unconstrained)\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    limbs == [0; N]\n}\n\n/// Compare two little-endian limb arrays for `lhs >= rhs` over integers (unconstrained)\n///\n/// Starts from the most significant limb (`N - 1`) and returns true\n/// if `lhs` is greater or equal to `rhs`\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        let idx: u32 = N - 1 - i;\n        if (lhs[idx] != rhs[idx]) {\n            result = lhs[idx] > rhs[idx];\n            break;\n        }\n    }\n    result\n}\n\n// ------------------------------ ARITHMETIC FUNCTIONS ------------------------------\n\n/// Negates a `BigNum` value, returning `m - x` (unconstrained)\n///\n/// ## Note\n/// The input is assumed to be less than modulus\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\n/// Adds two `BigNum` values with modular reduction (unconstrained)\n///\n/// Sums the limbs one by one, keeping the carry.\n/// In case the result overflows the modulus, the modulus is subtracted once\n///\n/// ## Note\n/// The `carry` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    let mask: u128 = TWO_POW_120 - 1;\n\n    for i in 0..N {\n        let add_term: u128 = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        result[i] = add_term & mask;\n    }\n\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/// Subtracts two `BigNum` values with modular reduction (unconstrained).\n///\n/// Computes `x + (m - y)` (mod m)\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\n/// Multiply `x` and `y` and reduce via Barrett, returning (Q, R) (unconstrained).\n///\n/// For `BigNum` values `x` and `y` compute (`Q`, `R`) such that:\n///      x * y = R + Q * m, 0 <= R < m\n/// See `__barrett_reduction` for details.\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let to_reduce: [u128; N * 2] = __helper_mul(lhs, rhs);\n    let (q, r): ([u128; N], [u128; N]) =\n        __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\n/// Multiplies two `BigNum` values with modular reduction (unconstrained).\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __mul_with_quotient::<N, MOD_BITS>(params, lhs, rhs).1\n}\n\n/// Squares a `BigNum` value with modular reduction (unconstrained).\npub(crate) unconstrained fn __sqr<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    __mul_with_quotient::<N, MOD_BITS>(params, val, val).1\n}\n\n/// Modular exponentiation via square-and-multiply. LSB-first (unconstrained).\n///\n/// Computes `x^e mod m`\n///\n/// ## Note\n/// For the loop, we are using `MOD_BITS` instead of `__get_msb`\n/// because it is much much cheaper\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let mut accumulator: [u128; N] = __one();\n    let mut x: [u128; N] = val;\n    let num_bits: u32 = MOD_BITS + 1;\n\n    for i in 0..num_bits {\n        if __get_bit(exponent, i) {\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, x);\n        }\n        x = __sqr::<N, MOD_BITS>(params, x);\n    }\n    accumulator\n}\n\n/// Given a `BigNum` value `x` compute x^{-1} (mod m) (unconstrained)\n///\n/// x^{p-1} = 1 (mod p) (Fermat's little theorem)\n/// x^{p-2} = x^{-1} (mod p)\n///\n/// ## Note\n/// The input value must be nonzero and modulus has to be prime\n/// No explicit assertion is made, as this condition is validated during evaluation\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one: [u128; N] = __one();\n    let exp: [u128; N] = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<N, MOD_BITS>(params, val, exp)\n}\n\n/// Divides two `BigNum` values with modular reduction (unconstrained).\n///\n/// Computes `x * y^{-1}` (mod m)\n///\n/// ## Note\n/// The divisor must be nonzero\n/// No explicit assertion is made, as this condition is validated during evaluation\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<N, MOD_BITS>(params, divisor);\n    __mul::<N, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/// Given the `BigNum` inputs `x, y`, compute integer division x / y (unconstrained)\n///\n/// This function implements binary long division and outputs (`quotient`, `remainder`) such that:\n///   1. floor(numerator / divisor) = quotient\n///   2. numerator % divisor = remainder\n///   3. divisor * quotient + remainder = numerator\n///\n/// ## Note\n/// The divisor must be nonzero\n/// No explicit assertion is made, as this condition is validated during evaluation\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n    let b: [u128; N] = divisor;\n\n    let numerator_msb: u32 = __get_msb(numerator);\n    let divisor_msb: u32 = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference: u32 = __get_msb(remainder) - __get_msb(divisor);\n        let mut divisor: [u128; N] = __shl(divisor, bit_difference);\n        let mut accumulator: [u128; N] = __shl(__one(), bit_difference);\n\n        // The same as divisor > remainder\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        (quotient, remainder)\n    }\n}\n\n/// Batch modular inversion of `BigNum` values in an array (unconstrained)\n///\n/// Given values v[0..M), returns inv[0...M) with inv[i] = v[i]^{-1} (mod m)\n///\n/// We use the Montgomery trick:\n/// First we compute the partial products:\n///         T0 = 1\n///         T1 = v1,\n///         T2 = v1 * v2,\n///         ...\n///         T_{m - 1} = T_{m - 2} * v_{m - 1} = v1 * ... * v_{m - 1}\n///\n///         P = T_{m-1} * v_m = v1 * v2 * ... * v_m\n///\n/// Then we calculate a single inverse P^-1 = v1^-1 * v2^-1 * ... * v_m^-1\n/// Finally we compute\n///         v_m^-1       = (P^-1 * T_{m-1})\n///         v_{m - 1}^-1 = (P^-1 * v_m * T_{m - 2})\n///         ....\n///         v_2^-1       = (P^-1 * v_m * ... * v_3 * T_1)\n///         v_1^-1       = (P^-1 * v_m * ... * v_2 * T_0)\n///\n/// ## Note\n/// Zero elements are allowed and are left unchanged in the resulting array\n///\n/// This interacts poorly with `neg(zero)`:\n/// Calling `neg` on `zero` yields `modulus` rather than `0`.\n/// A value in this form will **not** satisfy\n/// the `__is_zero` check and will lead to incorrect results.\n///\n/// This edge case should be rare, but it's worth keeping in mind when\n/// composing operations or debugging unexpected behavior\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    vals: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    let mut accumulator: [u128; N] = __one();\n    let mut temporaries: [[u128; N]; M] = [[0; N]; M];\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(vals[i])) {\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<N, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx: u32 = M - 1 - i;\n        if (!__is_zero(vals[idx])) {\n            let T0: [u128; N] = __mul::<N, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/// Batch modular inversion of `BigNum` values in a slice (unconstrained)\n///\n/// See `batch_invert` for details\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    vals: [[u128; N]],\n) -> [[u128; N]] {\n    let mut accumulator: [u128; N] = __one();\n    let mut temporaries: [[u128; N]] = &[];\n\n    let M: u32 = vals.len();\n\n    for i in 0..M {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(vals[i])) {\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<N, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx: u32 = M - 1 - i;\n        if (!__is_zero(vals[idx])) {\n            let T0: [u128; N] = __mul::<N, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        }\n    }\n\n    result\n}\n\n/// Compute a modular square root in a prime field (unconstrained)\npub(crate) unconstrained fn __sqrt<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum::__sqrt: Must be a field to take square roots\",\n    );\n\n    if (__is_zero(input)) {\n        Option::some(input)\n    } else if (params.modulus[0] % 4 == 3) {\n        __easy_sqrt(params, input)\n    } else {\n        __tonelli_shanks_sqrt(params, input)\n    }\n}\n\n/// Compute a modular square root using the Tonelli-Shanks algorithm (unconstrained)\n///\n/// Solves `x^2 = a (mod MOD)` for odd prime MOD\n///\n/// ## Algorithm\n///\n/// Here p = MOD\n///\n/// Tonelli-Shanks setup\n///\n/// Write `p - 1 = 2^s * Q`, `Q` - odd\n/// Define:\n///    `R = a^{(Q+1)/2}`\n///    `t = a^Q`\n///\n/// so that `R^2 = a^{Q + 1} = a * a^Q = a * t`\n/// If t = 1, we are done\n///\n/// By Euler's criterion, `a` is a quadratic reside iff `a^{(p - 1)/2} = 1`\n/// Since `t = a^Q` and `(p - 1) / 2 = Q * 2^{s-1}` we have:\n///    `t^{2^{s-1}} = a^{Q * 2^{s-1}} = a^{(p-1)/2} = 1`, assuming `a` is a q.r.\n///\n/// To proceed with computing our square root, we want to transfer `t` into a smaller subgroup,\n/// specifically, the `2^(s-2)`'th roots of unity or lower.\n///\n/// We do this by finding some value `b`, such that\n/// `(t * b^2)^{2^{s-2}} = 1` and `R' = R * b`\n/// Finding such a `b` is trivial, because from Euler's criterion, we know that,\n/// for any quadratic non-residue `z`, `z^{(p - 1) / 2} = -1`\n/// i.e. `z^{Q * 2^{s-1}} = -1`\n/// => `z^Q` is a `2^{s-1}`'th root of `-1`\n/// => `z^{2 * Q}` is a `2^{s-2}`'th root of `-1`\n///\n/// Since `t^{2^{s-1}} = 1`, we know that for some `i`, `i <= s - 2: t^{2^{i-1}} = -1`\n/// => `t * z^{2 * Q}` is a `2^{s - 2}`'th root of unity.\n/// We can iteratively transform `t` into ever smaller subgroups, until `t = 1`.\n/// At each iteration, we need to find a new value for `b`, which we can obtain\n/// by repeatedly squaring `z^Q`\n///\n/// ## Note\n/// Only use for prime fields! Function may infinite loop if used for non-prime fields\n///\n/// The input is assumed to be a nonzero value\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    let mut result: Option<[u128; N]> = Option::none();\n\n    let one: [u128; N] = __one();\n    let s: u32 = __primitive_root_log_size::<N, MOD_BITS>(params); // p - 1 = 2^s * Q, where Q is odd\n    let Q: [u128; N] = __shr(__helper_sub(params.modulus, one), s);\n    let Q_minus_one_over_two: [u128; N] = __shr1(__helper_sub(Q, one)); // (Q - 1) / 2\n\n    let z: [u128; N] = __quadratic_non_residue::<N, MOD_BITS>(params);\n\n    // Initialize:\n    // b = a^{(Q - 1)/2}\n    // R = a * b = a^{(Q + 1) / 2} => R^2 = a * a^Q\n    // t = R * b = a^Q\n    let mut b: [u128; N] = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r: [u128; N] = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t: [u128; N] = __mul::<_, MOD_BITS>(params, r, b);\n\n    let mut check: [u128; N] = t;\n    // Assure t^{2^{s - 1}} = a^{(p -1)/2} = 1, otherwise we have met a non-residue\n    for _ in 0..s - 1 {\n        check = __sqr::<N, MOD_BITS>(params, check);\n    }\n    if (__eq(check, one)) {\n        let mut m: u32 = s;\n        let mut c: [u128; N] = __pow::<N, MOD_BITS>(params, z, Q); // z^Q - proper 2^{M}'th root of unity\n\n        // Tonelli-Shanks main loop\n\n        // At the beginning of each iteration we have:\n        // M - current exponent such that t lies in the subgroup of order 2^m\n        // t - element, whose order divides 2^m\n        // c - the proper 2^M'th root of unity\n        // R - accumulator with R^2 = a * t\n\n        // If t == 1, we are done and R is a square root\n        //\n        // Otherwise\n        // 1. We compute 1 <= i < M, such that t^{2^i} = 1, t^{2^{i - 1}} = -1\n        // 2. Set b = c^{2^{M - i - 1}}, so it becomes a proper 2^(i+1)'th root of unity\n        //      Then b^2 has order 2^i which matches the order of t\n        //\n        // 3. Update the state values:\n        //    R <- R * b\n        //    t <- t * b^2\n        //    c <- b^2 = c^{2^{M - i}}\n        //    M <- i\n        // reduces the order of t from 2^i to at most 2^{i - 1} and preserves R^2 = a * t\n        //\n        // The loop runs at most s times because M strictly decreases\n        for _ in 0..s {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let i: u32 = __tonelli_shanks_sqrt_find_i::<N, MOD_BITS>(params, t);\n            let mut j: u32 = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                b = __sqr(params, b);\n            }\n\n            let b2: [u128; N] = __sqr::<N, MOD_BITS>(params, b);\n            c = b2;\n            t = __mul::<N, MOD_BITS>(params, t, b2);\n            r = __mul::<N, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\n/// Compute a modular square root for MOD = 3 (mod 4) (unconstrained)\n///\n/// In case MOD = 3 (mod 4), the square root can be computed using the formula:\n///     `R = a^{(MOD + 1) / 4} (mod MOD)`\n///\n/// Then R^2 = a^{(MOD + 1)/ 4 * 2} = a^{(MOD + 1) / 2} = a^{(MOD - 1) / 2 + 1} = a\n///\n/// ## Note\n/// The input is assumed to be a nonzero value\n///\n/// This is much cheaper than `__tonelli_shanks_sqrt`\npub(crate) unconstrained fn __easy_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    let mut result: Option<[u128; N]> = Option::none();\n\n    let one: [u128; N] = __one();\n    let p_minus_one_over_two: [u128; N] = __shr1(__helper_sub(params.modulus, one));\n    let mut check: [u128; N] = __pow(params, input, p_minus_one_over_two);\n    if (__eq(check, one)) {\n        // a = (MOD - 1) / 2\n        // b = (a + 1) / 2 = ((MOD - 1) / 2 + 1) / 2 = (MOD + 1) / 4\n        let p_plus_one_over_four: [u128; N] = __shr1(__increment(p_minus_one_over_two));\n        result = Option::some(__pow(params, input, p_plus_one_over_four));\n    }\n    result\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/unconstrained_ops.nr"
    },
    "99": {
      "source": "use std::ops::WrappingMul;\n\nglobal MUL_DE_BRUIJN_BIT: [u32; 128] = [\n    1, 14, 2, 15, 26, 20, 3, 16, 68, 80, 27, 21, 56, 50, 4, 17, 65, 96, 69, 81, 105, 99, 28, 22, 86,\n    90, 57, 51, 72, 42, 5, 126, 18, 66, 48, 94, 97, 84, 70, 124, 82, 122, 106, 100, 114, 108, 29,\n    23, 77, 102, 87, 91, 119, 116, 58, 52, 61, 110, 73, 37, 43, 31, 6, 127, 13, 25, 19, 67, 79, 55,\n    49, 64, 95, 104, 98, 85, 89, 71, 41, 125, 47, 93, 83, 123, 121, 113, 107, 76, 101, 118, 115, 60,\n    109, 36, 30, 12, 24, 78, 54, 63, 103, 88, 40, 46, 92, 120, 112, 75, 117, 59, 35, 11, 53, 62, 39,\n    45, 111, 74, 34, 10, 38, 44, 33, 9, 32, 8, 7, 128,\n];\n\n/// Get the most significant bit position of a `val` (unconstrained)\n///\n/// Bit hack that uses De Bruijn sequence to calculate msb position in log(N)\n/// See [IntegerLog2DeBruijn](https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn)\npub(crate) unconstrained fn get_msb(x: u128) -> u32 {\n    let result: u32 = if x == 0 {\n        0\n    } else {\n        let mut v: u128 = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        v |= v >> 64;\n        let index: u128 = (v.wrapping_mul(0x1FC10C2FBCF471B913B14CD2595D6D5)) >> 121;\n        MUL_DE_BRUIJN_BIT[index as u32]\n    };\n    result\n}\n\nmod tests {\n    use crate::constants::{TWO_POW_120, TWO_POW_60};\n    use crate::fns::unconstrained_helpers::__get_msb;\n    use super::get_msb as get_msb128;\n    use std::ops::WrappingMul;\n\n    fn assert_msb_equal(x: u64) {\n        // Safety: test code\n        let msb64 = unsafe { get_msb64(x) };\n        // Safety: test code\n        let msb128 = unsafe { get_msb128(x as u128) };\n        assert_eq(msb64, msb128);\n    }\n\n    #[test]\n    /// Check that the msb functions are equivalent with de bruijn sequence for 64 bits and 128 bits\n    fn test_get_msb() {\n        // Test case 1: MSB at position 7\n        let x: u64 = 0x80; // binary: 10000000\n        assert_msb_equal(x);\n\n        // Test case 2: MSB at position 0\n        let x: u64 = 0x1; // binary: 00000001\n        assert_msb_equal(x);\n\n        // Test case 3: MSB at position 63\n        let x: u64 = 0x8000000000000000; // binary: 1000...0000 (63 zeros)\n        assert_msb_equal(x);\n\n        // Test case 4: Zero input\n        let x: u64 = 0x0;\n        assert_msb_equal(x);\n\n        // Test case 5: All bits set\n        let x: u64 = 0xFFFFFFFFFFFFFFFF;\n        assert_msb_equal(x);\n    }\n\n    /// Multiple entires in the `MUL_DE_BRUIJN_BIT` list do not map to a valid output of `v * 0x6c04f118e9966f6b`.\n    /// This is a dummy value to fill the gaps in the map.\n    global n1: u32 = 0xffffffff;\n\n    global MUL_DE_BRUIJN_BIT_64: [u32; 128] = [\n        0, // change to 1 if you want bitSize(0) = 1\n        48, n1, n1, 31, n1, 15, 51, n1, 63, 5, n1, n1, n1, 19, n1, 23, 28, n1, n1, n1, 40, 36, 46,\n        n1, 13, n1, n1, n1, 34, n1, 58, n1, 60, 2, 43, 55, n1, n1, n1, 50, 62, 4, n1, 18, 27, n1,\n        39, 45, n1, n1, 33, 57, n1, 1, 54, n1, 49, n1, 17, n1, n1, 32, n1, 53, n1, 16, n1, n1, 52,\n        n1, n1, n1, 64, 6, 7, 8, n1, 9, n1, n1, n1, 20, 10, n1, n1, 24, n1, 29, n1, n1, 21, n1, 11,\n        n1, n1, 41, n1, 25, 37, n1, 47, n1, 30, 14, n1, n1, n1, n1, 22, n1, n1, 35, 12, n1, n1, n1,\n        59, 42, n1, n1, 61, 3, 26, 38, 44, n1, 56,\n    ];\n\n    pub(crate) unconstrained fn get_msb64(x: u64) -> u32 {\n        let mut v: u64 = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        let index: u64 = (v.wrapping_mul(0x6c04f118e9966f6b)) >> 57;\n        (index as Field).assert_max_bit_size::<32>();\n        MUL_DE_BRUIJN_BIT_64[index as u32]\n    }\n\n    unconstrained fn __get_msb64<let N: u32>(val: [u128; N]) -> u32 {\n        let mut count: u32 = 0;\n        for i in 0..N {\n            let v: u128 = val[((N) - 1 - i)];\n            let v_low: u64 = v as u64 % TWO_POW_60 as u64;\n            let v_high: u64 = ((v - v_low as u128) / TWO_POW_60) as u64;\n            if (v_high > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n                break;\n            }\n            if (v_low > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n                break;\n            }\n        }\n        count\n    }\n\n    #[test]\n    // Check that the msb functions are equivalent with De Bruijn sequence for 64 bits and 128 bits\n    unconstrained fn test_get_msb_equivalence() {\n        // Test single limb (64-bit number)\n        let x: Field = 0x8000000000000000;\n        let arr: [u128; 4] = [0, 0, x as u128, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test multiple limbs (120-bit number)\n        let x: Field = 0x800000000000000000000000000000; // 120 bits number, 2^119\n        let arr: [u128; 4] = [0, 0, x as u128, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test zero\n        let arr: [u128; 4] = [0, 0, 0, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test all bits set (120 bits)\n        let x: Field = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // 120 bits, 2^120 - 1\n        let arr: [u128; 4] = [0, x as u128, 0, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test systematic bit positions\n        for i in 0..120 {\n            let x: u128 = 1;\n            let shifted: u128 = x << i;\n            let arr: [u128; 4] = [0, shifted, 0, 0];\n            let msb1: u32 = __get_msb64(arr);\n            let msb2: u32 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test random-like patterns (multiple bits set)\n        let patterns: [Field; 7] = [\n            0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // alternating bits\n            0x555555555555555555555555555555, // alternating bits (opposite)\n            0x1234567890ABCDEF1234567890ABCD, // some pattern\n            0xFEDCBA0987654321FEDCBA09876543, // some pattern\n            0x800000000000000000000000000001, // highest and lowest bits\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE, // all bits except lowest\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFF, // all bits except highest\n        ];\n        for i in 0..patterns.len() {\n            let arr: [u128; 4] = [0, patterns[i] as u128, 0, 0];\n            let msb1: u32 = __get_msb64(arr);\n            let msb2: u32 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test with MSB in different array positions (120 bits)\n        let x: Field = 0x800000000000000000000000000000; // 120 bits\n        let arr1: [u128; 4] = [x as u128, 0, 0, 0];\n        let arr2: [u128; 4] = [0, x as u128, 0, 0];\n        let arr3: [u128; 4] = [0, 0, x as u128, 0];\n        let arr4: [u128; 4] = [0, 0, 0, x as u128];\n        let msb1_1: u32 = __get_msb64(arr1);\n        let msb2_1: u32 = __get_msb(arr1);\n        assert_eq(msb1_1, msb2_1);\n\n        let msb1_2: u32 = __get_msb64(arr2);\n        let msb2_2: u32 = __get_msb(arr2);\n        assert_eq(msb1_2, msb2_2);\n\n        let msb1_3: u32 = __get_msb64(arr3);\n        let msb2_3: u32 = __get_msb(arr3);\n        assert_eq(msb1_3, msb2_3);\n\n        let msb1_4: u32 = __get_msb64(arr4);\n        let msb2_4: u32 = __get_msb(arr4);\n        assert_eq(msb1_4, msb2_4);\n    }\n\n    #[test]\n    unconstrained fn fuzz_get_msb(seed: [u128; 5]) {\n        let mut seed_copy: [u128; 5] = seed;\n        for i in 0..5 {\n            seed_copy[i] = seed_copy[i] & (TWO_POW_120 - 1);\n        }\n        let msb1: u32 = __get_msb64(seed_copy);\n        let msb2: u32 = __get_msb(seed_copy);\n        assert_eq(msb1, msb2);\n    }\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/utils/msb.nr"
    },
    "100": {
      "source": "use crate::constants::TWO_POW_120;\n\n/// Split the Field value into two 120-bit limbs (unconstrained)\n///\n/// Here we're taking advantage of truncating 120 bit limbs from the input field\n/// and then subtracting them from the input such that the field division is equivalent\n/// to integer division.\n///\n/// We return the lower 120-bit limb as a `u128` value,\n/// and the upper limbs as a `Field`, to avoid unnecessary conversions\n/// and potential overflows\npub(crate) unconstrained fn __split_120_bits(mut x: Field) -> (u128, Field) {\n    let low: u128 = (x as u128) % TWO_POW_120;\n    let high: Field = ((x - low as Field) / TWO_POW_120 as Field);\n    (low, high)\n}\n\n/// Normalize an array of Field values into 120-bit limbs (unconstrained)\n///\n/// Each Field element is split into two parts modulo 2^{120}\n/// The overflow from the lower limbs is carried into the higher limbs\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(input: [Field; N]) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(N - 1) {\n        let (lo, hi): (u128, Field) = __split_120_bits(next);\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    let (lo, hi): (u128, Field) = __split_120_bits(next);\n    normalized[N - 1] = lo;\n\n    // non-zero final carry <=> normalized value overflows the array length\n    assert(hi == 0);\n\n    normalized\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/utils/split_bits.nr"
    },
    "110": {
      "source": "mod scalar_field;\nmod test;\npub mod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    pub x: Field,\n    pub y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\npub trait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx = scalar.base4_slices[i] as u32;\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0] as u32;\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0] as u32;\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx = scalars[j].base4_slices[i] as u32;\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/lib.nr"
    },
    "111": {
      "source": "use std::static_assert;\n\n/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub global TWO_POW_128: Field = 0x100000000000000000000000000000000;\npub global PLO: Field = 0x2833e84879b9709143e1f593f0000001;\npub global PHI: Field = 0x30644e72e131a029b85045b68181585d;\n\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = to_le_radix_16(x);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices<let N: u32>(x: [u8; N], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..N {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\n\nunconstrained fn to_le_radix_16<let N: u32>(value: Field) -> [u8; N] {\n    // Round up on odd values of `N` to ensure space for last nibble.\n    let bytes = value.to_le_bytes::<(N + 1) / 2>();\n    let mut result: [u8; N] = [0; N];\n    for index in 0..(N / 2) {\n        result[index * 2] = bytes[index] & 0x0F; // Extract low nibble (bits 0-3)\n        result[index * 2 + 1] = (bytes[index] >> 4); // Extract high nibble (bits 4-7)\n    }\n    if (N & 1) == 1 {\n        let last_nibble = bytes[bytes.len() - 1];\n        // The last byte must have the top 4 bits empty.\n        (last_nibble as Field).assert_max_bit_size::<4>();\n        result[N - 1] = last_nibble;\n    }\n    result\n}\n\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        // the field elements have 254 bits max, so we do not need to support N > 64\n        static_assert(N <= 64, \"N must be at most 64\");\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = 0;\n            let mut hi: Field = 0;\n\n            for i in 0..32 {\n                lo *= 16;\n                lo += (slices[32 + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            // Safety: we assert that the absolute value has less than 128 bits\n            let is_positive: bool = unsafe { get_borrow_flag(lo, TWO_POW_128) };\n\n            let abs_lo = (is_positive as Field) * lo + (1 - is_positive as Field) * (-lo);\n\n            abs_lo.assert_max_bit_size::<128>();\n            // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n            let borrow = unsafe { get_borrow_flag(PLO, abs_lo) as Field };\n            // we only need to check the rlo has 128 bits or less if lo is positive. if negative, the lo is already less than PLO\n            let rlo = is_positive as Field * (PLO - lo + borrow * TWO_POW_128 - 1)\n                + (1 - is_positive as Field) * (-lo); // -1 because we are checking a strict <, not <=\n            // is lo is positive, we need to check the hi is less than phi with the borrow flag subtracted\n            // if lo is negative, we have to check that hi * 2^128 < phi * 2^128 + abs_lo + plo\n            // to do this we first make a flag to check that abs_lo + plo is larger than 2^128 or not\n            // if they are larger, we check that hi < phi + 1 and otherwise we check that hi < phi\n            // Safety: we assert the when the flag is positive we have less than 128 bits\n            let threshold_flag: bool = unsafe { get_borrow_flag(abs_lo + PLO, TWO_POW_128) };\n            (threshold_flag as Field * (abs_lo + PLO)).assert_max_bit_size::<128>();\n            let rhi = is_positive as Field * (PHI - hi - borrow)\n                + (1 - is_positive as Field) * (PHI - hi + threshold_flag as Field);\n            // the rlo value would have 128 bits or less if positive and more if negative as the modulus is 254 bits\n            rlo.assert_max_bit_size::<128>();\n            rhi.assert_max_bit_size::<128>();\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n\n#[test]\nunconstrained fn test_wnaf() {\n    let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n    let (t0, t1) = get_wnaf_slices::<64>(result);\n    let expected = from_wnaf_slices(t0, t1);\n    assert_eq(result, expected);\n}\n\n#[test]\nfn test_regression_wnaf() {\n    let a = 0x7b;\n    let s: ScalarField<64> = ScalarField::<64>::from(a);\n    let b: Field = ScalarField::<64>::into(s);\n    assert_eq(a, b);\n}\n\n#[test]\nunconstrained fn to_le_radix_16_works_with_odd_N() {\n    let input = 0x0f00;\n    let nibbles: [u8; 3] = to_le_radix_16(input);\n    assert_eq(nibbles, [0x0, 0x0, 0xf]);\n}\n",
      "path": "/home/code/nargo/github.com/noir-lang/noir-edwards/v0.2.5/src/scalar_field.nr"
    },
    "113": {
      "source": "use dep::bignum;\nuse dep::bignum::BigNum;\nuse dep::bignum::fields::U256::U256;\nuse dep::bignum::fields::U512::U512;\nuse edwards::bjj::{BabyJubJub, BabyJubJubParams};\nuse edwards::Curve;\nuse edwards::CurveTrait;\nuse edwards::ScalarField;\nuse std::field::bn254::assert_lt;\nuse std::{hash::blake2s, ops::Mul};\n\n// Generator point of Baby Jubjub curve.\n// ref: https://github.com/noir-lang/noir-edwards/blob/main/src/test.nr#L6C8-L6C13\nglobal BASE8: [Field; 2] = [\n    5299619240641551281634865583518297030282874472190772894086521144482721001553,\n    16950150798460657717958625567821834550301663161624707787222815936182638968203,\n];\n\nglobal generator: Curve<BabyJubJubParams> = BabyJubJub::from((BASE8[0], BASE8[1]));\n\n// Baby Jubjub curve order [251 bit value]\npub global BABY_JUBJUB_ORDER: Field =\n    2736030358979909402780800718157159386076813972158567259200215660948447373041;\npub global BABY_JUBJUB_ORDER_PLUS_ONE: Field = BABY_JUBJUB_ORDER + 1;\n\n/// Creates a Baby Jubjub point from a scalar, specifically a Baby Jubjub public key from a secret scalar.\npub fn field_scalar_to_point(value: Field) -> edwards::Curve<BabyJubJubParams> {\n    // Ensure 0 < value <= l.\n    assert(value != 0);\n    assert_lt(value, BABY_JUBJUB_ORDER_PLUS_ONE);\n\n    // ScalarField is parameterised by the number of 4-bit slices it contains.\n    // Since value is already known to be max 251 bits, there are 63 slices.\n    let value_scalar: ScalarField<63> = ScalarField::from(value);\n    let point = generator.mul(value_scalar);\n\n    point\n}\n\n/// Encrypts a field to a Baby Jubjub public key using ECDH encryption.\npub fn VerifyEncryptMessage_ECDH(\n    message: Field,\n    r: Field,\n    pubkey: edwards::Curve<BabyJubJubParams>,\n) -> (edwards::Curve<BabyJubJubParams>, Field) {\n    // Ensure 0 < message <= l.\n    assert(message != 0);\n    assert_lt(message, BABY_JUBJUB_ORDER_PLUS_ONE);\n    // Ensure 0 < r <= l.\n    assert(r != 0);\n    assert_lt(r, BABY_JUBJUB_ORDER_PLUS_ONE);\n\n    // R = r * G (G is the generator)\n    let R: Curve<BabyJubJubParams> = field_scalar_to_point(r);\n\n    // Convert the randomness to Scalar\n    // ScalarField is parameterised by the number of 4-bit slices it contains.\n    // Since r is already known to be max 251 bits, there are 63 slices.\n    let r_scalar: ScalarField<63> = ScalarField::from(r);\n\n    // Shared secret = H(r * pubkey)\n    let rP = pubkey.mul(r_scalar);\n    let rP_x: [u8; 32] = rP.x.to_be_bytes();\n    let rP_y: [u8; 32] = rP.y.to_be_bytes();\n    let pre_image_slice: [u8] = rP_x.as_slice().append(rP_y);\n    let pre_image_array: [u8; 64] = pre_image_slice.as_array();\n    let hash_bytes: [u8; 32] = blake2s(pre_image_array);\n    let hash_bytes_slice: [u8] = hash_bytes.as_slice();\n    // U256 from_be_bytes expects 32 bytes + 1 byte for potential overflow\n    // We add a leading 0u8 since our data won't use the full 256-bit range and is ignored in the modulo\n    let hash_bytes_33: [u8] = &[0].append(hash_bytes_slice);\n    let hash_bignum: U256 = U256::from_be_bytes(hash_bytes_33.as_array());\n\n    //Clamp to Baby Jubjub order\n    let l_bignum: U256 = U256::from(BABY_JUBJUB_ORDER);\n\n    let shared_secret_bignum: U256 = hash_bignum.umod(l_bignum);\n\n    let message_bignum: U256 = U256::from(message);\n    let cipher_bignum_over = shared_secret_bignum + message_bignum;\n    let cipher_bignum: U256 = cipher_bignum_over.umod(l_bignum);\n    let mut cipher: Field = bignum::bignum::to_field(cipher_bignum);\n    if cipher == 0 {\n        cipher = BABY_JUBJUB_ORDER;\n    }\n\n    (R, cipher)\n}\n\n/// Verify T_i [given previous VerifyCOF() and original VerifyWitness0()]\npub fn VerifyTi(T_i: edwards::Curve<BabyJubJubParams>, witness_i: Field) {\n    //Produce statement point\n    let public_key: Curve<BabyJubJubParams> = field_scalar_to_point(witness_i);\n    assert_eq(public_key, T_i);\n}\n\n// Ed25519 curve order  [>252 bit value]\nglobal ED25519_ORDER: Field =\n    7237005577332262213973186563042994240857116359379907606001950938285454250989;\n\npub fn VerifyEquivalentModulo(\n    challenge_bytes: [u8; 32],\n    blinding_DLEQ: Field,\n    witness_i: Field,\n    response_div_BabyJubJub: [u8; 32],\n    response_BabyJubJub: Field,\n    response_div_ed25519: [u8; 32],\n    response_ed25519: [u8; 32],\n) {\n    let challenge_bytes_slice: [u8] = challenge_bytes.as_slice();\n\n    // U512 from_be_bytes expects 64 bytes + 1 byte for potential overflow\n    let challenge_bytes_65: [u8] = &[0; 33].append(challenge_bytes_slice);\n    let challenge_U512: U512 = U512::from_be_bytes(challenge_bytes_65.as_array());\n\n    //response = (challenge * secret) - blinding;\n    let secret: U512 = U512::from(witness_i);\n    let challenge_secret_calc: U512 = challenge_U512.mul(secret);\n\n    let response_calc: U512 = challenge_secret_calc - U512::from(blinding_DLEQ);\n\n    //Baby Jubjub order [251 bit value]\n    let l_bignum: U512 = U512::from(BABY_JUBJUB_ORDER);\n\n    // U512 from_be_bytes expects 64 bytes + 1 byte for potential overflow\n    let response_div_BabyJubJub_bytes_65: [u8] =\n        &[0; 33].append(response_div_BabyJubJub.as_slice());\n    let response_div_BabyJubJub_bignum: U512 =\n        U512::from_be_bytes(response_div_BabyJubJub_bytes_65.as_array());\n\n    let response_BabyJubJub_bignum: U512 = U512::from(response_BabyJubJub);\n    let response_calc_BabyJubJub =\n        l_bignum.mul(response_div_BabyJubJub_bignum) + response_BabyJubJub_bignum;\n    assert_eq(response_calc_BabyJubJub, response_calc);\n\n    //Ed25519 order [>252 bit value]\n    let ed25519_order_bignum: U512 = U512::from(ED25519_ORDER);\n\n    // U512 from_be_bytes expects 64 bytes + 1 byte for potential overflow\n    let response_div_ed25519_bytes_65: [u8] = &[0; 33].append(response_div_ed25519.as_slice());\n    let response_div_ed25519_bignum: U512 =\n        U512::from_be_bytes(response_div_ed25519_bytes_65.as_array());\n\n    // U512 from_be_bytes expects 64 bytes + 1 byte for potential overflow\n    let response_ed25519_bytes_65: [u8] = &[0; 33].append(response_ed25519.as_slice());\n    let response_ed25519_bignum: U512 = U512::from_be_bytes(response_ed25519_bytes_65.as_array());\n\n    let response_calc_ed25519 =\n        ed25519_order_bignum.mul(response_div_ed25519_bignum) + response_ed25519_bignum;\n    assert_eq(response_calc_ed25519, response_calc);\n}\n",
      "path": "/home/code/projects/grease/circuits/library/src/lib.nr"
    }
  },
  "expression_width": {
    "Bounded": {
      "width": 4
    }
  }
}