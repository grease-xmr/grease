{"noir_version":"1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663","hash":"12479602192299736142","abi":{"parameters":[{"name":"i","type":{"kind":"field"},"visibility":"public"},{"name":"wn_prev","type":{"kind":"field"},"visibility":"private"},{"name":"pub_prev","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]},"visibility":"public"},{"name":"pub_next","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]},"visibility":"public"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3301098964710512891":{"error_kind":"fmtstring","length":56,"item_types":[]},"3966396254248265779":{"error_kind":"string","string":"Wide mod reduction verification failed"},"5374506668436577668":{"error_kind":"string","string":"Derived witness must be non-zero"},"6029024216846167016":{"error_kind":"string","string":"Scalar must be non-zero"},"8842443765560789506":{"error_kind":"string","string":"Limb 4 must be 0 for BN254 field"},"9125450380484214683":{"error_kind":"string","string":"validate_gt fail"},"11084314168516775404":{"error_kind":"string","string":"assert_is_not_zero_integer fail"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12562637038294078267":{"error_kind":"string","string":"Limb 3 must be 0 for BN254 field"},"12896400913518849913":{"error_kind":"string","string":"Index must be non-zero"},"14204128565826157521":{"error_kind":"string","string":"pub_prev does not match wn_prev * G"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15206951196984621870":{"error_kind":"string","string":"Field to U512 conversion mismatch"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"18048334649809062322":{"error_kind":"string","string":"pub_next does not match wn_next * G"}}},"bytecode":"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","debug_symbols":"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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        let mut result = if double_predicate {\n            // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n            embedded_curve_add_unsafe(point1, point1)\n        } else {\n            let point1_1 = EmbeddedCurvePoint {\n                x: point1.x + (x_coordinates_match as Field),\n                y: point1.y,\n                is_infinite: false,\n            };\n            let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n            // point1_1 is guaranteed to have a different abscissa than point2:\n            // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n            // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n            // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n            // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n            // therefore we only want to do this if we need the result, otherwise it needs to be eliminated as a dead instruction, lest we want the circuit to fail.\n            embedded_curve_add_unsafe(point1_1, point2_1)\n        };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"39":{"source":"use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_add(y as u8) as i8\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_add(y as u16) as i16\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_add(y as u32) as i32\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_add(y as u64) as i64\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_sub(y as u8) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_sub(y as u16) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_sub(y as u32) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_sub(y as u64) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_mul(y as u8) as i8\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_mul(y as u16) as i16\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_mul(y as u32) as i32\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_mul(y as u64) as i64\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        crate::static_assert(1 == 2, \"custom message\");\n    }\n\n    mod arithmetic {\n        use crate::ops::arith::{Add, Div, Mul, Neg, Rem, Sub};\n        #[test]\n        fn test_basic_arithmetic_traits() {\n            // add\n            assert_eq(5.add(3), 8);\n            assert_eq(0u8.add(255u8), 255u8);\n            assert_eq(42.add(58), 100);\n\n            // sub\n            assert_eq(10.sub(3), 7);\n            assert_eq(100.sub(42), 58);\n\n            // mul\n            assert_eq(6.mul(7), 42);\n\n            // div\n            assert_eq(15.div(3), 5);\n            assert_eq(10u8.div(3u8), 3u8);\n            assert_eq(15.div(3), 5);\n\n            // rem\n            assert_eq(17.rem(5), 2);\n            assert_eq(10u8.rem(3u8), 1u8);\n\n            // neg\n            assert_eq(42.neg(), -42);\n            assert_eq((-10).neg(), 10);\n            assert_eq(42.neg(), -42);\n        }\n\n        #[test]\n        fn test_division() {\n            // test division by one\n            assert_eq(42.div(1), 42);\n            assert_eq(0.div(1), 0);\n            assert_eq(255u8.div(1u8), 255u8);\n\n            // test division by self\n            assert_eq(42.div(42), 1);\n            assert_eq(1.div(1), 1);\n\n            // test remainder\n            assert_eq(42.rem(42), 0);\n            assert_eq(0.rem(42), 0);\n            assert_eq(1.rem(42), 1);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_sub_overflow_failure() {\n            let _ = 0u8.sub(1u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_add_overflow_failure() {\n            let _ = 255u8.add(1u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u8_mul_overflow_failure() {\n            let _ = 255u8.mul(2u8);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_sub_overflow_failure() {\n            let _ = 0u16.sub(1u16);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_add_overflow_failure() {\n            let _ = 65535u16.add(1u16);\n        }\n\n        #[test(should_fail)]\n        fn test_u16_mul_overflow_failure() {\n            let _ = 65535u16.mul(2u16);\n        }\n\n        #[test(should_fail)]\n        fn test_signed_sub_overflow_failure() {\n            let val: i8 = -128;\n            let _ = val.sub(1i8);\n        }\n\n        #[test(should_fail)]\n        fn test_signed_overflow_failure() {\n            let _ = 127i8.add(1i8);\n        }\n\n        #[test]\n        fn test_field() {\n            let zero: Field = 0;\n            let one: Field = 1;\n\n            // test Field basic operations\n            assert_eq(zero.add(one), one);\n            assert_eq(one.add(zero), one);\n            assert_eq(one.sub(one), zero);\n            assert_eq(one.mul(one), one);\n            assert_eq(one.div(one), one);\n            assert_eq(zero.neg(), zero);\n            assert_eq(one.neg(), -one);\n        }\n\n    }\n\n    mod wrapping_arithmetic {\n        use crate::ops::arith::{Add, Div, Mul, Neg, Sub, WrappingAdd, WrappingMul, WrappingSub};\n        #[test]\n        fn test_wrapping_add() {\n            assert_eq(255u8.wrapping_add(1u8), 0u8);\n            assert_eq(255u8.wrapping_add(255u8), 254u8);\n            assert_eq(0u8.wrapping_add(0u8), 0u8);\n            assert_eq(128u8.wrapping_add(128u8), 0u8);\n\n            // test u16 wrapping add\n            assert_eq(65535u16.wrapping_add(1u16), 0u16);\n            assert_eq(65535u16.wrapping_add(65535u16), 65534u16);\n\n            // test u32 wrapping add\n            assert_eq(0xffffffffu32.wrapping_add(1u32), 0u32);\n            assert_eq(0xffffffffu32.wrapping_add(0xffffffffu32), 0xfffffffeu32);\n\n            // test u64 wrapping add\n            assert_eq(0xffffffffffffffffu64.wrapping_add(1u64), 0u64);\n            assert_eq(\n                0xffffffffffffffffu64.wrapping_add(0xffffffffffffffffu64),\n                0xfffffffffffffffeu64,\n            );\n\n            // test u128 wrapping add\n            assert_eq(0xffffffffffffffffffffffffffffffffu128.wrapping_add(1u128), 0u128);\n\n            // test signed types\n            assert_eq(127i8.wrapping_add(1i8), -128i8);\n            let val: i8 = -128;\n            assert_eq(val.wrapping_add(-1i8), 127i8);\n\n            // test Field wrapping add\n            let forty_two: Field = 42;\n            let fifty_eight: Field = 58;\n            let hundred: Field = 100;\n            let neg_two: Field = -2;\n            let two: Field = 2;\n            let zero: Field = 0;\n            let neg_two_hundred: Field = -200;\n            let neg_one_ninety_eight: Field = -198;\n            assert_eq(forty_two.wrapping_add(fifty_eight), hundred);\n            assert_eq(neg_two.wrapping_add(two), zero);\n            assert_eq(neg_two_hundred.wrapping_add(two), neg_one_ninety_eight);\n        }\n\n        #[test]\n        fn test_wrapping_sub() {\n            assert_eq(0u8.wrapping_sub(1u8), 255u8);\n            assert_eq(255u8.wrapping_sub(255u8), 0u8);\n            assert_eq(0u8.wrapping_sub(0u8), 0u8);\n            assert_eq(1u8.wrapping_sub(2u8), 255u8);\n\n            // test u16 wrapping sub\n            assert_eq(0u16.wrapping_sub(1u16), 65535u16);\n            assert_eq(65535u16.wrapping_sub(65535u16), 0u16);\n\n            // test u32 wrapping sub\n            assert_eq(0u32.wrapping_sub(1u32), 0xffffffffu32);\n            assert_eq(0xffffffffu32.wrapping_sub(0xffffffffu32), 0u32);\n\n            // test u64 wrapping sub\n            assert_eq(0u64.wrapping_sub(1u64), 0xffffffffffffffffu64);\n            assert_eq(0xffffffffffffffffu64.wrapping_sub(0xffffffffffffffffu64), 0u64);\n\n            // test u128 wrapping sub\n            assert_eq(0u128.wrapping_sub(1u128), 0xffffffffffffffffffffffffffffffffu128);\n\n            // test signed types\n            let val: i8 = -128;\n            assert_eq(val.wrapping_sub(1i8), 127i8);\n            assert_eq(127i8.wrapping_sub(-1i8), -128i8);\n\n            // test Field wrapping sub\n            let forty_two: Field = 42;\n            let fifty_eight: Field = 58;\n            let neg_sixteen: Field = -16;\n            assert_eq(forty_two.wrapping_sub(fifty_eight), neg_sixteen);\n        }\n\n        #[test]\n        fn test_wrapping_mul() {\n            let zero: u128 = 0;\n            let one: u128 = 1;\n            let two_pow_64: u128 = 0x10000000000000000;\n            let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n            assert_eq(zero, zero.wrapping_mul(one));\n            assert_eq(zero, one.wrapping_mul(zero));\n            assert_eq(one, one.wrapping_mul(one));\n            assert_eq(zero, zero.wrapping_mul(two_pow_64));\n            assert_eq(zero, two_pow_64.wrapping_mul(zero));\n            assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n            assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n            assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n            assert_eq(one, u128_max.wrapping_mul(u128_max));\n\n            // test u8 wrapping mul\n            assert_eq(255u8.wrapping_mul(2u8), 254u8);\n            assert_eq(255u8.wrapping_mul(255u8), 1u8);\n            assert_eq(128u8.wrapping_mul(2u8), 0u8);\n\n            // test u16 wrapping mul\n            assert_eq(65535u16.wrapping_mul(2u16), 65534u16);\n            assert_eq(65535u16.wrapping_mul(65535u16), 1u16);\n\n            // test u32 wrapping mul\n            assert_eq(0xffffffffu32.wrapping_mul(2u32), 0xfffffffeu32);\n            assert_eq(0xffffffffu32.wrapping_mul(0xffffffffu32), 1u32);\n\n            // test u64 wrapping mul\n            // 0xffffffffffffffffu64 is 2^64 - 1\n            assert_eq(0xffffffffffffffffu64.wrapping_mul(2u64), 0xfffffffffffffffeu64);\n            assert_eq(0xffffffffffffffffu64.wrapping_mul(0xffffffffffffffffu64), 1u64);\n\n            // test signed types\n            assert_eq(127i8.wrapping_mul(2i8), -2i8);\n            let val: i8 = -128;\n            assert_eq(val.wrapping_mul(-1i8), -128i8);\n\n            // test Field wrapping mul\n            let six: Field = 6;\n            let seven: Field = 7;\n            let forty_two: Field = 42;\n            let neg_two: Field = -2;\n            let two: Field = 2;\n            let neg_four: Field = -4;\n            assert_eq(six.wrapping_mul(seven), forty_two);\n            assert_eq(neg_two.wrapping_mul(two), neg_four);\n        }\n\n        #[test]\n        fn test_u1_behavior() {\n            // u1 wrapping add is XOR\n            assert_eq(0u1.wrapping_add(0u1), 0u1);\n            assert_eq(0u1.wrapping_add(1u1), 1u1);\n            assert_eq(1u1.wrapping_add(0u1), 1u1);\n            assert_eq(1u1.wrapping_add(1u1), 0u1);\n\n            // u1 wrapping sub is XOR\n            assert_eq(0u1.wrapping_sub(0u1), 0u1);\n            assert_eq(0u1.wrapping_sub(1u1), 1u1);\n            assert_eq(1u1.wrapping_sub(0u1), 1u1);\n            assert_eq(1u1.wrapping_sub(1u1), 0u1);\n\n            // u1 wrapping mul is AND\n            assert_eq(0u1.wrapping_mul(0u1), 0u1);\n            assert_eq(0u1.wrapping_mul(1u1), 0u1);\n            assert_eq(1u1.wrapping_mul(0u1), 0u1);\n            assert_eq(1u1.wrapping_mul(1u1), 1u1);\n        }\n\n        // test wrapping operations is the same as the regular operations\n        #[test]\n        fn test_wrapping_vs_regular() {\n            let u64_large = 0x123456789abcdef0u64;\n            let u128_large = 0x123456789abcdef0123456789abcdef0u128;\n\n            assert_eq(u64_large.wrapping_add(1u64), u64_large + 1u64);\n            assert_eq(u64_large.wrapping_sub(1u64), u64_large - 1u64);\n            assert_eq(u64_large.wrapping_mul(2u64), u64_large * 2u64);\n\n            assert_eq(u128_large.wrapping_add(1u128), u128_large + 1u128);\n            assert_eq(u128_large.wrapping_sub(1u128), u128_large - 1u128);\n            assert_eq(u128_large.wrapping_mul(2u128), u128_large * 2u128);\n        }\n\n        #[test]\n        fn test_field_wrapping_operations() {\n            let zero: Field = 0;\n            let one: Field = 1;\n            let large_val = 0xffffffffffffffff;\n\n            // test Field wrapping operations\n            assert_eq(zero.wrapping_add(one), one);\n            assert_eq(one.wrapping_add(large_val), one + large_val);\n            assert_eq(zero.wrapping_sub(one), -one);\n            assert_eq(one.wrapping_sub(large_val), one - large_val);\n            assert_eq(zero.wrapping_mul(one), zero);\n            assert_eq(one.wrapping_mul(large_val), large_val);\n\n            // test Field basic operations\n            assert_eq(zero.add(one), one);\n            assert_eq(one.add(zero), one);\n            assert_eq(one.sub(one), zero);\n            assert_eq(one.mul(one), one);\n            assert_eq(one.div(one), one);\n            assert_eq(zero.neg(), zero);\n            assert_eq(one.neg(), -one);\n        }\n\n    }\n\n    mod split_functions {\n\n        use crate::ops::arith::{split64, split_into_64_bit_limbs};\n\n        // test split64 and split_into_64_bit_limbs functions\n        #[test]\n        fn test_split_functions() {\n            let small_val = 0x123456789abcdefu128;\n            let large_val = 0x123456789abcdef0123456789abcdef0u128;\n            let max_val = 0xffffffffffffffffffffffffffffffffu128;\n\n            // test split64 (unconstrained)\n            // Safety: testing\n            unsafe {\n                let (lo, hi) = split64(small_val);\n                assert_eq(lo, 0x123456789abcdefu64);\n                assert_eq(hi, 0u64);\n\n                let (lo2, hi2) = split64(large_val);\n                assert_eq(lo2, 0x123456789abcdef0u64);\n                assert_eq(hi2, 0x123456789abcdef0u64);\n            }\n\n            // test split_into_64_bit_limbs (constrained)\n            let (lo3, hi3) = split_into_64_bit_limbs(small_val);\n            assert_eq(lo3, 0x123456789abcdefu64);\n            assert_eq(hi3, 0u64);\n\n            let (lo4, hi4) = split_into_64_bit_limbs(large_val);\n            assert_eq(lo4, 0x123456789abcdef0u64);\n            assert_eq(hi4, 0x123456789abcdef0u64);\n\n            let (lo5, hi5) = split_into_64_bit_limbs(max_val);\n            assert_eq(lo5, 0xffffffffffffffffu64);\n            assert_eq(hi5, 0xffffffffffffffffu64);\n        }\n    }\n}\n","path":"std/ops/arith.nr"},"50":{"source":"use library::{next_witness_wide, vcof_prove_wide, witness_to_pubkey};\nuse std::embedded_curve_ops::EmbeddedCurvePoint;\n\n/// Main entry point for the VCOF update circuit (Grumpkin variant).\n///\n/// Uses the wide derivation path: wn_next = (H(i,w,0) + H(i,w,1) * 2^254) mod l\n/// This ensures the derived witness is unbiased and valid in both Ed25519 and Grumpkin.\n///\n/// For curves where N_SF < N_ed25519 (e.g., BabyJubJub), use vcof_prove_native instead.\nfn main(i: pub Field, wn_prev: Field, pub_prev: pub EmbeddedCurvePoint, pub_next: pub EmbeddedCurvePoint) {\n    vcof_prove_wide(i, wn_prev, pub_prev, pub_next);\n}\n\n// ============================================================================\n// Benchmark Tests (Wide derivation for Grumpkin)\n// ============================================================================\n\n/// Benchmark: Single VCOF update with small values\n#[test]\nfn benchmark_vcof_wide_single_update_small() {\n    let i: Field = 1;\n    let wn_prev: Field = 12345;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_wide(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Benchmark: Single VCOF update with large values (near Ed25519 order)\n#[test]\nfn benchmark_vcof_wide_single_update_large() {\n    // Use a large value that's still < ED25519_ORDER (which is ~2^252)\n    // This is 2^252 - 1 = 0x0FFF... (63 F's)\n    let wn_prev: Field = 0x0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    let i: Field = 999999999;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_wide(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Benchmark: Chain of 5 consecutive VCOF updates\n#[test]\nfn benchmark_vcof_wide_chain_5_updates() {\n    let mut w: Field = 0xabcdef123456789;\n\n    for i in 1..5 {\n        let pub_prev = witness_to_pubkey(w);\n        let w_next = next_witness_wide(i as Field, w);\n        let pub_next = witness_to_pubkey(w_next);\n        vcof_prove_wide(i as Field, w, pub_prev, pub_next);\n        w = w_next;\n    }\n}\n\n/// Benchmark: Chain of 10 consecutive VCOF updates\n#[test]\nfn benchmark_vcof_wide_chain_10_updates() {\n    let mut w: Field = 0xfeedface12345678;\n\n    for i in 1..10 {\n        let pub_prev = witness_to_pubkey(w);\n        let w_next = next_witness_wide(i as Field, w);\n        let pub_next = witness_to_pubkey(w_next);\n        vcof_prove_wide(i as Field, w, pub_prev, pub_next);\n        w = w_next;\n    }\n}\n\n","path":"/home/code/projects/cjs/zeroize-witness/circuits/update/src/main.nr"},"51":{"source":"use dep::bignum;\nuse dep::bignum::bignum::BigNum;\nuse dep::bignum::fields::U512::U512;\nuse dep::poseidon2;\nuse std::ops::Mul;\nuse std::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, fixed_base_scalar_mul};\n\n// Ed25519 scalar field order (l)\n// l = 2^252 + 27742317777372353535851937790883648493\nglobal ED25519_ORDER: Field =\n    0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed;\n\n/// Computes the Ed25519 scalar field order from its mathematical definition.\n/// l = 2^252 + 27742317777372353535851937790883648493\npub fn compute_ed25519_order() -> Field {\n    // 2^252 (1 followed by 63 hex zeros = 252 bits)\n    let two_pow_252: Field = 0x1000000000000000000000000000000000000000000000000000000000000000;\n    // The \"small\" cofactor: 27742317777372353535851937790883648493\n    let cofactor: Field = 0x14def9dea2f79cd65812631a5cf5d3ed;\n    two_pow_252 + cofactor\n}\n\n// 2^254 as U512 limbs for wide multiplication\n// Used in next_witness_wide to combine two hash outputs\n// U512 uses [u128; 5] in little-endian order with 120-bit limbs\n// 2^254 = 2^(2*120 + 14), so it goes in limb 2 at 2^14 = 16384\nglobal SHIFT_2_254_LIMBS: [u128; 5] = [\n    0,     // limb 0 (bits 0-119)\n    0,     // limb 1 (bits 120-239)\n    16384, // limb 2 (bits 240-359): 2^14\n    0,     // limb 3 (bits 360-479)\n    0,     // limb 4 (bits 480+)\n];\n\n/// Asserts that a field value is a valid Ed25519 scalar field element.\n/// i.e. that 0 < value < l (Ed25519 order).\npub fn assert_valid_ed25519_scalar(value: Field) {\n    assert(value != 0, \"Scalar must be non-zero\");\n    // Use Noir's built-in lt check for BN254 field elements\n    // This constrains value < ED25519_ORDER, i.e., 0 < value < l\n    std::field::bn254::assert_lt(value, ED25519_ORDER);\n}\n\n/// Derives the next witness value using a single Poseidon2 hash.\n///\n/// This function is for SNARK fields where N_SF < N_ed25519 (scalar field order smaller\n/// than Ed25519's ~2^253). The result is automatically valid in Ed25519's scalar field\n/// since any value < N_SF is also < N_ed25519.\n///\n/// **Note:** This Noir library runs on BN254/Grumpkin where Field > Ed25519 order.\n/// For this deployment, use `next_witness_wide` instead. This function is provided\n/// for completeness and potential future backends with smaller fields.\n///\n/// # Arguments\n/// * `i` - The update index\n/// * `w` - The current witness value\n///\n/// # Returns\n/// The next witness value H(i || w)\npub fn next_witness_native(i: Field, w: Field) -> Field {\n    poseidon2::bn254::hash_2([i, w])\n}\n\n/// Derives the next witness value using wide Poseidon2 output reduced mod Ed25519 order.\n///\n/// Use this function for SNARK fields where N_SF >= N_ed25519 (scalar field order equal to\n/// or larger than Ed25519's ~2^253). This includes BN254/Grumpkin (~2^254).\n/// Combines two Poseidon2 hash outputs (~508 bits) and reduces mod Ed25519 order\n/// to produce an unbiased result valid in both fields.\n///\n/// **This is the correct function for this Noir deployment (BN254/Grumpkin).**\n///\n/// # Arguments\n/// * `i` - The update index\n/// * `w` - The current witness value\n///\n/// # Returns\n/// The next witness value: (H(i,w,0) + H(i,w,1) * 2^254) mod l\n///\n/// # Bias\n/// Statistical distance from uniform is ~2^(-254), cryptographically negligible.\n///\npub fn next_witness_wide(i: Field, w: Field) -> Field {\n    // Two Poseidon2 hashes with domain separation for ~508 bits of entropy\n    let h0 = poseidon2::bn254::hash_3([i, w, 0]);\n    let h1 = poseidon2::bn254::hash_3([i, w, 1]);\n\n    // Batch all BigNum operations in unconstrained to avoid ACIR/Brillig subgraph warnings.\n    // The computation is: result = (h0 + h1 * 2^254) mod ED25519_ORDER\n    // Safety: The unconstrained computation is verified by `verify_wide_mod_reduction`\n    // which proves the modular reduction equation holds.\n    let (result, quotient) = unsafe { compute_wide_mod_with_quotient(h0, h1) };\n\n    // Constrain the result by verifying the modular reduction equation:\n    // h0 + h1 * 2^254 = quotient * ED25519_ORDER + result\n    // This proves result is the correct remainder, not just any value < ED25519_ORDER.\n    verify_wide_mod_reduction(h0, h1, quotient, result);\n\n    result\n}\n\n/// Unconstrained helper that computes (h0 + h1 * 2^254) mod ED25519_ORDER\n/// and returns both the result and the quotient for verification.\nunconstrained fn compute_wide_mod_with_quotient(h0: Field, h1: Field) -> (Field, U512) {\n    let h0_wide: U512 = U512::from(h0);\n    let h1_wide: U512 = U512::from(h1);\n    let shift: U512 = U512::from_limbs(SHIFT_2_254_LIMBS);\n    let ed25519_order: U512 = U512::from(ED25519_ORDER);\n\n    let h1_shifted: U512 = h1_wide.mul(shift);\n    let wide: U512 = h0_wide + h1_shifted;\n\n    // Get both quotient and remainder using udiv_mod\n    let (quotient, reduced): (U512, U512) = wide.udiv_mod(ed25519_order);\n\n    let result: Field = bignum::bignum::to_field(reduced);\n    (result, quotient)\n}\n\n// Constants for limb-to-Field reconstruction\n// U512 uses 120-bit limbs in little-endian order\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000; // 2^120\n\n/// Converts a Field to U512 limbs in unconstrained code.\nunconstrained fn field_to_u512_limbs(f: Field) -> [u128; 5] {\n    let u: U512 = U512::from(f);\n    u.get_limbs()\n}\n\n/// Converts a Field to U512 using unconstrained limb computation + constrained validation.\n/// This avoids the internal Brillig validation in U512::from that causes subgraph warnings.\nfn field_to_u512_constrained(f: Field) -> U512 {\n    // Safety: Limbs are validated by reconstructing the Field and checking equality below.\n    let limbs = unsafe { field_to_u512_limbs(f) };\n    let u: U512 = U512::from_limbs(limbs);\n\n    // Validate the conversion by reconstructing Field from limbs\n    // For BN254 fields (< 2^254), only limbs 0, 1, 2 are used; limbs 3, 4 must be 0\n    assert(limbs[3] == 0, \"Limb 3 must be 0 for BN254 field\");\n    assert(limbs[4] == 0, \"Limb 4 must be 0 for BN254 field\");\n\n    // Reconstruct: f = l0 + l1 * 2^120 + l2 * 2^240\n    let l0: Field = limbs[0] as Field;\n    let l1: Field = limbs[1] as Field;\n    let l2: Field = limbs[2] as Field;\n    let reconstructed: Field = l0 + l1 * TWO_POW_120 + l2 * TWO_POW_120 * TWO_POW_120;\n    assert(reconstructed == f, \"Field to U512 conversion mismatch\");\n\n    u\n}\n\n/// Constrains that: h0 + h1 * 2^254 = quotient * ED25519_ORDER + result\n/// This verifies the modular reduction was computed correctly.\nfn verify_wide_mod_reduction(h0: Field, h1: Field, quotient: U512, result: Field) {\n    // Convert inputs to U512 using the warning-free conversion\n    let h0_wide: U512 = field_to_u512_constrained(h0);\n    let h1_wide: U512 = field_to_u512_constrained(h1);\n    let shift: U512 = U512::from_limbs(SHIFT_2_254_LIMBS);\n    let ed25519_order: U512 = field_to_u512_constrained(ED25519_ORDER);\n    let result_wide: U512 = field_to_u512_constrained(result);\n\n    // Compute left side: h0 + h1 * 2^254\n    let h1_shifted: U512 = h1_wide.mul(shift);\n    let lhs: U512 = h0_wide + h1_shifted;\n\n    // Compute right side: quotient * ED25519_ORDER + result\n    let q_times_order: U512 = quotient.mul(ed25519_order);\n    let rhs: U512 = q_times_order + result_wide;\n\n    // Verify equality\n    assert(lhs == rhs, \"Wide mod reduction verification failed\");\n\n    // Verify result < ED25519_ORDER (proves it's the canonical remainder)\n    std::field::bn254::assert_lt(result, ED25519_ORDER);\n}\n\n/// VCOF prove circuit using native (single hash) derivation.\n///\n/// This function is for SNARK fields where N_SF < N_ed25519 (scalar field order smaller\n/// than Ed25519's ~2^253).\n///\n/// **Note:** This Noir library runs on BN254/Grumpkin where Field > Ed25519 order.\n/// For this deployment, use `vcof_prove_wide` instead. This function is provided\n/// for completeness and potential future backends with smaller fields.\n///\n/// Implements VcofProve from the Grease protocol specification. Proves that:\n/// 1. The prover knows wn_prev corresponding to pub_prev\n/// 2. wn_next was correctly derived via wn_next = H(i || wn_prev)\n/// 3. pub_next corresponds to wn_next\n///\n/// # Public Inputs\n/// - `i`: The update index (caller must ensure `i <= u64::MAX`)\n/// - `pub_prev`: Public key for the previous witness (wn_prev * G on embedded curve)\n/// - `pub_next`: Public key for the next witness (wn_next * G on embedded curve)\n///\n/// # Private Inputs (witnesses)\n/// - `wn_prev`: The previous witness value (must be non-zero)\n///\n/// # Security\n/// - Consecutiveness: wn_next is derived deterministically from wn_prev\n/// - One-wayness: Cannot derive wn_prev from wn_next (Poseidon2 preimage resistance)\n/// - Verifiability: Public keys commit to witness values via discrete log\n/// - Zero rejection: Zero witnesses are rejected to prevent identity point attacks\npub fn vcof_prove_native(i: Field, wn_prev: Field, pub_prev: EmbeddedCurvePoint, pub_next: EmbeddedCurvePoint) {\n    // Reject zero witness to prevent identity point attacks\n    assert(wn_prev != 0, \"Previous witness must be non-zero\");\n    assert(i != 0, \"Index must be non-zero\");\n\n    // Verify pub_prev = wn_prev * G (proves knowledge of wn_prev)\n    let computed_prev = fixed_base_scalar_mul(EmbeddedCurveScalar::from_field(wn_prev));\n    assert(computed_prev == pub_prev, \"pub_prev does not match wn_prev * G\");\n\n    // Compute wn_next = H(i || wn_prev) using native single-hash derivation\n    let wn_next = next_witness_native(i, wn_prev);\n\n    // Reject zero derived witness (defensive - extremely unlikely from Poseidon2)\n    assert(wn_next != 0, \"Derived witness must be non-zero\");\n\n    // Verify pub_next = wn_next * G\n    let computed_next = fixed_base_scalar_mul(EmbeddedCurveScalar::from_field(wn_next));\n    assert(computed_next == pub_next, \"pub_next does not match wn_next * G\");\n}\n\n/// VCOF prove circuit using wide (double hash + reduction) derivation.\n///\n/// Use this for SNARK fields where N_SF >= N_ed25519 (scalar field order equal to or larger\n/// than Ed25519's ~2^253). This includes BN254/Grumpkin (~2^254).\n/// This ensures the derived witness is unbiased and valid in both Ed25519 and the SNARK field.\n///\n/// **This is the correct function for this Noir deployment (BN254/Grumpkin).**\n///\n/// Implements VcofProve from the Grease protocol specification. Proves that:\n/// 1. The prover knows wn_prev corresponding to pub_prev\n/// 2. wn_next was correctly derived via wn_next = (H(i,w,0) + H(i,w,1) * 2^254) mod l\n/// 3. pub_next corresponds to wn_next\n///\n/// # Public Inputs\n/// - `i`: The update index (caller must ensure `i <= u64::MAX`)\n/// - `pub_prev`: Public key for the previous witness (wn_prev * G on Grumpkin)\n/// - `pub_next`: Public key for the next witness (wn_next * G on Grumpkin)\n///\n/// # Private Inputs (witnesses)\n/// - `wn_prev`: The previous witness value (must be valid Ed25519 scalar: 0 < wn_prev < l)\n///\n/// # Security\n/// - Consecutiveness: wn_next is derived deterministically from wn_prev\n/// - One-wayness: Cannot derive wn_prev from wn_next (Poseidon2 preimage resistance)\n/// - Verifiability: Public keys commit to witness values via discrete log\n/// - Zero rejection: Zero witnesses are rejected to prevent identity point attacks\n/// - Unbiased: Statistical distance from uniform is ~2^(-254)\n/// - Range checked: wn_prev must be a valid Ed25519 scalar\npub fn vcof_prove_wide(i: Field, wn_prev: Field, pub_prev: EmbeddedCurvePoint, pub_next: EmbeddedCurvePoint) {\n    // Validate wn_prev is a valid Ed25519 scalar (0 < wn_prev < l)\n    // This is critical for Grumpkin where Field can hold values > Ed25519 order\n    assert_valid_ed25519_scalar(wn_prev);\n    // Reject zero index\n    assert(i != 0, \"Index must be non-zero\");\n\n    // Verify pub_prev = wn_prev * G (proves knowledge of wn_prev)\n    let computed_prev = fixed_base_scalar_mul(EmbeddedCurveScalar::from_field(wn_prev));\n    assert(computed_prev == pub_prev, \"pub_prev does not match wn_prev * G\");\n\n    // Compute wn_next using wide derivation with Ed25519 order reduction\n    let wn_next = next_witness_wide(i, wn_prev);\n\n    // Reject zero derived witness (defensive - extremely unlikely from Poseidon2)\n    assert(wn_next != 0, \"Derived witness must be non-zero\");\n    // Verify pub_next = wn_next * G\n    let computed_next = fixed_base_scalar_mul(EmbeddedCurveScalar::from_field(wn_next));\n    assert(computed_next == pub_next, \"pub_next does not match wn_next * G\");\n}\n\n// ============================================================================\n// Tests\n// ============================================================================\n\n/// Helper function to compute public key from witness value (w * G)\npub fn witness_to_pubkey(w: Field) -> EmbeddedCurvePoint {\n    fixed_base_scalar_mul(EmbeddedCurveScalar::from_field(w))\n}\n\n// ============================================================================\n// Tests for Ed25519 order constant\n// ============================================================================\n\n/// Test: Verify ED25519_ORDER constant matches computed value from definition\n/// l = 2^252 + 27742317777372353535851937790883648493\n#[test]\nfn test_ed25519_order_matches_computed() {\n    let computed = compute_ed25519_order();\n    assert(computed == ED25519_ORDER, \"ED25519_ORDER constant doesn't match computed value\");\n}\n\n/// Test: Verify ED25519_ORDER hex matches the known decimal representation\n/// The decimal value is: 7237005577332262213973186563042994240857116359379907606001950938285454250989\n#[test]\nfn test_ed25519_order_known_value() {\n    // Verify against the well-known hex representation\n    let expected: Field = 0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed;\n    assert(ED25519_ORDER == expected, \"ED25519_ORDER doesn't match expected hex value\");\n\n    // Verify the computed value also matches\n    let computed = compute_ed25519_order();\n    assert(computed == expected, \"Computed Ed25519 order doesn't match expected hex value\");\n}\n\n// ============================================================================\n// Tests for next_witness_native (single hash path)\n// ============================================================================\n\n/// Test: Native witness derivation produces consistent results\n#[test]\nfn test_next_witness_native_deterministic() {\n    let i = 1;\n    let w: Field = 12345;\n\n    let result1 = next_witness_native(i, w);\n    let result2 = next_witness_native(i, w);\n\n    assert(result1 == result2);\n}\n\n/// Test: Native witness derivation with different indices produces different results\n#[test]\nfn test_next_witness_native_different_indices() {\n    let w: Field = 12345;\n\n    let result1 = next_witness_native(1, w);\n    let result2 = next_witness_native(2, w);\n\n    assert(result1 != result2);\n}\n\n/// Test: vcof_prove_native accepts valid inputs\n#[test]\nfn test_vcof_prove_native_valid_derivation() {\n    let i = 1;\n    let wn_prev: Field = 12345;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_native(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_native(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Test: vcof_prove_native with large index\n#[test]\nfn test_vcof_prove_native_large_index() {\n    let i = 999999;\n    let wn_prev: Field = 0xdeadbeef;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_native(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_native(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Test: vcof_prove_native chained updates\n#[test]\nfn test_vcof_prove_native_chained_updates() {\n    let w0: Field = 0xabcdef123456;\n\n    let i1 = 1;\n    let pub0 = witness_to_pubkey(w0);\n    let w1 = next_witness_native(i1, w0);\n    let pub1 = witness_to_pubkey(w1);\n    vcof_prove_native(i1, w0, pub0, pub1);\n\n    let i2 = 2;\n    let pub1_check = witness_to_pubkey(w1);\n    let w2 = next_witness_native(i2, w1);\n    let pub2 = witness_to_pubkey(w2);\n    vcof_prove_native(i2, w1, pub1_check, pub2);\n}\n\n/// Test: vcof_prove_native rejects zero witness\n#[test(should_fail)]\nfn test_vcof_prove_native_rejects_zero_witness() {\n    let i = 1;\n    let wn_prev: Field = 0;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_native(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_native(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Test: vcof_prove_native rejects zero index\n#[test(should_fail)]\nfn test_vcof_prove_native_rejects_zero_index() {\n    let i = 0;\n    let wn_prev: Field = 0xfeedface;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_native(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_native(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Test: vcof_prove_native rejects wrong pub_next\n#[test(should_fail)]\nfn test_vcof_prove_native_rejects_wrong_pub_next() {\n    let i = 1;\n    let wn_prev: Field = 12345;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wrong_pub_next = witness_to_pubkey(0xbadbeef);\n\n    vcof_prove_native(i, wn_prev, pub_prev, wrong_pub_next);\n}\n\n// ============================================================================\n// Tests for next_witness_wide (double hash + reduction path)\n// ============================================================================\n\n/// Test: Wide witness derivation produces consistent results\n#[test]\nfn test_next_witness_wide_deterministic() {\n    let i = 1;\n    let w: Field = 12345;\n\n    let result1 = next_witness_wide(i, w);\n    let result2 = next_witness_wide(i, w);\n\n    assert(result1 == result2);\n}\n\n/// Test: Wide witness derivation with different indices produces different results\n#[test]\nfn test_next_witness_wide_different_indices() {\n    let w: Field = 12345;\n\n    let result1 = next_witness_wide(1, w);\n    let result2 = next_witness_wide(2, w);\n\n    assert(result1 != result2);\n}\n\n/// Test: Wide witness derivation produces value less than Ed25519 order\n#[test]\nfn test_next_witness_wide_within_ed25519_order() {\n    let i = 1;\n    let w: Field = 0xdeadbeef;\n\n    let result = next_witness_wide(i, w);\n\n    // Result should be < ED25519_ORDER (verified by assert_lt in next_witness_wide)\n    // Also verify it's non-zero\n    assert(result != 0);\n}\n\n/// Test: vcof_prove_wide accepts valid inputs\n#[test]\nfn test_vcof_prove_wide_valid_derivation() {\n    let i = 1;\n    let wn_prev: Field = 12345;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_wide(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Test: vcof_prove_wide with large index\n#[test]\nfn test_vcof_prove_wide_large_index() {\n    let i = 999999;\n    let wn_prev: Field = 0xdeadbeef;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_wide(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Test: vcof_prove_wide chained updates\n#[test]\nfn test_vcof_prove_wide_chained_updates() {\n    let w0: Field = 0xabcdef123456;\n\n    let i1 = 1;\n    let pub0 = witness_to_pubkey(w0);\n    let w1 = next_witness_wide(i1, w0);\n    let pub1 = witness_to_pubkey(w1);\n    vcof_prove_wide(i1, w0, pub0, pub1);\n\n    let i2 = 2;\n    let pub1_check = witness_to_pubkey(w1);\n    let w2 = next_witness_wide(i2, w1);\n    let pub2 = witness_to_pubkey(w2);\n    vcof_prove_wide(i2, w1, pub1_check, pub2);\n\n    let i3 = 3;\n    let pub2_check = witness_to_pubkey(w2);\n    let w3 = next_witness_wide(i3, w2);\n    let pub3 = witness_to_pubkey(w3);\n    vcof_prove_wide(i3, w2, pub2_check, pub3);\n}\n\n/// Test: vcof_prove_wide rejects zero witness\n#[test(should_fail)]\nfn test_vcof_prove_wide_rejects_zero_witness() {\n    let i = 1;\n    let wn_prev: Field = 0;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_wide(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Test: vcof_prove_wide rejects zero index\n#[test(should_fail)]\nfn test_vcof_prove_wide_rejects_zero_index() {\n    let i = 0;\n    let wn_prev: Field = 0xfeedface;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_wide(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Test: vcof_prove_wide rejects wrong pub_next\n#[test(should_fail)]\nfn test_vcof_prove_wide_rejects_wrong_pub_next() {\n    let i = 1;\n    let wn_prev: Field = 12345;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wrong_pub_next = witness_to_pubkey(0xbadbeef);\n\n    vcof_prove_wide(i, wn_prev, pub_prev, wrong_pub_next);\n}\n\n/// Test: vcof_prove_wide rejects swapped pubkeys\n#[test(should_fail)]\nfn test_vcof_prove_wide_rejects_swapped_pubkeys() {\n    let i = 1;\n    let wn_prev: Field = 12345;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_wide(i, wn_prev, pub_next, pub_prev);\n}\n\n/// Test: vcof_prove_wide rejects witness >= Ed25519 order\n#[test(should_fail)]\nfn test_vcof_prove_wide_rejects_witness_above_ed25519_order() {\n    let i = 1;\n    // ED25519_ORDER is the maximum valid value + 1, so using it should fail\n    let wn_prev: Field = ED25519_ORDER;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_wide(i, wn_prev, pub_prev, pub_next);\n}\n\n/// Test: vcof_prove_wide accepts witness at Ed25519 order - 1\n#[test]\nfn test_vcof_prove_wide_accepts_max_valid_witness() {\n    let i = 1;\n    // ED25519_ORDER - 1 is the maximum valid scalar\n    let wn_prev: Field = ED25519_ORDER - 1;\n\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    vcof_prove_wide(i, wn_prev, pub_prev, pub_next);\n}\n\n// ============================================================================\n// Tests verifying native and wide produce different results\n// ============================================================================\n\n/// Test: Native and wide derivations produce different results (as expected)\n/// This confirms the two paths are distinct implementations.\n#[test]\nfn test_native_and_wide_produce_different_results() {\n    let i = 1;\n    let w: Field = 12345;\n\n    let native_result = next_witness_native(i, w);\n    let wide_result = next_witness_wide(i, w);\n\n    // They should be different because:\n    // - native: H(i || w)\n    // - wide: (H(i,w,0) + H(i,w,1) * 2^254) mod l\n    assert(native_result != wide_result);\n}\n\n// ============================================================================\n// Test Vector Generation\n// ============================================================================\n\n/// Generates a single test vector using native derivation (for smaller SNARK fields).\nfn generate_single_vector_native(i: Field, wn_prev: Field) {\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_native(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    let pub_prev_x = pub_prev.x;\n    let pub_prev_y = pub_prev.y;\n    let pub_next_x = pub_next.x;\n    let pub_next_y = pub_next.y;\n\n    println(f\"VECTOR|0|{i}\");\n    println(f\"VECTOR|1|{wn_prev}\");\n    println(f\"VECTOR|2|{wn_next}\");\n    println(f\"VECTOR|3|{pub_prev_x}\");\n    println(f\"VECTOR|4|{pub_prev_y}\");\n    println(f\"VECTOR|5|{pub_next_x}\");\n    println(f\"VECTOR|6|{pub_next_y}\");\n    println(\"VECTOR|END\");\n}\n\n/// Generates a single test vector using wide derivation (for BN254/Grumpkin).\nfn generate_single_vector_wide(i: Field, wn_prev: Field) {\n    let pub_prev = witness_to_pubkey(wn_prev);\n    let wn_next = next_witness_wide(i, wn_prev);\n    let pub_next = witness_to_pubkey(wn_next);\n\n    let pub_prev_x = pub_prev.x;\n    let pub_prev_y = pub_prev.y;\n    let pub_next_x = pub_next.x;\n    let pub_next_y = pub_next.y;\n\n    println(f\"VECTOR|0|{i}\");\n    println(f\"VECTOR|1|{wn_prev}\");\n    println(f\"VECTOR|2|{wn_next}\");\n    println(f\"VECTOR|3|{pub_prev_x}\");\n    println(f\"VECTOR|4|{pub_prev_y}\");\n    println(f\"VECTOR|5|{pub_next_x}\");\n    println(f\"VECTOR|6|{pub_next_y}\");\n    println(\"VECTOR|END\");\n}\n\n/// VECTOR GENERATOR - Native derivation for smaller SNARK fields (N_SF < N_ed25519)\n/// Run with: nargo test generate_test_vectors_native --show-output\n/// Note: Native derivation is not appropriate for BN254/Grumpkin deployment.\n#[test]\nfn generate_test_vectors_native() {\n    println(\"=== BEGIN TEST VECTORS (NATIVE) ===\");\n    println(\"HEADER,i,wn_prev,wn_next,pub_prev_x,pub_prev_y,pub_next_x,pub_next_y\");\n\n    let seeds: [Field; 10] = [\n        0x12345,\n        0xdeadbeef,\n        0xfeedface,\n        0xabcdef123456,\n        0x1,\n        0xffffffff,\n        0x123456789abcdef,\n        0x9999999999,\n        0x2523648240000001ba344d80000000086121000000000013a700000000000012,\n        0x42424242,\n    ];\n\n    for seed in seeds {\n        generate_single_vector_native(1, seed);\n    }\n\n    for seed in seeds {\n        generate_single_vector_native(420, seed);\n    }\n\n    println(\"=== END TEST VECTORS (NATIVE) ===\");\n}\n\n/// VECTOR GENERATOR - Wide derivation for larger SNARK fields (N_SF >= N_ed25519)\n/// Run with: nargo test generate_test_vectors_wide --show-output\n/// This is the correct derivation for BN254/Grumpkin deployment.\n#[test]\nfn generate_test_vectors_wide() {\n    println(\"=== BEGIN TEST VECTORS (WIDE - BN254/Grumpkin) ===\");\n    println(\"HEADER,i,wn_prev,wn_next,pub_prev_x,pub_prev_y,pub_next_x,pub_next_y\");\n\n    let seeds: [Field; 10] = [\n        0x12345,\n        0xdeadbeef,\n        0xfeedface,\n        0xabcdef123456,\n        0x1,\n        0xffffffff,\n        0x123456789abcdef,\n        0x9999999999,\n        0x2523648240000001ba344d80000000086121000000000013a700000000000012,\n        0x42424242,\n    ];\n\n    for seed in seeds {\n        generate_single_vector_wide(1, seed);\n    }\n\n    for seed in seeds {\n        generate_single_vector_wide(420, seed);\n    }\n\n    println(\"=== END TEST VECTORS (WIDE) ===\");\n}\n\n/// VECTOR GENERATOR - Chain test vectors using native derivation (smaller SNARK fields)\n/// Note: Native derivation is not appropriate for BN254/Grumpkin deployment.\n#[test]\nfn generate_chain_test_vectors_native() {\n    println(\"=== BEGIN CHAIN TEST VECTORS (NATIVE) ===\");\n    println(\"HEADER,i,wn_prev,wn_next,pub_prev_x,pub_prev_y,pub_next_x,pub_next_y\");\n\n    let mut w: Field = 0xabcdef123456789;\n\n    for i in 1..11 {\n        generate_single_vector_native(i as Field, w);\n        w = next_witness_native(i as Field, w);\n    }\n\n    println(\"=== END CHAIN TEST VECTORS (NATIVE) ===\");\n}\n\n/// VECTOR GENERATOR - Chain test vectors using wide derivation (BN254/Grumpkin)\n/// This is the correct derivation for BN254/Grumpkin deployment.\n#[test]\nfn generate_chain_test_vectors_wide() {\n    println(\"=== BEGIN CHAIN TEST VECTORS (WIDE - BN254/Grumpkin) ===\");\n    println(\"HEADER,i,wn_prev,wn_next,pub_prev_x,pub_prev_y,pub_next_x,pub_next_y\");\n\n    let mut w: Field = 0xabcdef123456789;\n\n    for i in 1..11 {\n        generate_single_vector_wide(i as Field, w);\n        w = next_witness_wide(i as Field, w);\n    }\n\n    println(\"=== END CHAIN TEST VECTORS (WIDE) ===\");\n}\n","path":"/home/code/projects/cjs/zeroize-witness/circuits/library/src/lib.nr"},"54":{"source":"use crate::fns::constrained_ops::limbs_to_field;\nuse crate::params::BigNumParams;\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub trait BigNum: Neg + Add + Sub + Mul + Div + Eq {\n    let N: u32;\n    let MOD_BITS: u32;\n\n    fn params() -> BigNumParams<N, MOD_BITS>;\n    fn modulus_bits(_: Self) -> u32;\n    fn num_limbs(_: Self) -> u32;\n    fn modulus() -> Self;\n\n    fn new() -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn from_limbs(limbs: [u128; N]) -> Self;\n    fn get_limbs(self) -> [u128; N];\n    fn set_limb(self: &mut Self, idx: u32, value: u128);\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    fn from_be_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n    fn from_le_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n\n    fn get_limb(self: Self, idx: u32) -> u128 {\n        self.get_limbs()[idx]\n    }\n\n    unconstrained fn __eq(self: Self, other: Self) -> bool;\n\n    unconstrained fn __is_zero(self: Self) -> bool;\n\n    unconstrained fn __neg(self) -> Self;\n    unconstrained fn __add(self, other: Self) -> Self;\n    unconstrained fn __sub(self, other: Self) -> Self;\n    unconstrained fn __mul(self, other: Self) -> Self;\n    unconstrained fn __sqr(self) -> Self;\n    unconstrained fn __div(self, other: Self) -> Self;\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    unconstrained fn __invmod(self) -> Self;\n    unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n    unconstrained fn __sqrt(self) -> std::option::Option<Self>;\n\n    fn assert_is_not_equal(self: Self, other: Self);\n\n    fn validate_in_range(self);\n    fn validate_in_field(self);\n\n    fn sqr(self) -> Self;\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    fn udiv(self, divisor: Self) -> Self;\n    fn umod(self, divisor: Self) -> Self;\n\n    fn is_zero(self) -> bool;\n    fn is_zero_integer(self) -> bool;\n    fn assert_is_not_zero(self);\n    fn assert_is_not_zero_integer(self);\n}\n\n// we need macros that implement the BigNum, Default, From, Neg, Add, Sub, Mul, Div, Eq, Ord traits for each bignum type\npub comptime fn derive_bignum(\n    strukt: TypeDefinition,\n    N: u32,\n    MOD_BITS: u32,\n    params: Quoted,\n) -> Quoted {\n    let constrained_ops = quote { $crate::fns::constrained_ops };\n    let unconstrained_ops = quote { $crate::fns::unconstrained_ops };\n    let typ = strukt.as_type();\n    let serialization = quote { $crate::fns::serialization };\n    quote {\n\n        // implement BigNum for BigNum \n        impl $crate::BigNum for $typ {\n            let N: u32 = $N; \n            let MOD_BITS: u32 = $MOD_BITS;\n            \n            fn modulus_bits(_: Self) -> u32 {\n                $MOD_BITS\n            }\n            \n            fn num_limbs(_: Self) -> u32 {\n                $N\n            }\n\n            fn modulus() -> Self {\n                Self { limbs: Self::params().modulus }\n            }\n\n            fn new() -> Self {\n                Self {limbs: [0; $N]}\n            }\n\n            fn params() -> $crate::params::BigNumParams<$N, $MOD_BITS> {\n                $params\n            }\n\n            fn from_limbs(limbs: [u128; $N]) -> Self {\n                Self { limbs }\n            }\n\n            fn get_limbs(self: Self) -> [u128; $N] {\n                self.limbs\n            }\n\n            fn set_limb(self: &mut Self, idx: u32, value: u128) {\n                self.limbs[idx] = value;\n            }\n\n            fn zero() -> Self {\n                Self { limbs: [0; $N] }\n            }\n\n            fn one() -> Self {\n                let mut limbs = [0; $N];\n                limbs[0] = 1;\n                Self { limbs }\n            }\n\n            fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                $typ::from_limbs($constrained_ops::derive_from_seed::<_, $MOD_BITS, _>(params, seed))\n            }\n\n            unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                Self { limbs: $unconstrained_ops::__derive_from_seed::<_, $MOD_BITS, _>(params, seed) }\n            }\n\n            fn from_be_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_be_bytes::<_, $MOD_BITS>(x) }\n            }\n            \n            fn to_be_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_be_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            fn from_le_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_le_bytes::<_, $MOD_BITS>(x) }\n            }\n\n            fn to_le_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_le_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            unconstrained fn __eq(self: Self, other: Self) -> bool {\n                $crate::fns::unconstrained_ops::__eq(self.get_limbs(), other.get_limbs())\n            }\n\n            unconstrained fn __is_zero(self: Self) -> bool {\n                $crate::fns::unconstrained_ops::__is_zero(self.get_limbs())\n            }\n\n            unconstrained fn __neg(self: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__neg(params.modulus, self.get_limbs())}\n            }\n\n            unconstrained fn __add(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__add(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __sub(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__sub(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __mul(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__mul(params, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __sqr(self: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__sqr(params, self.get_limbs()) }\n            }\n\n            unconstrained fn __div(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__div(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            unconstrained fn __udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let (q, r) = $unconstrained_ops::__udiv_mod(self.get_limbs(), divisor.get_limbs());\n                (Self{limbs: q}, Self{limbs: r})\n            }\n\n            unconstrained fn __invmod(self: Self) -> Self {\n                let params = Self::params();\n                assert(params.has_multiplicative_inverse);\n                Self {limbs: $unconstrained_ops::__invmod(params, self.get_limbs())}\n            }\n\n            unconstrained fn __pow(self: Self, exponent: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__pow(params, self.get_limbs(), exponent.get_limbs())}\n            }\n\n            #[deprecated(\"use __sqrt\")]\n            unconstrained fn __tonelli_shanks_sqrt(self: Self) -> std::option::Option<Self> {\n                let params = Self::params();\n                let maybe_limbs = $unconstrained_ops::__sqrt(params, self.get_limbs());\n                maybe_limbs.map(|limbs| Self {limbs: limbs})\n            }\n\n            unconstrained fn __sqrt(self: Self) -> std::option::Option<Self> {\n                let params = Self::params();\n                let maybe_limbs = $unconstrained_ops::__sqrt(params, self.get_limbs());\n                maybe_limbs.map(|limbs| Self {limbs: limbs })\n            }\n\n            fn assert_is_not_equal(self: Self, other: Self) {\n                let params = Self::params();\n                $crate::fns::constrained_ops::assert_is_not_equal(\n                    params,\n                    self.get_limbs(),\n                    other.get_limbs(),\n                );\n            }\n\n            fn validate_in_field(self: Self) {\n                let params = Self::params();\n                $constrained_ops::validate_in_field::<_, $MOD_BITS>(params, self.get_limbs());\n            }\n\n            fn validate_in_range(self: Self) {\n                $constrained_ops::validate_in_range::<_, _, $MOD_BITS>(self.get_limbs());\n            }\n\n            fn sqr(self: Self) -> Self {\n                let params = Self::params();\n                Self { limbs: $constrained_ops::sqr::<$N, $MOD_BITS>(params, self.get_limbs()) }\n            }\n\n            fn udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let (q, r) = $constrained_ops::udiv_mod::<$N, $MOD_BITS>(self.get_limbs(), divisor.get_limbs());\n                (Self {limbs: q}, Self {limbs: r})\n            }\n\n            fn udiv(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::udiv::<$N, $MOD_BITS>(self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn umod(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::umod::<$N, $MOD_BITS>(self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn is_zero(self: Self) -> bool {\n                let params = Self::params();\n                $constrained_ops::is_zero::<$N, $MOD_BITS>(params, self.get_limbs())\n            }\n\n            fn is_zero_integer(self: Self) -> bool {\n                $constrained_ops::is_zero_integer(self.get_limbs())\n            }\n\n            fn assert_is_not_zero(self: Self) {\n                let params = Self::params();\n                $constrained_ops::assert_is_not_zero::<$N, $MOD_BITS>(params, self.get_limbs());\n            }\n\n            fn assert_is_not_zero_integer(self: Self) {\n                $constrained_ops::assert_is_not_zero_integer(self.get_limbs());\n            }\n        }\n\n        // implement Default for BigNum\n        impl Default for $typ {\n            fn default() -> Self {\n                $typ::from_limbs([0; $N])\n            }\n        }\n\n        impl std::convert::From<Field> for $typ {\n            fn from(input: Field) -> Self {\n                $typ { limbs: $constrained_ops::from_field::<$N, $MOD_BITS>($params, input) }\n            }\n        }\n\n        impl std::ops::Neg for $typ {\n            fn neg(self) -> Self {\n                $typ { limbs: $constrained_ops::neg::<$N, $MOD_BITS>($params, self.limbs) }\n            }\n        }\n\n        impl std::ops::Add for $typ {\n            fn add(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::add::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Sub for $typ {\n            fn sub(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::sub::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Mul for $typ {\n            fn mul(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::mul::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Div for $typ {\n            fn div(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::div::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::cmp::Eq for $typ {\n            fn eq(self, other: Self) -> bool {\n                $constrained_ops::eq::<$N, $MOD_BITS>($params, self.limbs, other.limbs)\n            }\n        }\n\n        impl std::cmp::Ord for $typ {\n            fn cmp(self, other: Self) -> std::cmp::Ordering {\n                $constrained_ops::cmp::<$N, $MOD_BITS>(self.limbs, other.limbs)\n            }\n        }\n\n    }\n}\n\npub fn conditional_select<T: BigNum>(lhs: T, rhs: T, predicate: bool) -> T {\n    if predicate {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub unconstrained fn compute_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (T, T) {\n    let params = T::params();\n    let (q_limbs, r_limbs) = crate::fns::expressions::__compute_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    );\n    (T::from_limbs(q_limbs), T::from_limbs(r_limbs))\n}\n\npub fn evaluate_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    let params = T::params();\n    crate::fns::expressions::evaluate_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    )\n}\n\npub unconstrained fn batch_invert<T: BigNum, let M: u32>(x: [T; M]) -> [T; M] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert(params, x.map(|bn: T| bn.get_limbs())).map(|limbs| {\n        T::from_limbs(limbs)\n    })\n}\n\npub unconstrained fn batch_invert_slice<T: BigNum>(x: [T]) -> [T] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert_slice(params, x.map(|bn: T| bn.get_limbs()))\n        .map(|limbs| T::from_limbs(limbs))\n}\n\npub fn to_field<T: BigNum>(bn: T) -> Field {\n    let params = T::params();\n    limbs_to_field(params, bn.get_limbs())\n}\n","path":"/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/bignum.nr"},"86":{"source":"use crate::constants::{GRUMPKIN_MODULUS, TWO_POW_120, TWO_POW_240};\n\nuse crate::fns::{\n    expressions::{evaluate_quadratic_expression, validate_udiv_mod_expression},\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags,\n        __validate_gte_with_flags, __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sqr, __sub, __udiv_mod},\n};\n\nuse crate::params::BigNumParams;\n\nuse std::cmp::Ordering;\n\n/// Lift the limbs of a `BigNum` value onto the circuit `Field`\n///\n/// Descent the `BigNum` value back into the `Field` and\n///    - check that it's a proper `BigNum` value\n///    - validate the limbs sum up to a `Field` value\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: BigNumParams<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    validate_in_range::<u128, N, MOD_BITS>(limbs);\n    if N > 2 {\n        // validate that the `BigNum` is less than the Grumpkin modulus\n        let mut grumpkin_modulus: [u128; N] = [0; N];\n        grumpkin_modulus[0] = GRUMPKIN_MODULUS[0];\n        grumpkin_modulus[1] = GRUMPKIN_MODULUS[1];\n        grumpkin_modulus[2] = GRUMPKIN_MODULUS[2];\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n    }\n\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        (limbs[0] as Field) + (limbs[1] as Field) * (TWO_POW_120 as Field)\n    } else {\n        (limbs[0] as Field)\n            + (limbs[1] as Field) * (TWO_POW_120 as Field)\n            + (limbs[2] as Field) * TWO_POW_240\n    }\n}\n\n/// Construct a `BigNum` value from a native `Field`\n///\n/// Decomposes the `Field` value into 120-bit limbs\n/// then we have three cases:\n///     - MOD_BITS < 253 (grumpkin_mod_bits - 1): it is enough to call for `validate_in_field`, which is basically `val <= MOD`\n///     - MOD_BITS > 253: we need to verify that the obtained `BigNum` `val < GRUMPKIN_MODULUS`\n///     - MOD_BITS = 253: verify that `val < min(MOD, GRUMPKIN_MODULUS)`\n/// Next we verify that all the limbs are properly ranged\n/// and that the accumulated limbs are equal to the input `Field` value\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: BigNumParams<N, MOD_BITS>,\n    val: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(val) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            let mut grumpkin_modulus: [u128; N] = [0; N];\n            grumpkin_modulus[0] = GRUMPKIN_MODULUS[0];\n            grumpkin_modulus[1] = GRUMPKIN_MODULUS[1];\n            grumpkin_modulus[2] = GRUMPKIN_MODULUS[2];\n\n            if MOD_BITS > 253 {\n                // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n                // also for correct params N is always larger than 3 here\n                validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            } else {\n                // this is the tricky part, when MOD_BITS = 253, we have to compare the limbs of the modulus to the grumpkin modulus limbs\n                // any `BigNum` with 253 bits will have 3 limbs\n\n                // if MOD is less than grumpkin modulus, this will be true\n                let mut mod_lt_grumpkin: bool = false;\n                for i in 0..3 {\n                    if !mod_lt_grumpkin & (_params.modulus[2 - i] < grumpkin_modulus[2 - i]) {\n                        mod_lt_grumpkin = true;\n                    }\n                }\n                let min_modulus: [u128; N] = if mod_lt_grumpkin {\n                    _params.modulus\n                } else {\n                    grumpkin_modulus\n                };\n                validate_gt::<N, MOD_BITS>(min_modulus, result);\n            }\n        }\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        // validate the limbs sum up to the field value\n        let field_val: Field = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            (result[0] as Field) + (result[1] as Field) * (TWO_POW_120 as Field)\n        } else {\n            (result[0] as Field)\n                + (result[1] as Field) * (TWO_POW_120 as Field)\n                + (result[2] as Field) * TWO_POW_240\n        };\n        assert_eq(field_val, val);\n    }\n\n    result\n}\n\n/// Given an input seed, generate a pseudorandom `BigNum` value\n///\n/// This function *should* produce a uniformly randomly distributed value modulo `MOD`\n///\n///  First we take the seed and pack it's 31-byte chunks into `Field`s\n///  We use a hash function that can be modelled as a random oracle\n///  We hash the packed seed using Poseidon2 to produce `MOD_BITS * 2` bits of entropy\n///\n///  From these bits we construct 4(in case N = 2) or 3(N > 2) `BigNum` values:\n///  - We fill first `N - 1` limbs and leave the top limb empty\n///\n///  Then we accumulate the resulting BigNum values using:\n///  B = 2^{120 * (N - 1)}\n///  res = x3 + B * x2 + B^2 * x1 + B^3 * x0\n///\n/// ## Note\n/// This function will always produce an `x3` `BigNum`\n/// If `MOD = 2^{120 * (N - 1)}`\n/// It will use only `MOD_BITS - 1` bits of entropy\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    // Pack seed bytes into Fields.\n    // For the seed of length M, we construct a rolling_hash_field of size ceil(M / 31).\n    // i.e.  31 bytes per Field\n    // NOTE: the Fields produced are 248 bits in size\n    let mut rolling_hash_fields: [Field; (SeedBytes + 30) / 31] = [0; (SeedBytes + 30) / 31];\n    let mut seed_ptr: u32 = 0;\n    for i in 0..(SeedBytes + 30) / 31 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed: Field =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes + 30) / 31);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    // 120 bit limb has 15 bytes in it\n    // we buffer (N * 15) * 2 bytes for 2N limbs\n    let mut hash_buffer: [u8; N * 15 * 2] = [0; N * 15 * 2];\n\n    // We produce 32 bytes (254 bits) per hash iteration\n    // We take only 30 bytes, so we need ceil(N * 2 * 15 / 30) hashes to fill them up\n    for i in 0..N {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    let num_bits: u32 = MOD_BITS * 2;\n    let num_bytes: u32 = (num_bits + 7) / 8;\n\n    // Truncate the final byte that will be used in `BigNum` creation\n    let bits_in_last_byte: u8 = (num_bits as u8) % 8;\n    if bits_in_last_byte != 0 {\n        let last_byte_mask: u8 = ((1 as u8) << bits_in_last_byte) - 1;\n        hash_buffer[num_bytes - 1] &= last_byte_mask;\n    }\n\n    let num_bigfield_chunks: u32 = if N == 2 { 4 } else { 3 };\n    let mut byte_ptr: u32 = 0;\n\n    // We want to convert our hash_buffer into bigfield chunks, with each `BigNum` having at most N - 1 limbs filled\n    // We sample only N - 1 limbs mostly because we do not wont to deal with accidental overflows in the top limb\n    // In any case the security is preserved\n    //\n    // For all integer values N > 1, the number of chunks is either 4(for N = 2) or 3(for N > 2) (ceil(2*N / (N - 1)))\n    //\n    // To determine the exact number of chunks, we need the `!=` or `>` operator which is not available when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n\n        // Before the current limb, we filled out (N - 1) limbs, k times\n        // 15 bytes per limb\n        // resulting in total of 15 * k * (N - 1)\n        let mut num_filled_bytes: u32 = 15 * k * (N - 1);\n        if num_bytes > num_filled_bytes {\n            // Static assert for completeness\n            assert(num_filled_bytes == byte_ptr);\n\n            let mut num_remaining_bytes_to_sample: u32 = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs_to_sample: u32 = (num_remaining_bytes_to_sample + 14) / 15;\n\n            // Sample at most (N - 1) limbs from hash_buffer\n            let mut num_limbs_to_sample: u32 = if num_remaining_limbs_to_sample > (N - 1) {\n                N - 1\n            } else {\n                num_remaining_limbs_to_sample\n            };\n\n            for j in 0..num_limbs_to_sample {\n                let mut limb: Field = 0;\n                // Construct a 120 bit limb\n                for _ in 0..15 {\n                    if byte_ptr < num_bytes {\n                        let mut byte: u8 = hash_buffer[byte_ptr];\n                        limb *= 256;\n                        limb += byte as Field;\n                        byte_ptr += 1;\n                    }\n                }\n                // crucial for performance\n                limb.assert_max_bit_size::<120>();\n                // Accumulate limbs from top to bottom\n                bigfield_limbs[num_limbs_to_sample - 1 - j] = limb as u128;\n            }\n            // Accumulate `BigNum` values from top to bottom\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    // B = 2^{120 * (N - 1)}, we know it is \\leq `MOD`, since the top limb\n    // have to be at least one\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n\n    let mut result: [u128; N] = bigfield_chunks[0];\n\n    for i in 1..num_bigfield_chunks {\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_chunks[i]);\n    }\n\n    result\n}\n\n// ------------------------------ COMPARISON FUNCTIONS ------------------------------\n\n/// Validate lhs != rhs\n///\n/// We compare `A` and `B` via their encodings in the circuit `Field`\n///\n/// Under our range assumptions, equality in `Field` implies equality of the underlying\n/// `BigNum` values, hence equality (mod `MOD`)\n///\n/// In this library it is possible that A or B is a little bit greater than `MOD`\n/// So A == B (mod `MOD`) implies that A == B, A == B + MOD or A == B - MOD over the integers\n/// Hence we can compute everything (mod p) and constrain that\n/// (A - B) * (A - B + MOD) * (A - B - MOD) != 0 (mod p)\n///\n/// ## Soundness\n/// This method is *sound* for checking `A != B (mod MOD)`\n///\n/// If `A == B (mod MOD)`, then `A - B` is in `{0, +-MOD}` as an integer,\n/// so one of the factors `A-B`, `A-B+MOD`, `A-B-MOD` is zero in `Field`, and the product is zero\n/// Therefore, whenever the assertion `target != 0` holds, we must have `A != B (mod MOD)`\n/// under our range assumptions\n///\n/// ## Completeness\n/// In general, this method is not *complete*: if the admissible range of `A` and `B`\n/// is large enough relative to the circuit `Field` prime `p`, an honest prover with\n/// `A != B (mod MOD)` can still hit an alias where\n///     (A - B) * (A - B + MOD) * (A - B - MOD) == 0 (mod p),\n/// i.e.\n///     - A = B       (mod p), or\n///     - A = B + MOD (mod p), or\n///     - A = B - MOD (mod p).\n///\n/// For random `A, B` in such a wide range, the probability of this collision is\n/// roughly 3/p.\n///\n/// In case `MOD` < `p` this function becomes *complete*\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_p: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_p *= TWO_POW_120 as Field;\n\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_p += params.modulus[N - i - 1] as Field;\n    }\n\n    let diff: Field = l - r;\n    let target: Field = diff * (diff + modulus_mod_p) * (diff - modulus_mod_p);\n    assert(target != 0, \"assert_is_not_equal fail\");\n}\n\n/// Compute equality flag\n///\n/// A == B (mod MOD)\n/// We compute A - B and check whether it is `0` or `MOD`\n/// This is due to subtract constrains the diff value to be < 2^MOD_BITS, not < `MOD`\n///\n/// ## Soundness\n/// This function is conditionally *sound*. See `sub` for details\n///\n/// ## Completeness\n/// This function is *complete*. An honest prover will always be able to execute it.\n///\n/// ## TODO\n/// can do this more efficiently via witngen in unconstrained functions?\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff: [u128; N] = sub::<N, MOD_BITS>(params, lhs, rhs);\n    is_zero::<N, MOD_BITS>(params, diff)\n}\n\n/// Validate that `val` is not equal to zero when interpreted as an integer.\n///\n/// This enforces that at least one limb of `val` is non-zero.\n/// It does *not* check \"BigNum zero\" in the modular sense (e.g. it\n/// treats `MOD` as non-zero).\n///\n/// ## Assumptions\n/// * Each limb of `val` is range-constrained to be a 120-bit value:\n///   `0 <= val[i] < 2^120`.\n/// * For our concrete fields and limb counts we have `N * 2^120 < p`,\n///   so the sum of all limbs fits strictly inside the field modulus.\n///\n/// ## Completeness\n/// If `val` is non-zero as an integer, then at least one limb is non-zero,\n/// so the integer sum of the limbs satisfies `0 < limb_sum < p`. In this\n/// case `limb_sum != 0` in the `Field`, and the assertion passes.\n///\n/// ## Soundness\n/// If all limbs of `val` are zero, then `limb_sum` is zero as an integer\n/// and as a field element, so the assertion fails. A witness representing\n/// the zero integer can never satisfy this check.\n///\n/// ## Note\n/// This is slightly cheaper than doing `val != [0; N]`, as we avoid\n/// creating per-limb boolean equalities and chaining them with `and`s.\npub(crate) fn assert_is_not_zero_integer<let N: u32>(val: [u128; N]) {\n    let mut limb_sum: Field = 0;\n    for i in 0..N {\n        limb_sum += val[i] as Field;\n    }\n    assert(limb_sum != 0, \"assert_is_not_zero_integer fail\");\n}\n\n/// Check whether `val` is the zero `BigNum` in the integer sense.\n///\n/// This returns `true` iff all limbs of `val` are zero. It does *not*\n/// treat `MOD` as zero; for modular `BigNum` zero use `is_zero`.\n///\n/// See `assert_is_not_zero_integer` for the underlying assumptions.\n///\n/// ## Note\n/// This is slightly cheaper than testing `val == [0; N]`, as we avoid\n/// creating per-limb boolean equalities and chaining them with `and`s.\npub(crate) fn is_zero_integer<let N: u32>(val: [u128; N]) -> bool {\n    let mut limb_sum: Field = 0;\n    for i in 0..N {\n        limb_sum += val[i] as Field;\n    }\n    limb_sum == 0\n}\n\n/// Validate that a `BigNum` value is not zero modulo `MOD`.\n///\n/// Convenience wrapper around `assert_is_not_equal`.\npub(crate) fn assert_is_not_zero<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    assert_is_not_equal::<N, MOD_BITS>(params, val, [0; N]);\n}\n\n/// Check whether a `BigNum` value is zero modulo `MOD`.\n///\n/// This treats both the all-zero limb vector and `params.modulus` as\n/// representing zero. It assumes that all valid `BigNum` values are\n/// range-constrained so that no other representatives of `0 (mod MOD)`\n/// can appear.\n///\n/// ## Note\n/// This is cheaper than calling `eq(val, [0; N])`\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> bool {\n    is_zero_integer(val) | (val == params.modulus)\n}\n\n/// Validate a `BigNum` instance is correctly range constrained to contain no more than `MOD_BITS` bits\n///\n/// Constrain the `BigNum` instance to be < 2^MOD_BITS by:\n///     - Constraining each limb(0..N-2) to be 120-bit limb\n///     - Constraining the last limb to be `MOD_BITS - 120 * (N - 1)`\n///\n/// ## Note\n/// This can be a very expensive function, when the `TOP_LIMB_BITS` is uncommon\n///\n/// For example: BLS12_377Fr, with `TOP_LIMB_BITS`=13\n/// It creates a new 13-bit range table, which consists of roughly 3k variables\n/// And ~2k circuit gates\n///\n/// Compare this to BLS12_377Fq, with `TOP_LIMB_BITS`=17\n/// It is nicely decomposed into\n/// 14-bit range check and 3-bit range check - much much cheaper, since 14-bit range checks\n/// are already pretty common for 120-bit range checks\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/// Validate quotient produced from `evaluate_quadratic_expression` is well-formed\n///\n/// Because the inputs into `evaluate_quadratic_expression` may cause the quotient to extend beyond `Params::modulus_bits`.\n///           We allow the quotient to extend `6` bits beyond `Params::modulus_bits()`\n///           Why is this?\n///           several factors:    1. quotient * modulus , limbs cannot overflow `Field` boundary (254 bits)\n///                               2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n///                                  limbs cannot exceed `246` bits (246 magic number due to a higher number adding extra range check gates)\n///           because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be > 126 bits\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N - 1) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - (N - 1) * 120 + 6>();\n}\n\n/// Validate that `lhs - rhs` does not underflow i.e. that lhs > rhs over the integers\n///\n/// Compute `result = lhs - rhs` along with `borrow_flags`,\n/// then constrain `result` to be a valid `BigNum` value.\n///\n/// ## Completeness\n/// This function is complete and will work only if `lhs > rhs` over the integers.\n///\n/// ## Soundness\n/// This function is sound:\n///     result[0]     = lhs[0]     - rhs[0]     + bf[0] * 2^{120}             < 2^{120}\n///     result[i]     = lhs[i]     - rhs[i]     + bf[i] * 2^{120} - bf[i - 1] < 2^{120},  i = 1..N-2\n///     result[N - 1] = lhs[N - 1] - rhs[N - 1]                   - bf[N - 2] < 2^{TOP_LIMB_BITS}\n///     result != 0\n///\n/// If `lhs < rhs`, then some limb of `result` would have to borrow from a higher limb,\n/// which is impossible because the top limb cannot borrow\n/// Without the extra borrow, the resulting difference will be wrapped around the `Field` modulus\n/// And won't satisfy the range constraint, since all the limbs are < 2^120\n///\n/// ## Note\n/// `assert_is_not_zero_integer(result)` is crucial. Without it, we could always provide\n/// two identical inputs `x`, `x` and set `borrow_flags = [false; N]`,\n/// which would satisfy the limb constraints.\n///\n/// Also note that `underflow` is not properly constrained, so it just hangs there for\n/// completeness\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // Safety: compute borrow flags out-of-circuit\n    let (underflow, result, borrow_flags): (bool, [u128; N], [bool; N - 1]) =\n        unsafe { __validate_gte_with_flags(lhs, rhs) };\n\n    // Completeness: require that no underflow occurred\n    assert(!underflow, \"validate_gt fail\");\n\n    // Constrain the `result` to be a valid `BigNum` value\n    validate_in_range::<u128, N, MOD_BITS>(result);\n    // Constrain it to be strict inequality\n    assert_is_not_zero_integer(result);\n\n    // Constrain `result` and `borrow_flags` to match the expected arithmetic\n    check_gte_with_flags(lhs, rhs, result, borrow_flags);\n}\n\n/// Constraining function for the results of `__validate_gte_with_flags`,\n/// used by both `cmp` and `validate gt`\n///\n/// This function checks the relations between `lhs`, `rhs`, `result` adn `borrow_flags`:\n///     lhs[0]     - rhs[0]     - result[0]     + bf[0] * 2^{120}             = 0\n///     lhs[i]     - rhs[i]     - result[i]     + bf[i] * 2^{120} - bf[i - 1] = 0,  i = 1..N-2\n///     lhs[N - 1] - rhs[N - 1] - result[N - 1]                   - bf[N - 2] = 0\npub(crate) fn check_gte_with_flags<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N - 1],\n) {\n    let result_limb: Field = (lhs[0] as Field) - (rhs[0] as Field) - (result[0] as Field)\n        + (borrow_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let result_limb: Field = (lhs[i] as Field) - (rhs[i] as Field) - (result[i] as Field)\n            + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n            - (borrow_flags[i - 1] as Field);\n        assert(result_limb == 0);\n    }\n\n    let result_limb: Field = (lhs[N - 1] as Field)\n        - (rhs[N - 1] as Field)\n        - (result[N - 1] as Field)\n        - (borrow_flags[N - 2] as Field);\n    assert(result_limb == 0);\n}\n\n/// Validate that `val` <= `MOD`\n///\n/// Compute `result = MOD - val` along with `borrow_flags`,\n/// then constrain `result` to be a valid `BigNum` value.\n///\n/// Basically the same as `validate_gt` but we compute the result on the fly\n/// It is just a bit more optimized as we expect each `BigNum` value to be \\leq `MOD`\n///\n/// ## Note\n/// In contrast to `validate_gt`, we allow the value to be `MOD`\n/// Since it is consistent with the rest of the library\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    let modulus: [u128; N] = params.modulus;\n\n    // Safety: compute borrow flags out-of-circuit\n    let borrow_flags: [bool; (N - 1)] =\n        unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n\n    let mut p_minus_self: [Field; N] = [0; N];\n    p_minus_self[0] = (modulus[0] as Field) - (val[0] as Field)\n        + (borrow_flags[0] as Field) * (TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] = (modulus[i] as Field) - (val[i] as Field)\n            + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n            - (borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] =\n        (modulus[N - 1] as Field) - (val[N - 1] as Field) - (borrow_flags[N - 2] as Field);\n    validate_in_range::<Field, N, MOD_BITS>(p_minus_self);\n}\n\n/// Compare two `BigNum` values\n///\n/// Returns `lhs > rhs`\n///\n/// ## Note\n/// This is a strict value comparison over the integers,\n/// the values do not have to be reduced modulo `MOD`.\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    // Safety: we constrain:\n    //        - `result` and `borrow_flags` with `check_gte_with_flags`\n    //        - `borrow_flags` are also booleans\n    //        - `underflow` with the following swap and (bool)\n    let (underflow, result, borrow_flags): (bool, [u128; N], [bool; N - 1]) =\n        unsafe { __validate_gte_with_flags(lhs, rhs) };\n\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs): ([u128; N], [u128; N]) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    // Constrain the `result` to be a valid `BigNum` value\n    validate_in_range::<u128, N, MOD_BITS>(result);\n\n    // Constrain subtraction: result = lhs - rhs with borrow_flags\n    check_gte_with_flags(lhs, rhs, result, borrow_flags);\n\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// ------------------------------ ARITHMETIC FUNCTIONS ------------------------------\n\n/// Negate a `BigNum` value\n///\n/// Computes `result = MOD - val` using limb-wise subtraction with borrow flags,\n/// then constrains:\n///   - all `result` limbs to be a valid `BigNum` value, and\n///   - the subtraction relation with the borrow flags\n///\n/// ## Assumptions\n/// - `val` is a valid `BigNum` in the range `0 <= val <= MOD`.\n///\n/// ## Soundness\n/// This function constrains the following relations:\n///     result[0]     = MOD[0]     - val[0]     + bf[0] * 2^{120}             < 2^{120}\n///     result[i]     = MOD[i]     - val[i]     + bf[i] * 2^{120} - bf[i - 1] < 2^{120},  i = 1..N-2\n///     result[N - 1] = MOD[N - 1] - val[N - 1]                   - bf[N - 2] < 2^{TOP_LIMB_BITS}\n///\n/// If all `MOD` and `val` limbs are valid `BigNum` limbs, these constraints\n/// ensure that:\n///   - the borrow flags `bf[i]` form a valid limb-wise subtraction chain, and\n///   - no underflow can occur in the subtraction `MOD - val`.\n///\n/// ## Completeness\n/// This function is complete for inputs in the range `0 <= val <= MOD`.\n/// If a value `val > MOD` is passed in (while still `< 2^{MOD_BITS}`), the\n/// constraints above will fail, since there is no valid borrow chain making\n/// `MOD - val` a well-formed `BigNum`.\n///\n/// In practice, honest provers should not hit this case: all functions in this\n/// module are expected to return values `< MOD`.\n///\n/// ## Note\n/// This function returns `MOD` when `val` is zero.\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: no need to constrain in an unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // Safety: compute borrow flags out-of-circuit\n        let (result, borrow_flags): ([u128; N], [bool; N - 1]) =\n            unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        let result_limb: Field = (params.modulus[0] as Field)\n            - (val[0] as Field)\n            - (result[0] as Field)\n            + (borrow_flags[0] as Field) * (TWO_POW_120 as Field);\n        assert(result_limb == 0);\n\n        for i in 1..N - 1 {\n            let result_limb: Field = (params.modulus[i] as Field)\n                - (val[i] as Field)\n                - (result[i] as Field)\n                + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (borrow_flags[i - 1] as Field);\n            assert(result_limb == 0);\n        }\n\n        let result_limb: Field = (params.modulus[N - 1] as Field)\n            - (val[N - 1] as Field)\n            - (result[N - 1] as Field)\n            - (borrow_flags[N - 2] as Field);\n        assert(result_limb == 0);\n        result\n    }\n}\n\n/// Add two `BigNum` values\n///\n/// Computes `result = lhs + rhs` using limb-wise addition with carry flags,\n/// and an optional subtraction of `MOD` using borrow flags. The function then\n/// constrains:\n///   - all `result` limbs to be a valid `BigNum` value, and\n///   - the addition/subtraction relation with the carry/borrow flags and the\n///     `overflow_modulus` bit.\n///\n/// ## Assumptions\n/// - All limbs of `lhs`, `rhs` and `MOD` are valid `BigNum` limbs\n///   (120-bit for non-top limbs, `TOP_LIMB_BITS` for the top limb).\n/// - Semantically, we intend to use this only with `0 <= lhs, rhs < MOD`,\n///   even though the limb/range constraints allow values up to `< 2^{MOD_BITS}`.\n///\n/// ## Soundness (intended relation)\n/// This function constrains the following equations:\n///\n///     result[0]     = lhs[0]     + rhs[0]\n///                     - sub[0]\n///                     + bf[0] * 2^{120}\n///                     - cf[0]                                        < 2^{120}\n///\n///     result[i]     = lhs[i]     + rhs[i]\n///                     - sub[i]\n///                     + bf[i] * 2^{120}  - bf[i - 1]\n///                     - cf[i] * 2^{120}  + cf[i - 1]                 < 2^{120},\n///                     for i = 1..N-2\n///\n///     result[N - 1] = lhs[N - 1] + rhs[N - 1]\n///                     - sub[N - 1]\n///                     - bf[N - 2]\n///                     + cf[N - 2]                                   < 2^{TOP_LIMB_BITS}\n///\n/// where:\n///   - `bf[i]` are the borrow flags of the optional subtraction,\n///   - `cf[i]` are the carry flags of the addition, and\n///   - `sub` is either the zero vector or `MOD`, depending on the\n///     `overflow_modulus` flag:\n///         * `overflow_modulus = 0`  =>  `sub = 0`\n///         * `overflow_modulus = 1`  =>  `sub = MOD`\n///\n/// If `lhs`, `rhs` and `MOD` are valid `BigNum` limbs and the witness for\n/// `(bf, cf, overflow_modulus)` is the honest one produced by `__add_with_flags`,\n/// these constraints enforce:\n///   - a valid limb-wise carry chain for `lhs + rhs`, and\n///   - a valid limb-wise subtraction chain for either `lhs + rhs` or\n///     `lhs + rhs - MOD`, with no underflow in any limb.\n///\n/// Under these assumptions the constrained result equals:\n///\n///     result = lhs + rhs (mod MOD)\n///\n/// in the intended arithmetic.\n///\n/// ## Limitations / extra satisfying witnesses\n///\n/// The constraint system itself does **not** uniquely determine the carry/borrow\n/// flags nor the `overflow_modulus` bit:\n///\n/// - For each limb `i`, `bf[i]` and `cf[i]` only appear in the combination\n///   `bf[i] * 2^{120} - cf[i] * 2^{120}`. This means that both\n///\n///       (bf[i], cf[i]) = (0, 0)  and  (bf[i], cf[i]) = (1, 1)\n///\n///   give the same contribution to the equation. As a result, there are multiple\n///   valid flag assignments for the *same* `lhs`, `rhs`, `sub` and `result`.\n///\n/// - More importantly, if `lhs + rhs` is greater than `MOD` but still strictly\n///   less than `2^{MOD_BITS}`, there exist *spurious* witnesses where:\n///     * `overflow_modulus` is set inconsistently with the true arithmetic\n///       overflow, and\n///     * the `(bf, cf)` flags are adjusted accordingly,\n///\n///   such that all equations above still hold and all `result` limbs remain\n///   within range. In particular, when\n///\n///       lhs + rhs + MOD < 2^{MOD_BITS},\n///\n///   a malicious prover can \"hide\" an extra `MOD` inside the choice of\n///   `overflow_modulus`, `bf` and `cf`, so that the circuit is satisfied by a\n///   witness\n///\n/// Consequently, this function is only *conditionally* sound: we rely on the\n/// out-of-circuit implementation of `__add_with_flags` to provide the honest\n/// `(borrow_flags, carry_flags, overflow_modulus)` witness. Under that\n/// assumption, the constrained `result` matches `lhs + rhs (mod MOD)`.\n///\n/// ## Completeness\n///\n/// For inputs in the range `0 <= lhs, rhs < MOD` and honest flags from\n/// `__add_with_flags`, the constraints are complete: every valid `BigNum` sum\n/// `lhs + rhs (mod MOD)` admits a satisfying assignment.\n///\n/// Inputs with `lhs` or `rhs` in `[MOD, 2^{MOD_BITS})` are still representable\n/// as limb arrays and may admit satisfying witnesses, but then the operation\n/// no longer corresponds to a unique, well-defined addition in the field\n/// `Z / MOD Z`. Such uses are outside the intended semantics of this function.\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: no need to constrain in unconstrained runtime\n        unsafe {\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // Safety: compute borrow/carry flags out-of-circuit\n        let (result, carry_flags, borrow_flags, overflow_modulus): ([u128; N], [bool; N - 1], [bool; N - 1], bool) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        let mut subtrahend: [u128; N] = if overflow_modulus {\n            params.modulus\n        } else {\n            [0; N]\n        };\n\n        let result_limb: Field = (lhs[0] as Field) + (rhs[0] as Field)\n            - (result[0] as Field)\n            - (subtrahend[0] as Field)\n            + (borrow_flags[0] as Field) * (TWO_POW_120 as Field)\n            - (carry_flags[0] as Field) * (TWO_POW_120 as Field);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb: Field = (lhs[i] as Field) + (rhs[i] as Field)\n                - (result[i] as Field)\n                - (subtrahend[i] as Field)\n                - (borrow_flags[i - 1] as Field)\n                + (carry_flags[i - 1] as Field)\n                + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (carry_flags[i] as Field) * (TWO_POW_120 as Field);\n            assert(result_limb == 0);\n        }\n        let result_limb: Field = (lhs[N - 1] as Field) + (rhs[N - 1] as Field)\n            - (result[N - 1] as Field)\n            - (subtrahend[N - 1] as Field)\n            - (borrow_flags[N - 2] as Field)\n            + (carry_flags[N - 2] as Field);\n        assert(result_limb == 0);\n        result\n    }\n}\n\n/// Subtract two `BigNum` values\n///\n/// Computes `result = lhs - rhs` using limb-wise subtraction with borrow flags,\n/// and an optional addition of `MOD` using carry flags. The function then\n/// constrains:\n///   - all `result` limbs to be a valid `BigNum` value, and\n///   - the subtraction/addition relation with the carry/borrow flags and the\n///     `underflow_modulus` bit.\n///\n/// ## Assumptions\n/// - All limbs of `lhs`, `rhs` and `MOD` are valid `BigNum` limbs\n///   (120-bit for non-top limbs, `TOP_LIMB_BITS` for the top limb).\n/// - Semantically, we intend to use this only with `0 <= lhs, rhs < MOD`,\n///   even though the limb/range constraints allow values up to `< 2^{MOD_BITS}`.\n///\n/// ## Soundness (intended relation)\n/// This function constrains the following equations:\n///\n///     result[0]     = lhs[0]     - rhs[0]\n///                     + add[0]\n///                     + bf[0] * 2^{120}\n///                     - cf[0]                                        < 2^{120}\n///\n///     result[i]     = lhs[i]     - rhs[i]\n///                     + add[i]\n///                     + bf[i] * 2^{120}  - bf[i - 1]\n///                     - cf[i] * 2^{120}  + cf[i - 1]                 < 2^{120},\n///                     for i = 1..N-2\n///\n///     result[N - 1] = lhs[N - 1] - rhs[N - 1]\n///                     + add[N - 1]\n///                     - bf[N - 2]\n///                     + cf[N - 2]                                   < 2^{TOP_LIMB_BITS}\n///\n/// where:\n///   - `bf[i]` are the borrow flags of the subtraction,\n///   - `cf[i]` are the carry flags of the optional addition, and\n///   - `add` is either the zero vector or `MOD`, depending on the\n///     `underflow_modulus` flag:\n///         * `underflow_modulus = 0`  =>  `add = 0`\n///         * `underflow_modulus = 1`  =>  `add = MOD`\n///\n/// If `lhs`, `rhs` and `MOD` are valid `BigNum` limbs and the witness for\n/// `(bf, cf, underflow_modulus)` is the honest one produced by `__sub_with_flags`,\n/// these constraints enforce:\n///   - a valid limb-wise borrow chain for `lhs - rhs`, and\n///   - a valid limb-wise addition chain for either `lhs - rhs` or\n///     `lhs - rhs + MOD`, with no underflow in any limb.\n///\n/// Under these assumptions the constrained result equals:\n///\n///     result = lhs - rhs (mod MOD)\n///\n/// in the intended arithmetic.\n///\n/// ## Limitations / extra satisfying witnesses\n///\n/// The constraint system itself does **not** uniquely determine the carry/borrow\n/// flags nor the `underflow_modulus` bit:\n///\n/// - For each limb `i`, `bf[i]` and `cf[i]` only appear in the combination\n///   `bf[i] * 2^{120} - cf[i] * 2^{120}`. This means that both\n///\n///       (bf[i], cf[i]) = (0, 0)  and  (bf[i], cf[i]) = (1, 1)\n///\n///   give the same contribution to the equation. As a result, there are multiple\n///   valid flag assignments for the *same* `lhs`, `rhs`, `add` and `result`.\n///\n/// - More importantly, when `lhs < rhs`, the true field result is\n///\n///       lhs - rhs + MOD,\n///\n///   and as long as\n///\n///       lhs - rhs + MOD < 2^{MOD_BITS},\n///\n///   a malicious prover can:\n///     * set `underflow_modulus` inconsistently with the true underflow, and\n///     * adjust the `(bf, cf)` flags accordingly,\n///\n///   such that all equations above still hold and all `result` limbs remain\n///   within range. In other words, the circuit can be satisfied by a witness\n///   that does **not** correspond to the unique intended subtraction modulo\n///   `MOD` for some inputs with `lhs < rhs`.\n///\n/// Consequently, this function is only *conditionally* sound: we rely on the\n/// out-of-circuit implementation of `__sub_with_flags` to provide the honest\n/// `(borrow_flags, carry_flags, underflow_modulus)` witness. Under that\n/// assumption, the constrained `result` matches `lhs - rhs (mod MOD)`.\n///\n/// ## Completeness\n///\n/// For inputs in the range `0 <= lhs, rhs < MOD` and honest flags from\n/// `__sub_with_flags`, the constraints are complete: every valid `BigNum`\n/// difference `lhs - rhs (mod MOD)` admits a satisfying assignment.\n///\n/// Inputs with `lhs` or `rhs` in `[MOD, 2^{MOD_BITS})` are still representable\n/// as limb arrays and may admit satisfying witnesses, but then the operation\n/// no longer corresponds to a unique, well-defined subtraction in the field\n/// `Z / MOD Z`. Such uses are outside the intended semantics of this function.\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: no need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // Safety: we constrain carry, borrow, underflow and result immediately\n        let (result, carry_flags, borrow_flags, underflow_modulus): ([u128; N], [bool; N - 1], [bool; N - 1], bool) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<u128, N, MOD_BITS>(result);\n\n        let mut addend: [u128; N] = if underflow_modulus {\n            params.modulus\n        } else {\n            [0; N]\n        };\n\n        let result_limb: Field = (lhs[0] as Field) - (rhs[0] as Field) - (result[0] as Field)\n            + (addend[0] as Field)\n            + (borrow_flags[0] as Field) * (TWO_POW_120 as Field)\n            - (carry_flags[0] as Field) * (TWO_POW_120 as Field);\n        assert(result_limb == 0);\n\n        for i in 1..N - 1 {\n            let result_limb: Field = (lhs[i] as Field) - (rhs[i] as Field) - (result[i] as Field)\n                + (addend[i] as Field)\n                + (borrow_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (carry_flags[i] as Field) * (TWO_POW_120 as Field)\n                - (borrow_flags[i - 1] as Field)\n                + (carry_flags[i - 1] as Field);\n            assert(result_limb == 0);\n        }\n        let result_limb: Field = (lhs[N - 1] as Field)\n            - (rhs[N - 1] as Field)\n            - (result[N - 1] as Field)\n            + (addend[N - 1] as Field)\n            - (borrow_flags[N - 2] as Field)\n            + (carry_flags[N - 2] as Field);\n        assert(result_limb == 0);\n        result\n    }\n}\n\n/// Compute the `BigNum` multiplication\n///\n/// Computes `result = lhs * rhs (mod MOD)` by:\n///   1. Computing `result` out of circuit via `__mul`.\n///   2. Constraining the quadratic relation `lhs * rhs - result = 0` with\n///      `evaluate_quadratic_expression`.\n///\n/// ## Soundness\n/// Soundness reduces to `evaluate_quadratic_expression` for the relation\n/// `lhs * rhs - result = 0`\n///\n/// ## Note\n/// When possible, prefer expressing your computation directly as a quadratic\n///   relation and calling `evaluate_quadratic_expression` instead of using `mul`\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    // Safety: we constrain the multiplication result immediately after\n    let result: [u128; N] = unsafe { __mul::<N, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        // lhs * rhs - result = 0\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n/// Compute the `BigNum` squaring\n///\n/// Computes `result = val * val (mod MOD)` by:\n///   1. Computing `result` out of circuit via `__sqr`.\n///   2. Constraining the quadratic relation `val * val - result = 0` with\n///      `evaluate_quadratic_expression`.\n///\n/// ## Soundness\n/// Soundness reduces to `evaluate_quadratic_expression` for the relation\n/// `val * val - result = 0`\n///\n/// ## Note\n/// When possible, prefer expressing your computation directly as a quadratic\n///   relation and calling `evaluate_quadratic_expression` instead of using `sqr`\npub(crate) fn sqr<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    // Safety: we constrain the multiplication result immediately after\n    let result: [u128; N] = unsafe { __sqr::<_, MOD_BITS>(params, val) };\n    if !std::runtime::is_unconstrained() {\n        // val * val - result = 0\n        evaluate_quadratic_expression(\n            params,\n            [[val]],\n            [[false]],\n            [[val]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n/// Compute the `BigNum` division\n///\n/// Computes `result = lhs * rhs^{-1} (mod MOD)` by:\n///   1. Computing `result` out of circuit via `__div`.\n///   2. Constraining the quadratic relation `result * rhs - lhs = 0` with\n///      `evaluate_quadratic_expression`.\n///   3. Enforcing `rhs != 0 (mod MOD)`.\n///\n/// ## Soundness\n/// Soundness reduces to `evaluate_quadratic_expression` for the relation\n/// `result * rhs - lhs = 0`, together with the non-zero check on `rhs` and the\n/// assumption that `MOD` has multiplicative inverses for all non-zero elements\n/// (`params.has_multiplicative_inverse = true`).\n///\n/// ## Note\n/// - This is **expensive** in witness time due to modular inversion.\n/// - When possible, prefer expressing your computation directly as a quadratic\n///   relation and calling `evaluate_quadratic_expression` instead of using `div`.\n/// - In the unconstrained runtime, the behavior of `__div` on zero divisors is\n///   not constrained by this function.\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    // Safety: We constrain the result of division immediately after\n    let result: [u128; N] = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        // result * rhs - lhs = 0\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n        assert_is_not_zero(params, rhs);\n    }\n    result\n}\n\n/// Compute the `BigNum` integer division with remainder\n///\n/// Computes `quotient = floor(numerator / divisor)` and\n/// `remainder = numerator % divisor` by:\n///   1. Computing `(quotient, remainder)` out of circuit via `__udiv_mod`.\n///   2. Constraining the quadratic relation\n///        quotient * divisor + remainder - numerator = 0\n///      with `validate_udiv_mod_expression`.\n///   3. Enforcing `remainder < divisor`.\n///\n/// ## Soundness\n/// Soundness reduces to `validate_udiv_mod_expression` for the relation\n///     quotient * divisor + remainder - numerator = 0,\n/// together with `remainder < divisor` check enforced via `validate_gt`.\n///\n/// Under these checks, any satisfying assignment corresponds to a valid\n/// integer division `numerator = quotient * divisor + remainder` with\n/// `0 <= remainder < divisor`\n///\n/// ## Note\n/// Enforcing `divisor != 0` is not necessary. `remainder < divisor`\n/// Already enforces this.\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    // Safety: We constrain the result of __udiv_mod immediately after\n    let (quotient, remainder): ([u128; N], [u128; N]) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // quotient * divisor + remainder - numerator = 0\n        validate_udiv_mod_expression::<N, MOD_BITS>(numerator, divisor, quotient, remainder);\n        // remainder < divisor\n        validate_gt::<N, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/// Compute the `BigNum` integer division\n///\n/// Returns `floor(numerator / divisor)`.\n/// All constraints and soundness details are handled inside `udiv_mod`.\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<N, MOD_BITS>(numerator, divisor).0\n}\n\n/// Compute the `BigNum` remainder\n///\n/// Returns `numerator % divisor`.\n/// All constraints and soundness details are handled inside `udiv_mod`.\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<N, MOD_BITS>(numerator, divisor).1\n}\n","path":"/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/constrained_ops.nr"},"87":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\n\nuse crate::fns::constrained_ops::{validate_in_range, validate_quotient_in_range};\nuse crate::fns::unconstrained_helpers::__barrett_reduction;\nuse crate::fns::unconstrained_ops::__is_zero;\n\nuse crate::params::BigNumParams;\n\n// ------------------------------ UNCONSTRAINED EXPRESSIONS ------------------------------\n\n/// Compute the result of a linear combination of (possibly negative) `BigNum` values (unconstrained)\n///\n/// ## Note\n/// 1. `modulus2` is structured such that all limbs will be greater than `0`, even when subtracting.\n/// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n/// We know that, for a valid bignum element, the limbs in `x` will be < 2^{120}\n/// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n/// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\n///\n/// 2. Returns the `Field` values that are not normalized to be 120-bit\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    vals: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    let mut sum: [Field; N] = [0; N];\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field) - (vals[i][j] as Field);\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + (vals[i][j] as Field);\n            }\n        }\n    }\n    sum\n}\n\n/// Compute the limb products of a quadratic expression (unconstrained)\n///\n/// See `__compute_quadratic_expression_with_borrow_flags` for full description\n///\n/// ## Note\n/// Returns the `Field` values that are not normalized to be 120-bit\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += lhs[k][i] * rhs[k][j];\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/// Compute the borrow flags for a limb-wise subtraction `lhs - rhs` (unconstrained).\n///\n/// This helper operates on `N`-limb values where each limb is interpreted as a\n/// 120-bit chunk (base `B = 2^{120}`), but where intermediate limbs may exceed\n/// `2^{120}` due to sums of products.\n///\n/// Conceptually, we want to model the integer subtraction\n///\n///     lhs - rhs\n///\n/// as a base-`B` subtraction with borrows, without allowing any intermediate\n/// values to go negative in the circuit field. We achieve this by:\n///\n///   1. Working with widened 246-bit ranges per limb.\n///   2. Encoding a borrow from limb `i+1` into limb `i` by:\n///        - adding `2^{246}` into limb `i`,\n///        - subtracting `2^{126}` (= 2^{246 - 120}) from limb `i+1` after\n///          scaling by `2^{-120}`.\n///\n/// The returned `borrow_flags[i]` indicate whether the canonical integer\n/// subtraction would borrow from limb `i+1` into limb `i`. These flags are\n/// later re-applied in-circuit via `apply_borrow_flags`, and the resulting\n/// limbs are checked by `validate_expression_is_zero`.\nunconstrained fn __compute_borrow_flags<let N: u32>(\n    mut lhs_limbs: [Field; N],\n    rhs_limbs: [Field; N],\n) -> [bool; N - 1] {\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{126} = 2^{246 - 120}\n    let downshift_120: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    borrow_flags[0] = lhs_limbs[0].lt(rhs_limbs[0]);\n\n    // we have N - 1 borrow flags. The number of limbs is N\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits: Field =\n        (lhs_limbs[0] - rhs_limbs[0] + ((borrow_flags[0] as Field) * borrow_shift)) * downshift_120;\n\n    for i in 1..(N - 1) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        lhs_limbs[i] += hi_bits;\n\n        let subtrahend: Field = rhs_limbs[i] + (borrow_flags[i - 1] as Field) * borrow_carry;\n\n        // determine whether negative limb values are greater than positive limb values\n        borrow_flags[i] = lhs_limbs[i].lt(subtrahend);\n        let minuend: Field = lhs_limbs[i] + (borrow_flags[i] as Field) * borrow_shift;\n\n        hi_bits = (minuend - subtrahend) * downshift_120;\n    }\n    borrow_flags\n}\n\n/// Given a degree-2 `BigNum` expression that is equal to `0 mod MOD`, compute\n/// the quotient and the borrow flags (unconstrained).\n///\n/// The expression has the form:\n///\n///     sum_{k=0}^{NUM_PRODUCTS-1} (L_k * R_k) + sum_{i=0}^{ADD_N-1} A_i = quotient * MOD\n///\n/// where each `L_k`, `R_k`, `A_i` is an `N`-limb `BigNum` assembled from the\n/// `(terms, flags)` arrays.\n///\n/// This helper:\n///   1. Evaluates the quadratic expression into `mulout_p` as a `2N`-limb\n///      non-normalized value.\n///   2. Normalizes `mulout_p` into 120-bit limbs and applies Barrett\n///      reduction to obtain `(quotient, remainder)`.\n///   3. Asserts that the integer remainder is zero (debugging aid; range\n///      checks enforce this later).\n///   4. Reconstructs `mulout_n = quotient * MOD`.\n///   5. Computes `borrow_flags` for the limb-wise subtraction\n///        `mulout_p - mulout_n`,\n///      using the 2^{246}/2^{126} encoding described in\n///      `evaluate_quadratic_expression`.\n///\n/// The returned `quotient` and `borrow_flags` are later constrained\n/// in-circuit by `compute_quadratic_expression_with_modulus` and\n/// `evaluate_quadratic_expression`.\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [bool; 2 * N - 2]) {\n    let mulout_p: [Field; 2 * N] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    // `__normalize_limbs` will validate that we do not overflow 2N, normally we should not overflow 2N-1\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p);\n    let (quotient, remainder): ([u128; N], [u128; N]) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n\n    // This is verified later by the range checks but left for debugging purposes\n    assert(__is_zero(remainder));\n\n    // We do not normalize `mulout_n` so we won't fill the `2 * N - 1`\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += (quotient[i] as Field) * (params.modulus[j] as Field);\n        }\n    }\n\n    let borrow_flags: [bool; 2 * N - 1] = __compute_borrow_flags(mulout_p, mulout_n);\n\n    // We have to copy it because we know that borrow_flags[2 * N - 1] is always 0\n    // But we also have to provide 2 * N limbs to `__barrett_reduction`.\n    // And keep `__compute_borrow_flags` generic enough\n    let mut borrow_flags_real: [bool; 2 * N - 2] = [false; 2 * N - 2];\n    for i in 0..2 * N - 2 {\n        borrow_flags_real[i] = borrow_flags[i];\n    }\n\n    (quotient, borrow_flags_real)\n}\n\n/// Computes the quotient/remainder of a quadratic expression (unconstrained)\n///\n/// See `__compute_quadratic_expression_with_borrow_flags` for full description\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    let mulout: [Field; 2 * N] = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    // __normalize_limbs will validate that we do not overflow 2N, normally we should not overflow 2N-1\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout);\n\n    let (quotient, remainder): ([u128; N], [u128; N]) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n\n    (quotient, remainder)\n}\n\n// ------------------------------ CONSTRAINED EXPRESSIONS ------------------------------\n\n/// Constrained version of `__add_linear_expression`\n///\n/// Computes all the linear parts of an expression in-circuit\n///\n/// ## Note\n/// 1. Negative terms are implemented by adding `double_modulus`\n/// `double_modulus` is chosen so that all limbs except the top one\n/// are > 2^{120}, which prevents underflows in intermediate computations.\n///\n/// 2. For the most significant limb we slightly reduce the padding (to keep the\n/// overall value equal to `2 * MOD`), so in principle there is a narrow edge\n/// case where that limb could underflow if enough negative contributions are\n/// accumulated and the top limb of `MOD` is very small. In practice, the\n/// global `BigNum` range and operand-count assumptions in\n/// `evaluate_quadratic_expression` rule out such patterns.\nfn compute_linear_expressions<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([[Field; N]; NUM_PRODUCTS], [[Field; N]; NUM_PRODUCTS], [Field; N]) {\n    // lhs linear terms\n    let mut lhs_linear: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    // rhs linear terms\n    let mut rhs_linear: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    // linear terms\n    let mut lin_expr: [Field; N] = [0; N];\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // Note: if lhs_flags[k][j] - `is_negative` is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    lhs_linear[k][i] -= lhs_terms[k][j][i] as Field;\n                    lhs_linear[k][i] += params.double_modulus[i] as Field;\n                } else {\n                    lhs_linear[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                // Note: if rhs_flags[k][j] - `is_negative` is not known at comptime this is very expensive\n                if (rhs_flags[k][j]) {\n                    rhs_linear[k][i] -= rhs_terms[k][j][i] as Field;\n                    rhs_linear[k][i] += params.double_modulus[i] as Field;\n                } else {\n                    rhs_linear[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n\n    for i in 0..N {\n        for j in 0..ADD_N {\n            // Note: if linear_flags[j] - `is_negative` is not known at comptime this is very expensive\n            if (linear_flags[j]) {\n                lin_expr[i] -= linear_terms[j][i] as Field;\n                lin_expr[i] += params.double_modulus[i] as Field;\n            } else {\n                lin_expr[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    (lhs_linear, rhs_linear, lin_expr)\n}\n\n/// Constrained version of `__compute_quadratic_expression_product`\n///\n/// Computes the following expression in-circuit:\n///     \\sum (L_i * R_i) + \\sum (A_i) - QUOTIENT * MOD\n///\n/// Because of the subtraction of `QUOTIENT * MODULUS`, the resulting limbs may\n/// underflow and represent *negative* values. To account for this, we allow the\n/// prover to choose a sequence of borrow flags and interpret the limbs with\n/// additional terms:\n///\n///   - for each limb `i` we may add `2^{246}` (via a flag at position `i`);\n///   - for each limb `i` we may subtract `2^{126 = 246 - 120}` (via the flag\n///     at position `i - 1`).\n///\n/// This corresponds to borrowing `2^{126}` from limb `i + 1` and adding\n/// `2^{246}` into limb `i`. After this adjustment, an honest prover can ensure\n/// that every limb lies in `[0, 2^{246})` and that the adjusted limbs encode\n/// the correct integer value.\n///\n/// Additionally, we constrain the quotient limbs via `validate_quotient_in_range`:\n///   - limbs `0..N-2` of `quotient` are < 2^{120};\n///   - the top limb is < 2^{TOP_LIMB_BITS + 6}.\n/// Which validates `quotient < 2^{MOD_BITS + 6}`\n///\n/// ## TODO\n/// Apply static or runtime checks in this method to validate that the effective\n/// `twiddle_factor` does not exceed 6 under the chosen parameters.\nfn compute_quadratic_expression_with_modulus<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N - 1] {\n    // Safety: use an unconstrained function to compute the value of the quotient and borrow_flags out-of-circuit\n    let (quotient, borrow_flags): ([u128; N], [bool; 2 * N - 2]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<N, MOD_BITS, LHS_N, RHS_N, NUM_PRODUCTS, ADD_N>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // Constrain the `quotient < 2^{MOD_BITS + 6}`\n    // By constraining limbs(0..N-2) to be < 2^120 and the the top limb < 2^{TOP_LIMB_BITS + 6}\n    validate_quotient_in_range::<N, MOD_BITS>(quotient);\n\n    // Compute the linear sums that represent L_i, R_i, A\n    let (lhs_linear, rhs_linear, lin_expr): ([[Field; N]; NUM_PRODUCTS], [[Field; N]; NUM_PRODUCTS], [Field; N]) = compute_linear_expressions::<N, MOD_BITS, LHS_N, RHS_N, NUM_PRODUCTS, ADD_N>(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    // We want to evaluate that L * R + A - Quotient * MOD = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow\n    let mut expression_limbs: [Field; 2 * N - 1] = [0; 2 * N - 1];\n\n    // Compute the product t0 * t1 + t4 - Quotient * MOD\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term: Field = lhs_linear[k][i] * rhs_linear[k][j]\n                        - (quotient[i] as Field) * (params.modulus[j] as Field);\n                    // width-4 optimization\n                    std::as_witness(new_term);\n                    expression_limbs[i + j] += new_term;\n                } else {\n                    expression_limbs[i + j] += lhs_linear[k][i] * rhs_linear[k][j];\n                }\n            }\n            // This is the fallback for pure linear expression\n            if (NUM_PRODUCTS == 0) {\n                expression_limbs[i + j] -= (quotient[i] as Field) * (params.modulus[j] as Field);\n            }\n        }\n        expression_limbs[i] += lin_expr[i];\n    }\n\n    apply_borrow_flags(expression_limbs, borrow_flags)\n}\n\n/// Apply a precomputed borrow chain to a limb array.\n///\n/// Given:\n///\n///   - `expression_limbs`: an `N`-limb array of `Field` values representing a\n///     (possibly non-normalized) degree-2-style expression, and\n///   - `borrow_flags[i]` indicating that we \"borrow\" from limb `i+1` into limb `i`,\n///\n/// this function applies the same 2^{246}/2^{126} encoding used in\n/// `__compute_borrow_flags` to produce an adjusted limb array\n///\n/// This matches the behavior of `__compute_borrow_flags`, which conceptually:\n///\n///   1. Adds `2^{246}` into a limb when a borrow is taken at that limb;\n///   2. After scaling by `2^{-120}`, contributes `2^{126}` into the next limb.\n///\n/// The resulting `expression_limbs` can then be passed to\n/// `validate_expression_is_zero`, which:\n///\n///   - right-shifts by 120 bits per limb,\n///   - enforces a 126-bit bound,\n///   - and propagates carries forward, finally checking that the most\n///     significant limb is zero.\n///\n/// ## Assumptions\n///\n/// - `borrow_flags` was computed consistently with the original construction\n///   of `expression_limbs` (e.g. via `__compute_borrow_flags` on the\n///   corresponding unconstrained expression).\n/// - The caller has ensured that each adjusted limb remains < 2^{246} for\n///   honest witnesses (e.g. via `NUM_PRODUCTS < 64`).\n///\n/// ## Note\n///\n/// This function does not itself enforce any bit-size bounds; it only applies\n/// the borrow encoding. The actual range checks happen later in\n/// `validate_expression_is_zero`.\n///\n/// ## TODO\n/// define trade-offs regarding the value of borrow_shift\n/// (the larger the value, the greater the range check that is required on product_limbs)\n/// (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n/// (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\nfn apply_borrow_flags<let N: u32>(\n    mut expression_limbs: [Field; N],\n    borrow_flags: [bool; N - 1],\n) -> [Field; N] {\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n\n    // Get the product_limbs into the form where each entry is a 246-bit value\n    expression_limbs[0] += (borrow_flags[0] as Field) * borrow_shift;\n    for i in 1..(N - 1) {\n        expression_limbs[i] += (borrow_flags[i] as Field) * borrow_shift\n            - (borrow_flags[i - 1] as Field) * borrow_carry;\n    }\n    expression_limbs[N - 1] -= (borrow_flags[N - 2] as Field) * borrow_carry;\n    expression_limbs\n}\n\n/// Validate that `limbs` represent the integer value `0`\n///\n/// ## Assumptions\n///     - `limbs` is an array of `Field` values that was derived arithmetically as\n///        a degree-2 expression\n///     - each limb satisfies `limbs[i] < 2^{246}`, as ensured by\n///       `compute_quadratic_expression_with_modulus` under its parameter bounds.\n///\n/// ## Details\n/// Each element `i` in `limbs` overlaps in bit-range with element `i+1`, EXCEPT for the low 120 bits\n/// i.e. we need to do the following for each limb `i`:\n///      1. validate the limb's low-120 bits equals zero\n///      2. compute the limb \"carry\" by right-shifting by 2^{120}\n///      3. propagate the \"carry\" into limb `i+1`\n/// We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n///\n/// If the low 120 bits are nonzero, there is no value in `[0, 2^{126})` that\n/// could have produced this limb after multiplying by `2^{120}`. Since\n/// multiplication by `2^{120}` is a bijection on the Field, any limb with\n/// non-zero low 120 bits must map outside the `[0, 2^{126})` range after\n/// scaling by `2^{-120}`.\n///\n/// The most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n///\n/// ## Note\n/// The constant 126 is not arbitrary. We use 120-bit limbs and allow up to 64\n/// products per limb, which contributes at most `log2(64) = 6` bits of headroom.\n/// After scaling by `2^{-120}`, honest witnesses fit in 126 bits. We could in\n/// principle go higher (up to roughly `CircuitModulusBits - 121`), but 126 is\n/// the minimal bound consistent with `NUM_PRODUCTS < 64` and is significantly\n/// cheaper than larger bounds for the barretenberg backend.\nfn validate_expression_is_zero<let N: u32>(mut limbs: [Field; N]) {\n    let hi_shift: Field = TWO_POW_120 as Field;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N - 1 {\n        limbs[i] *= hi_downshift;\n        std::as_witness(limbs[i]);\n        limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        limbs[i + 1] += limbs[i];\n    }\n    assert(limbs[N - 1] == 0);\n}\n\n/// Constrain a degree-2 `BigNum` expression to be equal to 0 (mod `MOD`)\n///\n//\n/// This method is intended for relations where the remainder term of the\n/// degree-2 expression is exactly zero as an integer relation. In other words,\n/// we use it only when we expect:\n///\n///     \\sum (L_i * R_i) + \\sum (A_i) - QUOTIENT * MOD = 0\n///\n/// as integers, not just modulo the circuit field or `BigNum` field.\n///\n/// ## Details\n///\n/// The constrained expression, viewed over the integers, is:\n///\n///       \\sum_{i=0}^{NUM_PRODUCTS-1} (L_i * R_i)\n///     + \\sum_{i=0}^{ADD_N-1} (A_i)\n///     - QUOTIENT * MOD\n///     = 0\n///\n/// Each `L_i`, `R_i`, `A_i` is an `N`-limb `BigNum` assembled from the\n/// `(terms, flags)` arrays. For example, for `i = 0`:\n///\n///     L_0 = \\sum_{j=0}^{LHS_N-1} lhs[0][j]    as a `BigNum`\n///     R_0 = \\sum_{j=0}^{RHS_N-1} rhs[0][j]    as a `BigNum`\n///\n/// The intent is to capture a generic degree-2 expression within Noir's\n/// limitations (no efficient dynamically sized vectors).\n///\n/// The expensive parts of this algorithm are:\n///   1. evaluating the limb products required to compute the `L_i * R_i` values;\n///   2. applying range constraints to validate that the result encodes 0.\n///\n/// ## Note\n/// When the expression is evaluated over `N`-limb `BigNum` values, the product\n/// has up to `2N - 1` significant limbs. Each limb is a sum of at most\n/// `NUM_PRODUCTS` products of `linear` 120-bit limbs and `quadratic` 240-bit-ish limbs\n///\n/// Note that:\n///   * limb-wise multiplication is not uniform across indices. For example:\n///\n///       [x0, x1, x2] * [y0, y1, y2] =\n///       [\n///         x0*y0,                               // 1 term\n///         x0*y1 + x1*y0,                       // 2 terms\n///         x0*y2 + x1*y1 + x2*y0,               // 3 terms\n///         x1*y2 + x2*y1,                       // 2 terms\n///         x2*y2                                // 1 term\n///       ]\n///       The number of partial products per limb grows linearly from 1 to N,\n///       then decreases linearly back to 1.\n///\n///   * we also allow linear combinations inside the products, which further increases the bound\n///     on a `quadratic` limb\n///\n///   * finally, when `is_negative` flag is set, we effectively add 2 * MOD to each limb, where\n///     2 * MOD limbs are structured in such a way that they all are > 2**120\n///\n/// We allow `NUM_PRODUCTS < 64` completeness-wise, but it certainly can overflow the 2^{240 + `twiddle_factor=6`} bound\n/// in edge cases. See completeness section for an example.\n///\n/// ## Assumptions\n///\n/// Each `BigNum` value used in this gadget is already range constrained:\n///   - limbs `0..N-2` satisfy `limb_i < 2^{120}`\n///   - limb `N-1` satisfies `limb_{N-1} < 2^{TOP_LIMB_BITS}`\n///\n/// ## Completeness\n/// If an honest prover supplies inputs that satisfy the assumptions above,\n/// it can always find a `quotient` and `borrow_flags` such that the integer\n/// relation holds and all constraints are satisfied.\n///\n/// The only possibility to break completeness is by providing too many inputs, for example:\n///\n///     (a0 + a1 + a2) * (b0 + b1 + b2) + ... (60 times), with each a_i having its limbs at maximum value of 2^{120} - 1\n///     The middle limb will contain a value that will definitely overflow the 2^{246} bound.\n///\n/// ## Soundness\n/// This function is conditionally sound: it enforces that the degree-2 relation\n/// holds modulo `MOD`, but it does not, by itself, enforce that any particular\n/// term (for example a result `z`) is a *canonical* representative in\n/// `[0, MOD)`.\n///\n/// In other words, if the surrounding relation is invariant under adding a\n/// multiple of `MOD` to one of its terms, then a dishonest prover can exploit\n/// this. For example, consider a multiplication relation:\n///\n///     x * y - z = 0 (mod MOD)\n///\n/// Internally we encode this as:\n///\n///     x * y + 2 * MOD - z - quotient * MOD = 0\n///\n/// which is equivalent to:\n///\n///     x * y - z = (quotient - 2) * MOD\n///\n/// Suppose the honest witness uses some `z` satisfying\n/// `0 <= z < MOD` and some `quotient`. If the `BigNum` encoding allows\n/// `z' = z + MOD` (i.e. `z' < 2^{MOD_BITS}` still holds), then a dishonest\n/// prover can instead provide:\n///\n///     z' = z + MOD\n///     quotient' = quotient - 1\n///\n/// and still satisfy:\n///\n///     x * y + 2 * MOD - z' - quotient' * MOD = 0\n///\n/// even though `z'` is no longer the canonical representative of `x * y mod MOD`.\n///\n/// The same consideration applies to almost every constrained `BigNum` relation:\n/// whenever a value participates *only* through a modular equality, and no\n/// separate range constraint is imposed on that value, the prover is free to\n/// shift it by an extra `MOD` as long as the resulting limb\n/// encoding still satisfies its bit-bounds. This is inherent in working with\n/// modular constraints; the responsibility for enforcing canonical\n/// representatives lies with the caller when it is required.\n///\n/// This is the same \"extra modulus\" phenomenon as in the `add`/`sub` functions:\n/// the constraints are sound for modular arithmetic, but any caller that\n/// requires canonical outputs in `[0, MOD)` must additionally enforce a\n/// range check (for example via `validate_in_field`) on the relevant terms.\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    assert(NUM_PRODUCTS < 64, f\"evaluate_quadratic_expression overflow in operands count\");\n    // NUM_PRODUCTS < 64 is a light bound that tries to ensure each limb sum < 2^{246} so that the 126-bit bound is valid.\n\n    lhs_terms.for_each(|lhs_limbs: [[u128; N]; LHS_N]| {\n        lhs_limbs.for_each(|term: [u128; N]| validate_in_range::<u128, N, MOD_BITS>(term))\n    });\n    rhs_terms.for_each(|rhs_limbs: [[u128; N]; RHS_N]| {\n        rhs_limbs.for_each(|term: [u128; N]| validate_in_range::<u128, N, MOD_BITS>(term))\n    });\n    linear_terms.for_each(|term: [u128; N]| validate_in_range::<u128, N, MOD_BITS>(term));\n\n    let expression_limbs: [Field; 2 * N - 1] = compute_quadratic_expression_with_modulus::<N, MOD_BITS, LHS_N, RHS_N, NUM_PRODUCTS, ADD_N>(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    validate_expression_is_zero(expression_limbs);\n}\n\n// ------------------------------ UDIV MOD EXPRESSION ------------------------------\n\n/// Given a `udiv_mod` `BigNum` expression that is equal to `0` over integers, compute the borrow flags (unconstrained)\n///\n/// Mirror function of `__compute_quadratic_expression_with_borrow_flags` optimized to compute borrow flags of an expression:\n///     divisor * quotient + remainder - numerator = 0\n/// see `__compute_quadratic_expression_with_borrow_flags` for details\n///\n/// The main differences from it are:\n///     1. `product_limbs` stores only the least-significant `N` limbs of\n///         `quotient * divisor + remainder`. This is sufficient to compute the\n///         borrow flags for the first `N` limbs of\n///             quotient * divisor + remainder - numerator.\n///\n///         For an honest `udiv_mod` relation we also have\n///             quotient * divisor <= numerator < B^N,\n///         so the true product fits into `N` limbs as an integer.\n///     2. Instead of subtracting `quotient * MOD` we subtract `numerator`. This is due to the fact that\n///        we no longer work over `MOD`, and we can't really do subtractions as we did previously: `double_modulus - x`\n///\n/// ## Note\n/// We leave the borrow values at 2^{246}, even though we should never reach this bound with just 3 terms\n/// The cases where it can happen are: N >= 64 (middle limb will have 64 additions). And it is a pure completeness issue\n/// But the rest of the library will probably not work with that massive number anyway\nunconstrained fn __compute_udiv_mod_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n    quotient: [u128; N],\n    remainder: [u128; N],\n) -> [bool; N - 1] {\n    let mut product_limbs: [Field; N] = [0; N];\n    let mut numerator_field: [Field; N] = [0; N];\n    for i in 0..N {\n        for j in 0..N - i {\n            product_limbs[i + j] += (quotient[i] as Field) * (divisor[j] as Field);\n        }\n        product_limbs[i] += (remainder[i] as Field);\n\n        numerator_field[i] = numerator[i] as Field;\n    }\n\n    __compute_borrow_flags(product_limbs, numerator_field)\n}\n\n/// Constrained version of `__compute_udiv_mod_expression_with_borrow_flags`\n///\n/// Computes the following expression in-circuit:\n///     quotient * divisor + remainder - numerator = 0\n///\n/// Mirror function of `compute_quadratic_expression_with_modulus`. See it for details.\n///\n/// ## Soundness note\n/// We compute the full convolution `quotient * divisor` into `2N - 1` limbs\n/// and then constrain all limbs with index `i >= N` to be zero. For `i >= N`\n/// the value `expression_limbs_full[i]` is a sum of products\n///     sum_{j+k=i} quotient[j] * divisor[k]\n/// with no contribution from `numerator` or `remainder`.\n///\n/// Every limb of `quotient` and `divisor` is range-constrained to be a 120-bit\n/// integer, so each product term is < 2^{240} and each coefficient of the\n/// convolution is strictly smaller than the field modulus. In this regime,\n/// the constraint `expression_limbs_full[i] == 0` in `Field` coincides with\n/// the same equality over the integers.\n///\n/// Vanishing of all high limbs `i >= N` is therefore an integer statement that\n/// the product has degree < N, i.e.\n///     quotient * divisor < 2^{120 * N},\n/// so `quotient * divisor` fits into `N` 120-bit limbs and does not overflow.\nfn compute_udiv_mod_expression<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n    quotient: [u128; N],\n    remainder: [u128; N],\n) -> [Field; N] {\n    // Safety: use an unconstrained function to compute the value of the quotient and borrow_flags out-of-circuit\n    let borrow_flags: [bool; N - 1] = unsafe {\n        __compute_udiv_mod_expression_with_borrow_flags::<N, MOD_BITS>(\n            numerator,\n            divisor,\n            quotient,\n            remainder,\n        )\n    };\n\n    let mut expression_limbs_full: [Field; 2 * N - 1] = [0; 2 * N - 1];\n    for i in 0..N {\n        for j in 0..N {\n            expression_limbs_full[i + j] += (quotient[i] as Field) * (divisor[j] as Field);\n        }\n        expression_limbs_full[i] += (remainder[i] as Field) - (numerator[i] as Field);\n    }\n\n    let mut expression_limbs: [Field; N] = [0; N];\n    for i in 0..N {\n        expression_limbs[i] = expression_limbs_full[i];\n    }\n    for i in N..2 * N - 1 {\n        assert(expression_limbs_full[i] == 0);\n    }\n\n    apply_borrow_flags(expression_limbs, borrow_flags)\n}\n\n/// Constrain a `udiv_mod` `BigNum` expression to be equal to 0\n///\n/// Mirror function of `evaluate_quadratic_expression`\n///\n/// ## Details\n///\n/// The constrained expression, viewed over the integers, is:\n///\n///     quotient * divisor + remainder - numerator = 0\n///\n/// ## Completeness\n/// If an honest prover supplies valid `BigNum` inputs that satisfy the equation,\n/// it can always find `borrow_flags` such that the integer\n/// relation holds and all constraints are satisfied.\n///\n/// The only possibility to break completeness is by providing a `BigNum` with `N >= 64`\n/// See `__compute_udiv_mod_expression_with_borrow_flags` for details\n///\n/// ## Soundness\n/// This function is conditionally sound: it enforces that the degree-2 relation\n/// holds over the integers, but it does not, by itself, enforce that\n/// this relation is unique for given `numerator` and `divisor`\n///\n/// For example, if the true relation is\n///     quotient * divisor + remainder - numerator = 0\n///\n/// then we can set quotient' = quotient - 1, remainder' = remainder + divisor\npub(crate) fn validate_udiv_mod_expression<let N: u32, let MOD_BITS: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n    quotient: [u128; N],\n    remainder: [u128; N],\n) {\n    validate_in_range::<u128, N, MOD_BITS>(numerator);\n    validate_in_range::<u128, N, MOD_BITS>(divisor);\n    validate_in_range::<u128, N, MOD_BITS>(quotient);\n    validate_in_range::<u128, N, MOD_BITS>(remainder);\n\n    let expression_limbs: [Field; N] =\n        compute_udiv_mod_expression::<N, MOD_BITS>(numerator, divisor, quotient, remainder);\n    validate_expression_is_zero(expression_limbs);\n}\n","path":"/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/expressions.nr"},"90":{"source":"// This file contains the unconstrained helpers that are mostly used by unconstrained ops\n\nuse crate::constants::TWO_POW_120;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __gte, __mul, __neg, __pow, __sqr};\n\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::{__normalize_limbs, __split_120_bits};\n\nuse crate::params::BigNumParams;\n\n// ------------------------------ DERIVATION HELPER FUNCTIONS ------------------------------\n\n///  Construct a `1` BigNum value (unconstrained)\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Construct a BigNum value from Field (unconstrained)\n///\n/// Split the native `Field` value into `N` 120-bit limbs\npub(crate) unconstrained fn __from_field<let N: u32>(val: Field) -> [u128; N] {\n    let mut x: Field = val;\n    let mut result: [u128; N] = [0; N];\n\n    if (N == 1) {\n        let (first_limb, _): (u128, Field) = __split_120_bits(x);\n        result[0] = first_limb;\n    }\n\n    if (N == 2) {\n        let (first_limb, x): (u128, Field) = __split_120_bits(x);\n        let (second_limb, _): (u128, Field) = __split_120_bits(x);\n        result[0] = first_limb;\n        result[1] = second_limb;\n    }\n\n    if (N > 2) {\n        let (first_limb, x): (u128, Field) = __split_120_bits(x);\n        let (second_limb, x): (u128, Field) = __split_120_bits(x);\n        let (third_limb, _): (u128, Field) = __split_120_bits(x);\n        result[0] = first_limb;\n        result[1] = second_limb;\n        result[2] = third_limb;\n    }\n    result\n}\n\n// ------------------------------ ARITHMETIC WITH FLAGS HELPER FUNCTIONS ------------------------------\n// These are the functions that compute modular operations results as well as borrow and carry flags for constraints\n\n/// Compute the `MOD - val` and the corresponding borrow flags (unconstrained)\n///\n/// Negate the value and compute the flags indicating whether we need\n///      to borrow a `bit` from the upper limb when subtracting the value from modulus\n///\n/// ## Note\n/// The `borrow_in` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term: u128 = val[i] + borrow_in;\n        borrow_in = (sub_term > modulus[i]) as u128;\n        result[i] = borrow_in * TWO_POW_120 + modulus[i] - sub_term;\n        if (i < N - 1) {\n            borrow_flags[i] = (borrow_in != 0);\n        }\n    }\n    (result, borrow_flags)\n}\n\n/// Compute modular addition and the corresponding borrow and carry flags (unconstrained)\n///\n/// Given `x, y, MOD` compute x + y or x + y - MOD in case it overflows\n/// Additionally compute all the carries from addition (x + y)\n/// and borrows from subtraction  (- MOD)\n///\n/// ## Note\n/// The `borrow` must be equal to `carry` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N - 1], [bool; N - 1], bool) {\n    let mask: u128 = TWO_POW_120 - 1;\n\n    let add_res: [u128; N] = __helper_add(lhs, rhs);\n    let overflow: bool = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = if overflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N - 1] = [false; N - 1];\n\n    let mut carry: u128 = 0;\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + rhs[i] + carry;\n        carry = add_term >> 120;\n        add_term &= mask;\n\n        let sub_term: u128 = subtrahend[i] + borrow;\n        borrow = (sub_term > add_term) as u128;\n\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n\n        // Only set `borrow` and `carry` if they differ\n        // And if it's not the last limb\n        if (carry != borrow) & (i < N - 1) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\n/// Compute modular subtraction and the corresponding borrow and carry flags (unconstrained)\n///\n/// Given `x, y, MOD` compute x - y or x - y + MOD in case it overflows\n/// Additionally compute all the carries from addition (x + MOD)\n/// and borrows from subtraction  (- y)\n///\n/// ## Note\n/// The `borrow` must be equal to `carry` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N - 1], [bool; N - 1], bool) {\n    let mask: u128 = TWO_POW_120 - 1;\n\n    let underflow: bool = !__gte(lhs, rhs);\n\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N - 1] = [false; N - 1];\n\n    let mut carry: u128 = 0;\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry;\n        carry = add_term >> 120;\n        add_term &= mask;\n\n        let sub_term: u128 = rhs[i] + borrow;\n        borrow = (sub_term > add_term) as u128;\n\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n\n        // Only set `borrow` and `carry` if they differ\n        // And if it's not the last limb\n        if (carry != borrow) & (i < N - 1) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/// Validate that lhs - rhs does not underflow (unconstrained)\n///\n/// Same as `__validate_gte_with_flags`, but we don't compute the\n/// result of a subtraction\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N - 1] {\n    let modulus: [u128; N] = params.modulus;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    borrow_flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        borrow_flags[i] = modulus[i] < val[i] + (borrow_flags[i - 1] as u128);\n    }\n    borrow_flags\n}\n\n/// Validate that lhs - rhs does not underflow (unconstrained)\n///\n/// Compute underflow flag (lhs < rhs)\n///       then perform subtraction with borrow flags\n///\n/// ## Note\n/// The `borrow` must be equal to 0 at the end of the loop.\n/// And it can't be nonzero, since we swap the terms at the beginning\npub(crate) unconstrained fn __validate_gte_with_flags<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N - 1]) {\n    let mut a: [u128; N] = lhs;\n    let mut b: [u128; N] = rhs;\n\n    let underflow: bool = !__gte(lhs, rhs);\n    // swap a and b if there's an underflow\n    let (a, b): ([u128; N], [u128; N]) = if underflow { (b, a) } else { (a, b) };\n\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let mut add_term: u128 = a[i];\n\n        let sub_term: u128 = b[i] + borrow;\n        borrow = (sub_term > add_term) as u128;\n\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, borrow_flags)\n}\n\n// ------------------------------ BARRETT REDUCTION ------------------------------\n\n/// `BARRETT_REDUCTION_OVERFLOW_BITS` defines how large an input to barrett reduction can be\n///\n/// maximum value = modulus^2 << BARRETT_REDUCTION_OVERFLOW_BITS\n/// see __barrett_reduction for more details\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\n/// Optimized modular multiplication (unconstrained)\n///\n/// The trick is to approximate 1/p with m/2**r, because division by 2**r is much cheaper\n/// In our case m = redc_param = floor(2^{MOD_BITS * 2 + BARRET_REDUCTION_OVERFLOW_BITS} / p)\n///             r = MOD_BITS * 2 + BARRET_REDUCTION_OVERFLOW_BITS\n///\n/// When we apply the barrett reduction, the maximum value of the output will be <= p * (1 + x/2^{2k})\n/// where p = modulus,\n///       x = reduction input\n///\n/// If x > p * p, we need k to be larger than modulus_bits()\n/// We hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n/// This should be larger than most values put into `evaluate_quadratic_expression`\n///\n/// ## TODO\n/// Detect cases where x might be too large at comptime\n///\n/// ## Note\n/// very niche edge case error that we need to be aware of:\n///      N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n///      i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow\n///      when calling __barrett_reduction\n///\n/// ## Note on final reduction\n///\n/// Assumptions:\n///  - k = ceil(log2 p), so p <= 2^k\n///  - s = 4, m = redc_param = floor(2^{2*k + s}/p)\n///  - x < 16 * p^2 (x < 2^{2 * k + s})\n///\n/// Let m' = 2^{2*k + s} / p, and write m = m' - \\epsilon, \\epsilon \\in [0, 1)\n//\n/// quo = floor(x * m / 2^{2 * k + s}) = floor(x * m' / 2^{2 * k + s} - x * \\epsilon / 2^{2 * k + s}) =\n/// floor(x / p - x * \\epsilon / 2^{2 * k + s})\n///\n/// Bounds:\n///   quo <= floor(x / p)\n///\n///   floor(a - b) >= floor(a) - ceil(b) (known identity) =>\n///   quo >= floor(x / p) - ceil(x * \\epsilon / 2^{2 * k + s})\n///       >= floor(x / p) - ceil(x / 2^{2 * k + s}) (epsilon < 1)\n///\n/// x / 2^{2 * k + s} < C * p^2 / 2^{2 * k + s} <= C * 2^{2 * k} / 2^{2 * k + s} = C / 2^s\n///\n/// When the assumption holds (C = 16), ceil(x / 2^{2 * k + s}) = 1, for x > 0\n/// Therefore quo = {floor(x/p), floor(x/p) - 1}\n///\n/// In first case: rem = x - quo * p = x - floor(x/p) * p < p\n/// In second case: rem = x - (floor(x/p) - 1) * p = (x - floor(x/p) * p) + p -> need 1 subtraction\n///\n/// ### Note\n/// We allow 64 products to be summed inside the `evaluate_quadratic_expression`\n/// In that case x / 2^{2 * k + s} < 64 / 2^4 = 4 => hence we need to subtract modulus at most 4 times\n/// We can leave it 2 for now as it is unlikely to reach beyond 32 * p^2\n///\n/// In the worst case though, we will have the input > 64 * p^2\n/// (for example (a1 + b1) * (c1 + d1) + ... 64 times)\n/// This is highly unlikely though.\n///\n/// ### TODO:\n/// Possibly change the `BARRETT_REDUCTION_OVERFLOW_BITS` to 6, so that we need only 1 reduction here\n/// However we will have to recompute all the fields `redc_param`s and fix paramgen\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    // TODO: switch to __helper_mul, once the compiler is smart enough to handle this\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(2 * N) {\n        for j in 0..N {\n            mulout_field[i + j] += (x[i] as Field) * (redc_param[j] as Field);\n        }\n    }\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field);\n\n    let quotient: [u128; 3 * N] = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // Remove a bunch of zeros from the end\n    let mut smaller_quotient: [u128; N] = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // long_quotient_mul_modulus can never exceed input value `x` so can fit into size-2 array\n    let long_quotient_mul_modulus: [u128; 2 * N] = __helper_mul(smaller_quotient, modulus);\n    let long_remainder: [u128; 2 * N] = __helper_sub(x, long_quotient_mul_modulus);\n\n    // Remove a bunch of zeros from the end\n    let mut remainder: [u128; N] = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n\n    for _ in 0..2 {\n        if (__gte(remainder, modulus)) {\n            remainder = __helper_sub(remainder, modulus);\n            smaller_quotient = __increment(smaller_quotient);\n        }\n    }\n\n    (smaller_quotient, remainder)\n}\n\n// ------------------------------ ARITHMETIC HELPER FUNCTIONS ------------------------------\n// These are the functions that operate on limbs as if they were just big integers\n\n/// Adds `1` to the BigNum value without modular reduction (unconstrained)\n///\n/// ## Note\n/// The `carry` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mask: u128 = TWO_POW_120 - 1;\n\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let add_term: u128 = val[i] + carry;\n        carry = add_term >> 120;\n        result[i] = add_term & mask;\n    }\n    result\n}\n\n/// Adds two `BigNum` values without modular reduction (unconstrained).\n///\n/// ## Note\n/// The `carry` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry: u128 = 0;\n    let mask: u128 = TWO_POW_120 - 1;\n\n    for i in 0..N {\n        let add_term: u128 = lhs[i] + rhs[i] + carry;\n        carry = add_term >> 120;\n        result[i] = add_term & mask;\n    }\n    result\n}\n\n/// Subtracts two `BigNum` values without modular reduction (unconstrained).\n///\n/// ## Note\n/// The `borrow` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let mut borrow: u128 = 0;\n    for i in 0..N {\n        let subtrahend: u128 = rhs[i] + borrow;\n        borrow = (subtrahend > lhs[i]) as u128;\n        result[i] = (borrow << 120) + lhs[i] - subtrahend;\n    }\n    result\n}\n\n/// Multiplies two `BigNum` values without modular reduction (unconstrained).\n///\n/// Computes the full schoolbook product of two N-limb little-endian arrays\n///\n/// ## Note\n/// The mathematical product fits in `2 * N - 1` limbs, but we keep `2 * N`\n/// limbs intentionally as the extra high limb safely absorbs a possible single limb overflow\n/// for moduli close to `120 * N` bits.\npub(crate) unconstrained fn __helper_mul<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; 2 * N] {\n    let mut result: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            result[i + j] += (lhs[i] as Field) * (rhs[j] as Field);\n        }\n    }\n    __normalize_limbs(result)\n}\n\n// ------------------------------ LOGIC HELPER FUNCTIONS ------------------------------\n// These are the functions that operate on limbs as if they were just big integers\n\n/// Left-shifts a `BigNum` value by `shift` bits (unconstrained).\n///\n/// Performs a bitwise left shift across limbs.\n///\n/// ## Note\n/// The most significant limb is truncated to 120 bits after the shift.\n///\n/// No bounds check is performed on `num_shifted_limbs`.\n/// However, we use it only in `__udiv_mod`, where it is not possible to reach\n/// `num_shifted_limbs` > `N`\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs: u32 = shift / 120;\n    let limb_shift: u128 = (shift % 120) as u128;\n    let remainder_shift: u128 = 120 - limb_shift;\n\n    let mask: u128 = TWO_POW_120 - 1;\n    let mut remainder: u128 = input[0] >> remainder_shift;\n\n    result[num_shifted_limbs] = (input[0] << limb_shift) & mask;\n\n    for i in 1..(N - num_shifted_limbs) {\n        let value: u128 = input[i];\n        let upshift: u128 = ((value << limb_shift) | remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = value >> remainder_shift;\n    }\n    result\n}\n\n/// Right-shifts a `BigNum` value by `shift` bits (unconstrained).\n///\n/// Performs a bitwise right shift across limbs.\n///\n/// # Note\n/// No bounds check is performed on `num_shifted_limbs`.\n/// However, we use it only in `__tonelli_shanks_sqrt`, where it is not possible to reach\n/// `num_shifted_limbs` > `N`\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs: u32 = shift / 120;\n    let limb_shift: u128 = (shift % 120) as u128;\n\n    let remainder_shift: u128 = 120 - limb_shift;\n    let low_mask: u128 = (1 as u128 << limb_shift) - 1;\n\n    result[0] = input[num_shifted_limbs] >> limb_shift;\n    for i in 1..(N - num_shifted_limbs) {\n        let value: u128 = input[i + num_shifted_limbs];\n\n        let carry: u128 = (value & low_mask) << remainder_shift;\n        result[i - 1] |= carry;\n\n        result[i] = value >> limb_shift;\n    }\n    result\n}\n\n/// Right-shifts a `BigNum` value by `1` bit  (unconstrained)\n///\n/// # Note\n/// All the operations on limbs are executed in place\n/// to save opcodes\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value: u128 = input[N - 1];\n    let mut remainder: u128 = (value & 1) << 119;\n    input[N - 1] >>= 1;\n\n    for i in 1..N {\n        let value: u128 = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) | remainder;\n        remainder = (value & 1) << 119;\n    }\n    input\n}\n\n/// Returns the index of the most significant set bit in a `BigNum` value (unconstrained).\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count: u32 = 0;\n    for i in 0..N {\n        let idx: u32 = N - 1 - i;\n        let v: u128 = val[idx];\n        if (v > 0) {\n            count = 120 * idx + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\n/// Returns `true` if the bit at position `bit` is set in the `BigNum` (unconstrained).\n///\n/// ## Note\n/// No bounds check is performed on `bit`\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index: u128 = (bit % 120) as u128;\n\n    let limb: u128 = input[segment_index];\n    let value: u128 = (limb >> uint_index) & 1;\n    value == 1\n}\n\n// ------------------------------ SQRT HELPER FUNCTIONS ------------------------------\n// These are the functions that are used during taking a square root\n\n/// Compute the maximal power of 2 that divides the group order (unconstrained)\n///\n/// Find the maximum value s such that `MOD = 2^s * q + 1`, where `q` is odd\n///       This is needed for our Tonelli-Shanks sqrt algorithm\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n) -> u32 {\n    let mut target: [u128; N] = __helper_sub(params.modulus, __one());\n    let mut result: u32 = 0;\n    while !__get_bit(target, result) {\n        result += 1;\n    }\n    result\n}\n\n/// Find a quadratic non-residue `g` where `g` is the smallest such value (unconstrained)\n///       i.e. smallest `g` such that `g^{(p - 1)/2} = -1 (mod MOD)`\n///       or smallest `g`, such that `x^2 - g = 0 (mod MOD)` has no solutions\n///\n/// ## Note\n/// WARNING If the field is not prime, this function will enter an infinite loop!\npub(crate) unconstrained fn __quadratic_non_residue<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n) -> [u128; N] {\n    let one: [u128; N] = __one();\n    let neg_one: [u128; N] = __neg(params.modulus, one);\n\n    let p_minus_one_over_two: [u128; N] = __shr1(__helper_sub(params.modulus, __one()));\n\n    // We start with 2\n    let mut target: [u128; N] = __increment(one);\n    let mut expd: [u128; N] = __pow(params, target, p_minus_one_over_two);\n    while !__eq(expd, neg_one) {\n        target = __increment(target);\n        expd = __pow(params, target, p_minus_one_over_two);\n    }\n    target\n}\n\n/// Compute the smallest `i`, such that `t^{2^i} = 1, t^{2^{i-1}} = -1 (mod MOD)` (unconstrained)\n///\n/// ## Note\n/// Multiplicative order of t must divide 2^v2(MOD-1), otherwise you'll end up in an infinite loop!\npub(crate) unconstrained fn __tonelli_shanks_sqrt_find_i<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    t: [u128; N],\n) -> u32 {\n    let one: [u128; N] = __one();\n    let mut c: [u128; N] = t;\n\n    let mut i: u32 = 0;\n    // Compute t^{2^k} until it hits 1 for the first time\n    while !__eq(c, one) {\n        c = __sqr::<N, MOD_BITS>(params, c);\n        i += 1;\n    }\n    i\n}\n","path":"/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/unconstrained_helpers.nr"},"91":{"source":"// This file contains the unconstrained operations that are used directly by BigNum class\n\nuse crate::fns::constrained_ops::derive_from_seed;\n\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_mul, __helper_sub,\n    __increment, __one, __primitive_root_log_size, __quadratic_non_residue, __shl, __shr, __shr1,\n    __tonelli_shanks_sqrt_find_i,\n};\n\nuse crate::constants::TWO_POW_120;\n\nuse crate::params::BigNumParams;\n\n// ------------------------------ DERIVATION FUNCTIONS ------------------------------\n\n/// Deterministically derives a `BigNum` from a seed value (unconstrained)\n///\n/// Takes a seed byte array and generates a `BigNum` in the range [0, modulus-1].\n///\n/// See more information in `constrained_ops.nr`: `derive_from_seed`\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed)\n}\n\n// ------------------------------ COMPARISON FUNCTIONS ------------------------------\n\n/// Compare two limb arrays for equality (unconstrained)\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\n/// Compare a limb array to a zero array (unconstrained)\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    limbs == [0; N]\n}\n\n/// Compare two little-endian limb arrays for `lhs >= rhs` over integers (unconstrained)\n///\n/// Starts from the most significant limb (`N - 1`) and returns true\n/// if `lhs` is greater or equal to `rhs`\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        let idx: u32 = N - 1 - i;\n        if (lhs[idx] != rhs[idx]) {\n            result = lhs[idx] > rhs[idx];\n            break;\n        }\n    }\n    result\n}\n\n// ------------------------------ ARITHMETIC FUNCTIONS ------------------------------\n\n/// Negates a `BigNum` value, returning `m - x` (unconstrained)\n///\n/// ## Note\n/// The input is assumed to be less than modulus\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\n/// Adds two `BigNum` values with modular reduction (unconstrained)\n///\n/// Sums the limbs one by one, keeping the carry.\n/// In case the result overflows the modulus, the modulus is subtracted once\n///\n/// ## Note\n/// The `carry` must be `0` at the end of the loop.\n/// No explicit assertion is made, as this condition is validated during evaluation.\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    let mask: u128 = TWO_POW_120 - 1;\n\n    for i in 0..N {\n        let add_term: u128 = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        result[i] = add_term & mask;\n    }\n\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/// Subtracts two `BigNum` values with modular reduction (unconstrained).\n///\n/// Computes `x + (m - y)` (mod m)\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\n/// Multiply `x` and `y` and reduce via Barrett, returning (Q, R) (unconstrained).\n///\n/// For `BigNum` values `x` and `y` compute (`Q`, `R`) such that:\n///      x * y = R + Q * m, 0 <= R < m\n/// See `__barrett_reduction` for details.\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let to_reduce: [u128; N * 2] = __helper_mul(lhs, rhs);\n    let (q, r): ([u128; N], [u128; N]) =\n        __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\n/// Multiplies two `BigNum` values with modular reduction (unconstrained).\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __mul_with_quotient::<N, MOD_BITS>(params, lhs, rhs).1\n}\n\n/// Squares a `BigNum` value with modular reduction (unconstrained).\npub(crate) unconstrained fn __sqr<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    __mul_with_quotient::<N, MOD_BITS>(params, val, val).1\n}\n\n/// Modular exponentiation via square-and-multiply. LSB-first (unconstrained).\n///\n/// Computes `x^e mod m`\n///\n/// ## Note\n/// For the loop, we are using `MOD_BITS` instead of `__get_msb`\n/// because it is much much cheaper\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let mut accumulator: [u128; N] = __one();\n    let mut x: [u128; N] = val;\n    let num_bits: u32 = MOD_BITS + 1;\n\n    for i in 0..num_bits {\n        if __get_bit(exponent, i) {\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, x);\n        }\n        x = __sqr::<N, MOD_BITS>(params, x);\n    }\n    accumulator\n}\n\n/// Given a `BigNum` value `x` compute x^{-1} (mod m) (unconstrained)\n///\n/// x^{p-1} = 1 (mod p) (Fermat's little theorem)\n/// x^{p-2} = x^{-1} (mod p)\n///\n/// ## Note\n/// The input value must be nonzero and modulus has to be prime\n/// No explicit assertion is made, as this condition is validated during evaluation\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one: [u128; N] = __one();\n    let exp: [u128; N] = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<N, MOD_BITS>(params, val, exp)\n}\n\n/// Divides two `BigNum` values with modular reduction (unconstrained).\n///\n/// Computes `x * y^{-1}` (mod m)\n///\n/// ## Note\n/// The divisor must be nonzero\n/// No explicit assertion is made, as this condition is validated during evaluation\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<N, MOD_BITS>(params, divisor);\n    __mul::<N, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/// Given the `BigNum` inputs `x, y`, compute integer division x / y (unconstrained)\n///\n/// This function implements binary long division and outputs (`quotient`, `remainder`) such that:\n///   1. floor(numerator / divisor) = quotient\n///   2. numerator % divisor = remainder\n///   3. divisor * quotient + remainder = numerator\n///\n/// ## Note\n/// The divisor must be nonzero\n/// No explicit assertion is made, as this condition is validated during evaluation\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n    let b: [u128; N] = divisor;\n\n    let numerator_msb: u32 = __get_msb(numerator);\n    let divisor_msb: u32 = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference: u32 = __get_msb(remainder) - __get_msb(divisor);\n        let mut divisor: [u128; N] = __shl(divisor, bit_difference);\n        let mut accumulator: [u128; N] = __shl(__one(), bit_difference);\n\n        // The same as divisor > remainder\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        (quotient, remainder)\n    }\n}\n\n/// Batch modular inversion of `BigNum` values in an array (unconstrained)\n///\n/// Given values v[0..M), returns inv[0...M) with inv[i] = v[i]^{-1} (mod m)\n///\n/// We use the Montgomery trick:\n/// First we compute the partial products:\n///         T0 = 1\n///         T1 = v1,\n///         T2 = v1 * v2,\n///         ...\n///         T_{m - 1} = T_{m - 2} * v_{m - 1} = v1 * ... * v_{m - 1}\n///\n///         P = T_{m-1} * v_m = v1 * v2 * ... * v_m\n///\n/// Then we calculate a single inverse P^-1 = v1^-1 * v2^-1 * ... * v_m^-1\n/// Finally we compute\n///         v_m^-1       = (P^-1 * T_{m-1})\n///         v_{m - 1}^-1 = (P^-1 * v_m * T_{m - 2})\n///         ....\n///         v_2^-1       = (P^-1 * v_m * ... * v_3 * T_1)\n///         v_1^-1       = (P^-1 * v_m * ... * v_2 * T_0)\n///\n/// ## Note\n/// Zero elements are allowed and are left unchanged in the resulting array\n///\n/// This interacts poorly with `neg(zero)`:\n/// Calling `neg` on `zero` yields `modulus` rather than `0`.\n/// A value in this form will **not** satisfy\n/// the `__is_zero` check and will lead to incorrect results.\n///\n/// This edge case should be rare, but it's worth keeping in mind when\n/// composing operations or debugging unexpected behavior\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    vals: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    let mut accumulator: [u128; N] = __one();\n    let mut temporaries: [[u128; N]; M] = [[0; N]; M];\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(vals[i])) {\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<N, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx: u32 = M - 1 - i;\n        if (!__is_zero(vals[idx])) {\n            let T0: [u128; N] = __mul::<N, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\n/// Batch modular inversion of `BigNum` values in a slice (unconstrained)\n///\n/// See `batch_invert` for details\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    vals: [[u128; N]],\n) -> [[u128; N]] {\n    let mut accumulator: [u128; N] = __one();\n    let mut temporaries: [[u128; N]] = &[];\n\n    let M: u32 = vals.len();\n\n    for i in 0..M {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(vals[i])) {\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<N, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx: u32 = M - 1 - i;\n        if (!__is_zero(vals[idx])) {\n            let T0: [u128; N] = __mul::<N, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<N, MOD_BITS>(params, accumulator, vals[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        }\n    }\n\n    result\n}\n\n/// Compute a modular square root in a prime field (unconstrained)\npub(crate) unconstrained fn __sqrt<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum::__sqrt: Must be a field to take square roots\",\n    );\n\n    if (__is_zero(input)) {\n        Option::some(input)\n    } else if (params.modulus[0] % 4 == 3) {\n        __easy_sqrt(params, input)\n    } else {\n        __tonelli_shanks_sqrt(params, input)\n    }\n}\n\n/// Compute a modular square root using the Tonelli-Shanks algorithm (unconstrained)\n///\n/// Solves `x^2 = a (mod MOD)` for odd prime MOD\n///\n/// ## Algorithm\n///\n/// Here p = MOD\n///\n/// Tonelli-Shanks setup\n///\n/// Write `p - 1 = 2^s * Q`, `Q` - odd\n/// Define:\n///    `R = a^{(Q+1)/2}`\n///    `t = a^Q`\n///\n/// so that `R^2 = a^{Q + 1} = a * a^Q = a * t`\n/// If t = 1, we are done\n///\n/// By Euler's criterion, `a` is a quadratic reside iff `a^{(p - 1)/2} = 1`\n/// Since `t = a^Q` and `(p - 1) / 2 = Q * 2^{s-1}` we have:\n///    `t^{2^{s-1}} = a^{Q * 2^{s-1}} = a^{(p-1)/2} = 1`, assuming `a` is a q.r.\n///\n/// To proceed with computing our square root, we want to transfer `t` into a smaller subgroup,\n/// specifically, the `2^(s-2)`'th roots of unity or lower.\n///\n/// We do this by finding some value `b`, such that\n/// `(t * b^2)^{2^{s-2}} = 1` and `R' = R * b`\n/// Finding such a `b` is trivial, because from Euler's criterion, we know that,\n/// for any quadratic non-residue `z`, `z^{(p - 1) / 2} = -1`\n/// i.e. `z^{Q * 2^{s-1}} = -1`\n/// => `z^Q` is a `2^{s-1}`'th root of `-1`\n/// => `z^{2 * Q}` is a `2^{s-2}`'th root of `-1`\n///\n/// Since `t^{2^{s-1}} = 1`, we know that for some `i`, `i <= s - 2: t^{2^{i-1}} = -1`\n/// => `t * z^{2 * Q}` is a `2^{s - 2}`'th root of unity.\n/// We can iteratively transform `t` into ever smaller subgroups, until `t = 1`.\n/// At each iteration, we need to find a new value for `b`, which we can obtain\n/// by repeatedly squaring `z^Q`\n///\n/// ## Note\n/// Only use for prime fields! Function may infinite loop if used for non-prime fields\n///\n/// The input is assumed to be a nonzero value\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    let mut result: Option<[u128; N]> = Option::none();\n\n    let one: [u128; N] = __one();\n    let s: u32 = __primitive_root_log_size::<N, MOD_BITS>(params); // p - 1 = 2^s * Q, where Q is odd\n    let Q: [u128; N] = __shr(__helper_sub(params.modulus, one), s);\n    let Q_minus_one_over_two: [u128; N] = __shr1(__helper_sub(Q, one)); // (Q - 1) / 2\n\n    let z: [u128; N] = __quadratic_non_residue::<N, MOD_BITS>(params);\n\n    // Initialize:\n    // b = a^{(Q - 1)/2}\n    // R = a * b = a^{(Q + 1) / 2} => R^2 = a * a^Q\n    // t = R * b = a^Q\n    let mut b: [u128; N] = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r: [u128; N] = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t: [u128; N] = __mul::<_, MOD_BITS>(params, r, b);\n\n    let mut check: [u128; N] = t;\n    // Assure t^{2^{s - 1}} = a^{(p -1)/2} = 1, otherwise we have met a non-residue\n    for _ in 0..s - 1 {\n        check = __sqr::<N, MOD_BITS>(params, check);\n    }\n    if (__eq(check, one)) {\n        let mut m: u32 = s;\n        let mut c: [u128; N] = __pow::<N, MOD_BITS>(params, z, Q); // z^Q - proper 2^{M}'th root of unity\n\n        // Tonelli-Shanks main loop\n\n        // At the beginning of each iteration we have:\n        // M - current exponent such that t lies in the subgroup of order 2^m\n        // t - element, whose order divides 2^m\n        // c - the proper 2^M'th root of unity\n        // R - accumulator with R^2 = a * t\n\n        // If t == 1, we are done and R is a square root\n        //\n        // Otherwise\n        // 1. We compute 1 <= i < M, such that t^{2^i} = 1, t^{2^{i - 1}} = -1\n        // 2. Set b = c^{2^{M - i - 1}}, so it becomes a proper 2^(i+1)'th root of unity\n        //      Then b^2 has order 2^i which matches the order of t\n        //\n        // 3. Update the state values:\n        //    R <- R * b\n        //    t <- t * b^2\n        //    c <- b^2 = c^{2^{M - i}}\n        //    M <- i\n        // reduces the order of t from 2^i to at most 2^{i - 1} and preserves R^2 = a * t\n        //\n        // The loop runs at most s times because M strictly decreases\n        for _ in 0..s {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let i: u32 = __tonelli_shanks_sqrt_find_i::<N, MOD_BITS>(params, t);\n            let mut j: u32 = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                b = __sqr(params, b);\n            }\n\n            let b2: [u128; N] = __sqr::<N, MOD_BITS>(params, b);\n            c = b2;\n            t = __mul::<N, MOD_BITS>(params, t, b2);\n            r = __mul::<N, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\n/// Compute a modular square root for MOD = 3 (mod 4) (unconstrained)\n///\n/// In case MOD = 3 (mod 4), the square root can be computed using the formula:\n///     `R = a^{(MOD + 1) / 4} (mod MOD)`\n///\n/// Then R^2 = a^{(MOD + 1)/ 4 * 2} = a^{(MOD + 1) / 2} = a^{(MOD - 1) / 2 + 1} = a\n///\n/// ## Note\n/// The input is assumed to be a nonzero value\n///\n/// This is much cheaper than `__tonelli_shanks_sqrt`\npub(crate) unconstrained fn __easy_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    let mut result: Option<[u128; N]> = Option::none();\n\n    let one: [u128; N] = __one();\n    let p_minus_one_over_two: [u128; N] = __shr1(__helper_sub(params.modulus, one));\n    let mut check: [u128; N] = __pow(params, input, p_minus_one_over_two);\n    if (__eq(check, one)) {\n        // a = (MOD - 1) / 2\n        // b = (a + 1) / 2 = ((MOD - 1) / 2 + 1) / 2 = (MOD + 1) / 4\n        let p_plus_one_over_four: [u128; N] = __shr1(__increment(p_minus_one_over_two));\n        result = Option::some(__pow(params, input, p_plus_one_over_four));\n    }\n    result\n}\n","path":"/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/fns/unconstrained_ops.nr"},"100":{"source":"use std::ops::WrappingMul;\n\nglobal MUL_DE_BRUIJN_BIT: [u32; 128] = [\n    1, 14, 2, 15, 26, 20, 3, 16, 68, 80, 27, 21, 56, 50, 4, 17, 65, 96, 69, 81, 105, 99, 28, 22, 86,\n    90, 57, 51, 72, 42, 5, 126, 18, 66, 48, 94, 97, 84, 70, 124, 82, 122, 106, 100, 114, 108, 29,\n    23, 77, 102, 87, 91, 119, 116, 58, 52, 61, 110, 73, 37, 43, 31, 6, 127, 13, 25, 19, 67, 79, 55,\n    49, 64, 95, 104, 98, 85, 89, 71, 41, 125, 47, 93, 83, 123, 121, 113, 107, 76, 101, 118, 115, 60,\n    109, 36, 30, 12, 24, 78, 54, 63, 103, 88, 40, 46, 92, 120, 112, 75, 117, 59, 35, 11, 53, 62, 39,\n    45, 111, 74, 34, 10, 38, 44, 33, 9, 32, 8, 7, 128,\n];\n\n/// Get the most significant bit position of a `val` (unconstrained)\n///\n/// Bit hack that uses De Bruijn sequence to calculate msb position in log(N)\n/// See [IntegerLog2DeBruijn](https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogDeBruijn)\npub(crate) unconstrained fn get_msb(x: u128) -> u32 {\n    let result: u32 = if x == 0 {\n        0\n    } else {\n        let mut v: u128 = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        v |= v >> 64;\n        let index: u128 = (v.wrapping_mul(0x1FC10C2FBCF471B913B14CD2595D6D5)) >> 121;\n        MUL_DE_BRUIJN_BIT[index as u32]\n    };\n    result\n}\n\nmod tests {\n    use crate::constants::{TWO_POW_120, TWO_POW_60};\n    use crate::fns::unconstrained_helpers::__get_msb;\n    use super::get_msb as get_msb128;\n    use std::ops::WrappingMul;\n\n    fn assert_msb_equal(x: u64) {\n        // Safety: test code\n        let msb64 = unsafe { get_msb64(x) };\n        // Safety: test code\n        let msb128 = unsafe { get_msb128(x as u128) };\n        assert_eq(msb64, msb128);\n    }\n\n    #[test]\n    /// Check that the msb functions are equivalent with de bruijn sequence for 64 bits and 128 bits\n    fn test_get_msb() {\n        // Test case 1: MSB at position 7\n        let x: u64 = 0x80; // binary: 10000000\n        assert_msb_equal(x);\n\n        // Test case 2: MSB at position 0\n        let x: u64 = 0x1; // binary: 00000001\n        assert_msb_equal(x);\n\n        // Test case 3: MSB at position 63\n        let x: u64 = 0x8000000000000000; // binary: 1000...0000 (63 zeros)\n        assert_msb_equal(x);\n\n        // Test case 4: Zero input\n        let x: u64 = 0x0;\n        assert_msb_equal(x);\n\n        // Test case 5: All bits set\n        let x: u64 = 0xFFFFFFFFFFFFFFFF;\n        assert_msb_equal(x);\n    }\n\n    /// Multiple entires in the `MUL_DE_BRUIJN_BIT` list do not map to a valid output of `v * 0x6c04f118e9966f6b`.\n    /// This is a dummy value to fill the gaps in the map.\n    global n1: u32 = 0xffffffff;\n\n    global MUL_DE_BRUIJN_BIT_64: [u32; 128] = [\n        0, // change to 1 if you want bitSize(0) = 1\n        48, n1, n1, 31, n1, 15, 51, n1, 63, 5, n1, n1, n1, 19, n1, 23, 28, n1, n1, n1, 40, 36, 46,\n        n1, 13, n1, n1, n1, 34, n1, 58, n1, 60, 2, 43, 55, n1, n1, n1, 50, 62, 4, n1, 18, 27, n1,\n        39, 45, n1, n1, 33, 57, n1, 1, 54, n1, 49, n1, 17, n1, n1, 32, n1, 53, n1, 16, n1, n1, 52,\n        n1, n1, n1, 64, 6, 7, 8, n1, 9, n1, n1, n1, 20, 10, n1, n1, 24, n1, 29, n1, n1, 21, n1, 11,\n        n1, n1, 41, n1, 25, 37, n1, 47, n1, 30, 14, n1, n1, n1, n1, 22, n1, n1, 35, 12, n1, n1, n1,\n        59, 42, n1, n1, 61, 3, 26, 38, 44, n1, 56,\n    ];\n\n    pub(crate) unconstrained fn get_msb64(x: u64) -> u32 {\n        let mut v: u64 = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        let index: u64 = (v.wrapping_mul(0x6c04f118e9966f6b)) >> 57;\n        (index as Field).assert_max_bit_size::<32>();\n        MUL_DE_BRUIJN_BIT_64[index as u32]\n    }\n\n    unconstrained fn __get_msb64<let N: u32>(val: [u128; N]) -> u32 {\n        let mut count: u32 = 0;\n        for i in 0..N {\n            let v: u128 = val[((N) - 1 - i)];\n            let v_low: u64 = v as u64 % TWO_POW_60 as u64;\n            let v_high: u64 = ((v - v_low as u128) / TWO_POW_60) as u64;\n            if (v_high > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n                break;\n            }\n            if (v_low > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n                break;\n            }\n        }\n        count\n    }\n\n    #[test]\n    // Check that the msb functions are equivalent with De Bruijn sequence for 64 bits and 128 bits\n    unconstrained fn test_get_msb_equivalence() {\n        // Test single limb (64-bit number)\n        let x: Field = 0x8000000000000000;\n        let arr: [u128; 4] = [0, 0, x as u128, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test multiple limbs (120-bit number)\n        let x: Field = 0x800000000000000000000000000000; // 120 bits number, 2^119\n        let arr: [u128; 4] = [0, 0, x as u128, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test zero\n        let arr: [u128; 4] = [0, 0, 0, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test all bits set (120 bits)\n        let x: Field = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // 120 bits, 2^120 - 1\n        let arr: [u128; 4] = [0, x as u128, 0, 0];\n        let msb1: u32 = __get_msb64(arr);\n        let msb2: u32 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test systematic bit positions\n        for i in 0..120 {\n            let x: u128 = 1;\n            let shifted: u128 = x << i;\n            let arr: [u128; 4] = [0, shifted, 0, 0];\n            let msb1: u32 = __get_msb64(arr);\n            let msb2: u32 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test random-like patterns (multiple bits set)\n        let patterns: [Field; 7] = [\n            0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // alternating bits\n            0x555555555555555555555555555555, // alternating bits (opposite)\n            0x1234567890ABCDEF1234567890ABCD, // some pattern\n            0xFEDCBA0987654321FEDCBA09876543, // some pattern\n            0x800000000000000000000000000001, // highest and lowest bits\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE, // all bits except lowest\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFF, // all bits except highest\n        ];\n        for i in 0..patterns.len() {\n            let arr: [u128; 4] = [0, patterns[i] as u128, 0, 0];\n            let msb1: u32 = __get_msb64(arr);\n            let msb2: u32 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test with MSB in different array positions (120 bits)\n        let x: Field = 0x800000000000000000000000000000; // 120 bits\n        let arr1: [u128; 4] = [x as u128, 0, 0, 0];\n        let arr2: [u128; 4] = [0, x as u128, 0, 0];\n        let arr3: [u128; 4] = [0, 0, x as u128, 0];\n        let arr4: [u128; 4] = [0, 0, 0, x as u128];\n        let msb1_1: u32 = __get_msb64(arr1);\n        let msb2_1: u32 = __get_msb(arr1);\n        assert_eq(msb1_1, msb2_1);\n\n        let msb1_2: u32 = __get_msb64(arr2);\n        let msb2_2: u32 = __get_msb(arr2);\n        assert_eq(msb1_2, msb2_2);\n\n        let msb1_3: u32 = __get_msb64(arr3);\n        let msb2_3: u32 = __get_msb(arr3);\n        assert_eq(msb1_3, msb2_3);\n\n        let msb1_4: u32 = __get_msb64(arr4);\n        let msb2_4: u32 = __get_msb(arr4);\n        assert_eq(msb1_4, msb2_4);\n    }\n\n    #[test]\n    unconstrained fn fuzz_get_msb(seed: [u128; 5]) {\n        let mut seed_copy: [u128; 5] = seed;\n        for i in 0..5 {\n            seed_copy[i] = seed_copy[i] & (TWO_POW_120 - 1);\n        }\n        let msb1: u32 = __get_msb64(seed_copy);\n        let msb2: u32 = __get_msb(seed_copy);\n        assert_eq(msb1, msb2);\n    }\n}\n","path":"/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/utils/msb.nr"},"101":{"source":"use crate::constants::TWO_POW_120;\n\n/// Split the Field value into two 120-bit limbs (unconstrained)\n///\n/// Here we're taking advantage of truncating 120 bit limbs from the input field\n/// and then subtracting them from the input such that the field division is equivalent\n/// to integer division.\n///\n/// We return the lower 120-bit limb as a `u128` value,\n/// and the upper limbs as a `Field`, to avoid unnecessary conversions\n/// and potential overflows\npub(crate) unconstrained fn __split_120_bits(mut x: Field) -> (u128, Field) {\n    let low: u128 = (x as u128) % TWO_POW_120;\n    let high: Field = ((x - low as Field) / TWO_POW_120 as Field);\n    (low, high)\n}\n\n/// Normalize an array of Field values into 120-bit limbs (unconstrained)\n///\n/// Each Field element is split into two parts modulo 2^{120}\n/// The overflow from the lower limbs is carried into the higher limbs\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(input: [Field; N]) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(N - 1) {\n        let (lo, hi): (u128, Field) = __split_120_bits(next);\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    let (lo, hi): (u128, Field) = __split_120_bits(next);\n    normalized[N - 1] = lo;\n\n    // non-zero final carry <=> normalized value overflows the array length\n    assert(hi == 0);\n\n    normalized\n}\n","path":"/home/code/nargo/github.com/noir-lang/noir-bignum/v0.8.3/src/utils/split_bits.nr"},"115":{"source":"use crate::bn254::permute_bn254;\nuse crate::bn254::consts;\nuse dep::hash_utils::poseidon;\nuse dep::std::collections::vec::Vec;\n\nfn internal_2(state: [Field; 2]) -> [Field; 2] {\n    let sum = state[0] + state[1];\n    [sum + state[0], sum + 2 * state[1]]\n}\n\nfn internal_3(state: [Field; 3]) -> [Field; 3] {\n    let sum = state.reduce(|a, b| a + b);\n    let mut ret_val = [0; 3];\n    ret_val[0] = state[0] + sum;\n    ret_val[1] = state[1] + sum;\n    ret_val[2] = 2 * state[2] + sum;\n    ret_val\n}\n\nfn external_3(mut state: [Field; 3]) -> [Field; 3] {\n    let sum = state.reduce(|a, b| a + b);\n    state[0] += sum;\n    state[1] += sum;\n    state[2] += sum;\n    state\n}\n\nfn external<let T: u32>(mut state: [Field; T]) -> [Field; T] {\n    let mut mds_parts: Vec<[Field; 4]> = Vec::new();\n    for i in 0..T / 4 {\n        let offset = (4 * i);\n        mds_parts.push(poseidon::mds_4([\n            state[0 + offset],\n            state[1 + offset],\n            state[2 + offset],\n            state[3 + offset],\n        ]))\n    }\n    for i in 0..T / 4 {\n        for j in 0..4 {\n            state[i * 4 + j] = mds_parts.get(i)[j];\n        }\n    }\n\n    let mut stored = [0; 4];\n    for l in 0..4 {\n        stored[l] = mds_parts.get(0)[l];\n        for j in 1..T / 4 {\n            stored[l] += mds_parts.get(j)[l];\n        }\n    }\n    for i in 0..T / 4 {\n        for j in 0..4 {\n            state[i * 4 + j] += stored[j];\n        }\n    }\n\n    state\n}\n\nfn internal_4(mut state: [Field; 4]) -> [Field; 4] {\n    diag_mat_mul(state, consts::internal_diag4)\n}\n\nfn internal_8(mut state: [Field; 8]) -> [Field; 8] {\n    diag_mat_mul(state, consts::internal_diag8)\n}\n\nfn internal_12(mut state: [Field; 12]) -> [Field; 12] {\n    diag_mat_mul(state, consts::internal_diag12)\n}\n\nfn internal_16(mut state: [Field; 16]) -> [Field; 16] {\n    diag_mat_mul(state, consts::internal_diag16)\n}\n\nfn diag_mat_mul<let T: u32>(mut state: [Field; T], diag: [Field; T]) -> [Field; T] {\n    let sum = state.reduce(|a, b| a + b);\n    for i in 0..T {\n        state[i] *= diag[i];\n        state[i] += sum;\n    }\n    state\n}\n\n#[field(bn254)]\npub fn x5_2(input: [Field; 2]) -> [Field; 2] {\n    permute_bn254(input, poseidon::mds_2, internal_2, consts::x5_2_config())\n}\n\n#[field(bn254)]\npub fn x5_3(input: [Field; 3]) -> [Field; 3] {\n    permute_bn254(input, external_3, internal_3, consts::x5_3_config())\n}\n\n#[field(bn254)]\npub fn x5_4(input: [Field; 4]) -> [Field; 4] {\n    permute_bn254(input, poseidon::mds_4, internal_4, consts::x5_4_config())\n}\n\n#[field(bn254)]\npub fn x5_8(input: [Field; 8]) -> [Field; 8] {\n    permute_bn254(input, external, internal_8, consts::x5_8_config())\n}\n\n#[field(bn254)]\npub fn x5_12(input: [Field; 12]) -> [Field; 12] {\n    permute_bn254(input, external, internal_12, consts::x5_12_config())\n}\n\n#[field(bn254)]\npub fn x5_16(input: [Field; 16]) -> [Field; 16] {\n    permute_bn254(input, external, internal_16, consts::x5_16_config())\n}\n\n#[test]\nfn test_x5_2() {\n    assert(\n        x5_2([0, 1])\n            == [\n                0x1d01e56f49579cec72319e145f06f6177f6c5253206e78c2689781452a31878b,\n                0x0d189ec589c41b8cffa88cfc523618a055abe8192c70f75aa72fc514560f6c61,\n            ],\n    );\n    assert(\n        x5_2([\n            0x0ae097f5ad29d8a8329dc964d961c9933a57667122baa88351719021510aadcc,\n            0x1db0afb64a7847b404e509b8076ea6f113e0dc33c8d8923850288b297b366a96,\n        ])\n            == [\n                0x234411a64c9117a670dcbb2e32887c05695108becb3746a4b63a5e0c64abf213,\n                0x0aeacd239c8086b9199880f4c20576cab326b06c4692d3dec9e13a35228a2a47,\n            ],\n    );\n    assert(\n        x5_2([\n            0x190e9f8d74c3ee7e6f9a5fc4f3e9aea43e4c636652d64732663ce4d4e9a82dfc,\n            0x116d4666591fd484d3f63b2143851ecf51790d344f076703aff0ea2ae73d84c0,\n        ])\n            == [\n                0x184f08154e7c0ae8d1dd611de726a33b46e83c881e7dcc83969ab5225bb1ffd2,\n                0x1c869eaf711604998e0015346275a1df87c872497cf501796b5c665bac5e6c51,\n            ],\n    );\n    assert(\n        x5_2([\n            0x0765449fba54a8f027fdfc4bba2251e13867d2999658961503e1c552eb8d30f0,\n            0x2458fc60fe06af665be546da89f792db27ba8122735483b028f7945b79a0121d,\n        ])\n            == [\n                0x00b99fef7542031ec0fc94e798c29b8d270ae80b0496316c722f149ddbd24c10,\n                0x05a9add2dfce4303c28124e1165154fcf44b7784d3adcc56f505d4e5917b8096,\n            ],\n    );\n    assert(\n        x5_2([\n            0x05df817f34e9cc11af435dd58951c0dc120a9637f1625dae110c900fd64fac01,\n            0x165798534b555615e2d3a7c0371d7c6b37814e4816dfcbcce9a7f5134166bf95,\n        ])\n            == [\n                0x2383496930a272a7d99e2db4dcfbe427ac7ece01dbb2c74e0393f44807131987,\n                0x238c2be5f5769977c50e089de45933dc1a00ef4f451497fa67b880fcbb5086da,\n            ],\n    );\n    assert(\n        x5_2([\n            0x278ab5ceb7ccf50051df09e958a60cdc29304d5a8bc5f512e8c05e4e8344b494,\n            0x0691450210975cfd5ad15ad9b7b8d2c0b0e15bc964511530830691b9bdb1deab,\n        ])\n            == [\n                0x267529bf7c33acceb53850eba2b713f4449a04d168f90b211c9cbfc2977955e8,\n                0x0dd91eb3904b8fd295abae96ce1e387d3ce1c06f1e68b8b14567c283a2719c10,\n            ],\n    );\n    assert(\n        x5_2([\n            0x0c19d1ab43ce3d913418687b4a60b758e2be814434c5310c7f0a6f5813befa40,\n            0x0cff2930faece292fb8ef0447faa51eca7538b91999d308c914ffe166deae4b2,\n        ])\n            == [\n                0x1ac275a60d969f95feead488e81955aa70680121066220a8e313309e76ce8c59,\n                0x05119d1c349bf5ad1b9af9ca6f17c40cd378cf971125709f1905b68d5172826c,\n            ],\n    );\n    assert(\n        x5_2([\n            0x23b96a10b3a6b5cb32a4a48ba9e2c7fd95a0381977051d377aba654ce3f46d3f,\n            0x12c4411263a01236387f3ad010243a44ac532a834589d6d7a38a0149748bf187,\n        ])\n            == [\n                0x26603ba36cd41bdbde16e06c6f1ec040743059b6ce45fe6f34e00bcb6e535b04,\n                0x0301f7923f6d373b7a36ce42a8f8be025d3f88e0abcd0b54e78ebfbf9116a9bf,\n            ],\n    );\n    assert(\n        x5_2([\n            0x2f1df4234732c49ac7567c29d2e066308f807e1bbf0951136b7fccba2602ea9e,\n            0x04a23083267080ae4ee1a3cb4173dbce507c86edcfdd02853b0399cdab611517,\n        ])\n            == [\n                0x0d6e20ac92800c7b08438805fe94a871c5f756ec07a919923c4e007cf01fa87e,\n                0x0d0e60f1acb65d948e7ff874e255c2c07a0f0ecc15e4d14209bc5d5715951ccb,\n            ],\n    );\n    assert(\n        x5_2([\n            0x106babe89343a47ce296eed78129b6f7af056b46ad808b2cabb66f371180dd17,\n            0x2f01d999b6e58284d87640c08c49e96d538ba3ffba0c544090fe858dbb5bc28e,\n        ])\n            == [\n                0x08d523548b9f396c877536b5f96fdfd1826ecdc0c806e24ae328586e8a405d8f,\n                0x1c1c5eeb613b596dd524fe59264ae5ef173cbd271e7f476a5f15d56175cb7478,\n            ],\n    );\n    assert(\n        x5_2([\n            0x299c0a40411ed9d7de7792fa299b262937b21fabfa386fa761e3f079c1d9045f,\n            0x2ace2e81e39d97a8e6d83c9e50a8643f4bf01a1465177518558305e7ab254c62,\n        ])\n            == [\n                0x2c62b5c08ee75aa967809de58131cb38e953fdbdccb9140ed92ea89adebcda85,\n                0x2c507b864995a399f7c1143f8c9dc67b7aca63419a2443a879715404a16ec6b8,\n            ],\n    );\n}\n\n#[test]\nfn test_x5_3() {\n    assert(\n        x5_3([0, 1, 2])\n            == [\n                0x0bb61d24daca55eebcb1929a82650f328134334da98ea4f847f760054f4a3033,\n                0x303b6f7c86d043bfcbcc80214f26a30277a15d3f74ca654992defe7ff8d03570,\n                0x1ed25194542b12eef8617361c3ba7c52e660b145994427cc86296242cf766ec8,\n            ],\n    );\n    assert(\n        x5_3([\n            0x2c6422c33190d036a17bd4281738ad60a6b4544c1020da1c0c84880a0ddc71c4,\n            0x245cd98e5af9a6ebb35945b092c7e877ab9549c8919940250956a0bfedb457ab,\n            0x0b43c424171231016dfe2072518b825a18c759383dba4e09a47bcd8b1a55da21,\n        ])\n            == [\n                0x0b6f503d74ca8c80934b48d8d9e41c239ea6bcee17f658d416a0b72fd7daf1b8,\n                0x2845997bb81ad9d29f0b7ba57550cb7160b6930c70c92287207c7b5f65b2814b,\n                0x0a97e625f336a7c5e51bb2881e3b4e224f6e2e01ae5d698fa19446dbc407ac3f,\n            ],\n    );\n    assert(\n        x5_3([\n            0x124ce2326b4a95fe09743697c1e5c9ac9f6940cab7221decfd0162a8873c63ea,\n            0x167148c1014f9f1ae03bb93892ec0164c6f65f779b526c3499d7ac374e84af86,\n            0x18c0badc1c5aa472c434c254786f8e1aa8b519a7ec017dfd20bc1e5dfb820caa,\n        ])\n            == [\n                0x2791fa7cca97f87cc3de6ce004bccf28e3cb631e4fd31d50b38fc79b7e43dbbf,\n                0x22e42774e15a97e78d378b0225379ecbcb76060beef46e10e4b630bbd256003b,\n                0x2e56288af3d63be34692074d7db4ce2f9eda91f7a55ba60d7661d8c2bfca9580,\n            ],\n    );\n    assert(\n        x5_3([\n            0x034f5155557b5e85db4fba5c254882f8658baa03376a38d37ff03fef1f850cfd,\n            0x23975b943c4070c2bc98ec66b4a9e1f0ca1c812b38317bdbfac98aa748b5b059,\n            0x03f9ef0d827a433a679060b654b556daa963c9658f628a3522dee7e839ab3615,\n        ])\n            == [\n                0x0014a5e7728d210b90ef439df76561371be410051332852cea084ef73271ccbd,\n                0x05c0808fa8657cb6091ee49fd5a0b32de2affeab6bed761043044982b3d7e3f5,\n                0x2f6cc98fa05d79737a559115be171d2863e65080353c281b2104bb17b01f9c49,\n            ],\n    );\n    assert(\n        x5_3([\n            0x184561698ba999c39dcd5effd2f073e95345fb74f023ba25e162995a206ba79e,\n            0x294e74e9b2f87eb7f5e00a350a22ff02e22397c278d48cecae04a4a83085a9ce,\n            0x2840b008f9dd0379037622060b97bbe9fb5ffcf3e765c0a7feb5be13405ad2d8,\n        ])\n            == [\n                0x13b47f0963b7751e01c8ff9775b02df2b185d8a968edfded67d518fe00a13104,\n                0x287fc57d4458c6853c98a361b93fbfa6176e346bd75bbb11773b00356d496b6c,\n                0x200f5d2604826c715b6b0b731a5365d9bc24cba1fbeec033e3e0a434a6505251,\n            ],\n    );\n    assert(\n        x5_3([\n            0x1c3c047ca883688ca6b6ddec715eef99a40282a4dc1d1b33910f59f30074e8f4,\n            0x0a3aed04e3acb73a0f74d42f0d304f1afeefc00859a77d956120638d9007fbc5,\n            0x07d9e5a9a2ac225871d7616f13a7a0185731fa679d931762ce1ef7767a3e63df,\n        ])\n            == [\n                0x0df5bd217aa8e906435455b0151adae8dccb5f1fef23c0bd36a15f78f7b90ea7,\n                0x2f6ae610ef9f92d6bce4540aaecfd2f0e93bad0671f544f0c16bd8546de44928,\n                0x1b74956ba343323130615d776a667187f72ade7bc295c7750551170721f5253f,\n            ],\n    );\n    assert(\n        x5_3([\n            0x1e7cb866b31dc33c91585591e7c82530ef2a25c3feef3273b1c4fc382790ab2b,\n            0x2781a330739b20aff560c61207ac9a3dd0f74b78dd9d4ec97a3db650c4d05ae6,\n            0x275dc90993858ee8bcee5a94d1010f30c9731a49eb799e3aa0dfe94c73d1d28a,\n        ])\n            == [\n                0x1c8317bbb73ba936b89bb337d1a91a48639602b721e0400e0b9d5799f64c3dd7,\n                0x1a4887a3b86e801f5602aabf3d247a4fd508ecf6eb5d1e54d53eaeef7235b123,\n                0x1a1298a0b4d732d42c85649ac7167073350be052dedbc334d05cdbb2e636b72c,\n            ],\n    );\n    assert(\n        x5_3([\n            0x276d519f50629d7ab7b0362da8e532da858c989c37765d77e56d570ef67037d1,\n            0x2b7cd64f3fdb10e2006a924c051cd3ea53dfa82e75993bad8d0eb4ca8f3756b4,\n            0x07dc1f509cb68ec98ce1c9d18a89fa75a28a300ea58769a5fdc5ae19b4459c24,\n        ])\n            == [\n                0x2ad18eae7534d3d0efe05e897a4daebc441027e39256c1b647350f4a1969ed22,\n                0x089f6c4f52414101923991f94065e403aa9ddb7af3381c74b595650460d883ef,\n                0x1cfdc65275dc88f45a862bb5618c586c52a548a7ad33fa6240cb06cc79988278,\n            ],\n    );\n    assert(\n        x5_3([\n            0x0c6c15f4368f09bdaa7e7f4bc63d65d597eafe75764d82cb4d774e1982fce517,\n            0x2e250d17689425c849b6d94bf822783c14086e5b5a145f6bd67d61d227e5dfa5,\n            0x18693f449496390c0d6daa3f03170629b987b27c832c9e2aa586e3e36c6eac8e,\n        ])\n            == [\n                0x0d35a94d34a9fe5527a72ddb2a6654bfde040cb5ed436944146971939790429b,\n                0x0bf853441574d5367ebfb250538322e16bda7cd1ed8097a7924f937c3bdb6807,\n                0x1e9ece2f587bdcc047d4f18419934d2d53f5e1aeef8ae5ac7a66bea8eea657b2,\n            ],\n    );\n    assert(\n        x5_3([\n            0x2fb3cd143630e3dd1a1eda75a9e8e698ee7a3a877ec6ecd7a77de97a1e0b6657,\n            0x0c525ee6e5674c991dd70bd04a00bc62119d0ae97a1f1ec89cbdd34ac139edb4,\n            0x2b6d256970b78cda94586db4eb7db119b10ee087b9ba107afe8c64e7b34625b1,\n        ])\n            == [\n                0x131f70df273c7fe22667903a3aaeecfd8a873067c836159ffeb6b7e9f9ff347c,\n                0x2c3734764e1decc2f5edef11beeaa1e7319594a4fdd850ac34370fe616f07fc8,\n                0x06aaada4c2611fd916e1e0e7c31625e60d3e0b3ff972de980a3327350896ba2a,\n            ],\n    );\n}\n#[test]\nfn test_x5_4() {\n    assert(\n        x5_4([\n            0x0000000000000000000000000000000000000000000000000000000000000000,\n            0x0000000000000000000000000000000000000000000000000000000000000001,\n            0x0000000000000000000000000000000000000000000000000000000000000002,\n            0x0000000000000000000000000000000000000000000000000000000000000003,\n        ])\n            == [\n                0x01bd538c2ee014ed5141b29e9ae240bf8db3fe5b9a38629a9647cf8d76c01737,\n                0x239b62e7db98aa3a2a8f6a0d2fa1709e7a35959aa6c7034814d9daa90cbac662,\n                0x04cbb44c61d928ed06808456bf758cbf0c18d1e15a7b6dbc8245fa7515d5e3cb,\n                0x2e11c5cff2a22c64d01304b778d78f6998eff1ab73163a35603f54794c30847a,\n            ],\n    );\n    assert(\n        x5_4([\n            0x0c8c9889597488008e2e96985b843092fa78004ac3406c9df51ed2b6cf1165cd,\n            0x20519dc2e54103607f781cb4c3e0728db3c0183b0d8e32b7a18b3ee7226d1866,\n            0x17f6e0269a9439e0cbafb92fb6a33448460becc662da31786bf22935ca8734ed,\n            0x18bd21d391158c54dd641afa11a9020a2bc49948f16864fbaf161d746d49b3a8,\n        ])\n            == [\n                0x17853a421466990a70c8df0ca883fc9580968a8ff381c573ccdb2a17b4717f1a,\n                0x16c5b3481f48b51a628fc4595f30198f9c7eef5315e126d668a555076d6b77b3,\n                0x06c6ff5c992138c00e99c9daa6a4eeb86cce3b1b8cc9fa8b30c3a9350dedd1cb,\n                0x0fb18430a0e66a85bdf65c38f2d23be9005c48fae709f297268d13bff5076b1c,\n            ],\n    );\n    assert(\n        x5_4([\n            0x1854b7992ec5a1349e9ed40970bbae67373bf98cac98055c7baf28d664384085,\n            0x12d3bf93b4c656e57eb1f4e1fe74f4dc5dacd2b95f27a12f0cc51c8aad9b4ceb,\n            0x26c5ff636e75996c5d4953e2f44fc31403710c59e017cc0c68d7f7b547e5e12d,\n            0x1c29859e1768d3def45f2a97f7f96fd13149e50bd809fe6f49ee960e9d625f3e,\n        ])\n            == [\n                0x17d01a086c63a77d6315cd7a1cdbac3ca89534c1a1da4e778f5ce60bdc77b28f,\n                0x0c64c46dbae63fb3e07037ae5d732c5cdf0da73971b940dbd32b2aa5c0bd7a5f,\n                0x2bcdcd400e2f052facc52233728cea88f9088313746a0f44fc286c5b6fef5f8c,\n                0x0fb03a8ea938397d9aaacde31fd4510d89ad5a11d353603448d19bcd4bdcda8c,\n            ],\n    );\n    assert(\n        x5_4([\n            0x24ad6b688e5398429ffb1e3ba8ab3cd798f9909155b45812325cba5a16d2d220,\n            0x300687b9652aa54e7cae4137d9408e3ddf88a869428998d30b86f788ce92e1d1,\n            0x2aaff3037bd20cd938462fbf41dac988afe9104d7794016c017a29aa411912d0,\n            0x195cf02bd9aeebd4482b3f72dc509221de8c2ebf37361f8766f600bc748de617,\n        ])\n            == [\n                0x143d9fb2ffcec25c75977edf8ffa3d3007cdd38e1bd4d64b0a6603b7e38380a7,\n                0x1d2b015c19154421416a0204b88da26fbb74fa545116bea2c1c252d8cc43f284,\n                0x25bcf030113a4e13e812ebefc4b2af53687c21729bc197462b1f52b9d38820be,\n                0x0758b5e5e91eadf63054e205c4239ad12b950fe183800db6e2673408a4ef2600,\n            ],\n    );\n    assert(\n        x5_4([\n            0x16e6e596105e785a3e0bc02bb15398a4b08c55b9cba3536877ff40b7de1f2a38,\n            0x2530d6ae25e495a3ccf8d51121e0d7134825264c630c9aacb0f78c380498e5eb,\n            0x1586aaed4606463b8d7ebd287062d9128df99c8cebb06d8ddaac95e258e5a804,\n            0x02082849eead984e1db4f4bf307e310a1fa562b14e446cc62f8a7232673b868a,\n        ])\n            == [\n                0x1b9c747e2cec9adeb3d6e37f0f2eb39d3e5055afee568d4feee3396618c86670,\n                0x2752b18bc2f394a02c93e39322a62d37107810fea619c69e5f855390f29af3d5,\n                0x1e6ca93880b078c245c1388d6756d2e222ac749360c0e8890f59cc3469498f89,\n                0x2554845bc6555c2614692cfb69936fc1fdd64df889198dcddaad8fe34fdfd02e,\n            ],\n    );\n    assert(\n        x5_4([\n            0x1e0efaac6c6acea57222f9161313ec9579cda0c85e22f180345af12abc70b5a1,\n            0x0d0f3071f2e4fc48d9dd9f37367de2ec12260ab9a8729269fa1510e9d093a5b3,\n            0x26b2e5123ade4de33a0185d7ee08bb10ab217d8cf44227673904ed9ba7d6d0bf,\n            0x192aa37419458e66c367d86966f9c3f12e1a4ea89883bf21f98989ac5404c163,\n        ])\n            == [\n                0x1882d48c13b9d810e8a260a6097864328e80253b650c95178bc23cf9784a6221,\n                0x14716a2a8cefec1867e13d2972da49ff8eaa54a8a6d570ad3f941e3503c04051,\n                0x1d7d8881a73cc7b1a72651a8ed89ac423a80c81a25b81b9f29da1a46242a2315,\n                0x01727d8c17208e420a5aef8388c19dc1bcf1aa95de99b14fcc954fb830db09e9,\n            ],\n    );\n    assert(\n        x5_4([\n            0x1420cb6e80553413972d39a0e2aa1b0fce8e1759e8955b9d0b4183bfe7cd2577,\n            0x0e0bed978ef7b27a34d0fc3f4db4dd6a62eb2a89deacde38ab43d23b5001d9ec,\n            0x1f52d011ec77d06560315f14de37b7e6af34fa77c8689f82b5cec53a6f731a8f,\n            0x2b6f87516d48fd88765f571998ff308eedbfecb4de3eab9f541845fd5a079a10,\n        ])\n            == [\n                0x1cc0885e44b1e34b49d5a222b7c61d4423b1cb2ef5c7ddfdf79ccfc09d7969fa,\n                0x269f78e3b703e373d6bba5bf975850256e59fe346fee340934a6f8d11aa06d1e,\n                0x20ca89ea0ebbc138a7486139a8661cfd9c60e0f6a4448cee512359f53115d637,\n                0x1608f2be9dd70626d5faf42532b6f3d91bbfe9cf0dc48df9fc70786c22f36e5a,\n            ],\n    );\n    assert(\n        x5_4([\n            0x02ed7335766c6990f8c4c07e406dbe441efe9fe3f8a3b3c36efcf8d5b2466a78,\n            0x2e1b45eb605cde0d22d13f244108dc47d45c395a1854afee35822424b6cc022d,\n            0x2f26a4bd4c1472f8fb3d475c64647acb9371432589214dba81a90cef7e84c3f3,\n            0x018dad8abf0ebbc641d59f342ef89b61a0645dbfb601e4220595050d4927efe6,\n        ])\n            == [\n                0x07ea9ac7ee426db731f066f680e808598fa2a2e2a2a0184343332cac349192cc,\n                0x138eb891fa8db7ced98b0068a5a0d601f0e35c846e92bd89dc99b26fb4c1ca2f,\n                0x08ff879f042fbb823506632bfa99626ec1f8e02849fe0710a915c1f2b1c17e2c,\n                0x234785ac2b70c4e7c0de52b4b9f5b03d04325950cc88e26a2c59f2ee45f1ebdc,\n            ],\n    );\n    assert(\n        x5_4([\n            0x2668dc5c24a61ba1ea716788ca323027411c67114fcf8d3037ec85cf04f9ab49,\n            0x2ff5ef931ab5091bbc32352e20b9971475f2096cdec6a2540897bf383b3f491e,\n            0x269edac091156e2f0b78bf1bda18b4bc0fa57c5da2d9223c0af89e7e32360079,\n            0x0a26433da1fc61b268edb2be549944559ae70c4b90cffb6d3b37f16f1ac7626b,\n        ])\n            == [\n                0x0d1ebc93de138f542afad67b1b7ed5a0a91b6386417a61ef775c4498f324c339,\n                0x02363f63f074a61ea1857ac0e821c228794a18b481adc3bcb52c4a2f1d2b271d,\n                0x2b39691b7342e1b0b5d50511ffb83b7ff01d604b2ad3e9b216d78dd9538bdb3b,\n                0x1b99a6480116544d64604ab259da12cc1a7948106b6107949457356ccdbfa4d4,\n            ],\n    );\n    assert(\n        x5_4([\n            0x0b714049d73a453d12fd8d29b6d3827fca2e9bdb2b81700f91a99af577c7fe7b,\n            0x2f0f7fed2d8dfcd4abb28e3622eae01279c61d4256a6be4cb3b1fd51b8d723bb,\n            0x305e7764e1a84dee8dc9a1f80d850ad02302840f301590f274789f97c8c1f2d1,\n            0x207557596ad35e035c50acafdc27a0073889426cfbe4ba1832d6ef7cef5302ec,\n        ])\n            == [\n                0x021fa88b38fd0749af48dc29fa661c3c4741ea05f359384caa04000481e1d1ef,\n                0x2e62acd7dd3e2bc28218108633a8c30c9cd16957b3122b80e58a04738b9a6974,\n                0x13f8bd5eb5b4d726e77555718c121d9765be75c7eb75f0ece17788d69861141f,\n                0x1843371c51a20880032443ed629204bfc54ae1db656feee8c11c6d4ef2a7cf73,\n            ],\n    );\n    assert(\n        x5_4([\n            0x044d9089d0d731e323eb08218c16222676b1b170bd13d06ce96759a21ebe3279,\n            0x120b8825613c5d3d12545a5806743e5234cc1586f1d1bae59bbde22eb973178d,\n            0x2b5a57fce5f044b2e8b26f6f669b88eb1880183e7bfa2903a16ef0236f2f3faa,\n            0x07f4a9b793b47b8781ede417ad119323d1ae6743d5c3dc990183eec04ae03e0d,\n        ])\n            == [\n                0x2519d1f27af8da43d481547ab075f18bf96be7f94c81439e9a666e9724cc01b2,\n                0x0043d337bfd1462f71190d710e163df4959d74c85977efe90a356a65e4bdff9d,\n                0x2bf3a9750b18f92d984cdfe1f61f23c427e1bd0764095fa2d96c0339cdd4771f,\n                0x00478202dc2b091483edea6c313c77aff25a45419cdab2d88e662fdc007f4c67,\n            ],\n    );\n}\n\n#[test]\nfn test_x5_8() {\n    assert(\n        x5_8([0, 1, 2, 3, 4, 5, 6, 7])\n            == [\n                0x1d1a50bcde871247856df135d56a4ca61af575f1140ed9b1503c77528cf345df,\n                0x2d3943cf476ed49fd8a636660d8a76c83b55f07d06bc082005ad7eb1a21791c5,\n                0x2fcda2dd846fadfde8104b1d05175dcf3cf8bd698ed8ea3ad2fbcf9c06e00310,\n                0x28811ac7e0829171f9d3d81f1c0ff8f34b360d407a16b331a1cb6b5d992de094,\n                0x2c07c1817cfccb67c1297935514885c07abad5a0e15477f6c076c0b0fb1ad6f3,\n                0x1b6114397199bc44e37437dd3ba1754dff007d3315bfcdcdc14ec27d02452f52,\n                0x1431250baf36fb61a07618caee4dd2f500da339a05c553e8f529a3349e617aa2,\n                0x0b19bfa00c8f1d505074130e7f8b49a8624b1905e280ceca5ba11099b081b265,\n            ],\n    );\n    assert(\n        x5_8([\n            0x11e027e38a43d36a72be06d524c0856d027363f604c347937fd91acdd47e04f7,\n            0x28b51285afdea43557ffd2b5ad3ec85c08e1f718e263bf9e8709889d6bb9a745,\n            0x290a6954438d96f11db1a59092c454379c233b5a07bd0b70f29ea12c03a3b729,\n            0x06869a7aa196418515672ba3e3de0124866d8448d387e33d69de16cd0a0cd9d8,\n            0x2aa9acb0cfdabf42c8254db2fe4980c757daaffa7429e87bbbd5756334a01b86,\n            0x10356d863c177d1a97fd1a908b89a6ff0bccda3eae346c96ae8a72f3b44d59ee,\n            0x09b24b777e6352b7908cc4961942624f2725412f84c75ed93238ccd42b2efd49,\n            0x241fd4790bab98a9185d5b11d083ffe5360b3e2094bf1123142bcea4eadf6012,\n        ])\n            == [\n                0x301e58def5ed2e1a5dcaa44a9cd47919246011f39575de8212cd631da771686a,\n                0x23d5d952e536aea304ebc4c83d206a8f1dff4c1480334ac954bb24e273ba2120,\n                0x12386a450b5c89202ee12619ff486c1c2ba39ae969b24f7b850afe0a7f0db2ea,\n                0x1100f7e0935587cc6e3d2a59b69045e12c1e1ca3c442365c5769ea2df8c370a7,\n                0x20bc910a6ec6aacc4007e5dfc7bd7b51adfa1dae2516aa3060e15e5a42106b5e,\n                0x0550bb9366d5da5470ac98c4e97fb12cb04e70fb1e47d17d365e9444a9860761,\n                0x1049903ff3d9d6a8286508e3e7b8e3f3d254228aa00c322ef9d305d3248b8754,\n                0x076dc291e1cdc9f48efeaf713a161de6d43e407133f38b82d56df9279d723de9,\n            ],\n    );\n    assert(\n        x5_8([\n            0x25776de965f9e74ee70f66a4aa501b2e5bdd7f1dc2910bf1a060cc5fd746ed1e,\n            0x2b5b27c3c2f2f6991ce700ba074c7cb8bad876e2a8f09e712310c50f77af22b0,\n            0x2f43305136fcb3ef1d0fa9347702dbcdddd8475ebb01d617a598add5b0d62aca,\n            0x16812fd128edf911aa4f7e27568814a208023bc9ffa8183117efa78ff356734b,\n            0x0811490d27c169cc8a8a774c686cd25dfcebdbfdf9865152728f10b02f416a8a,\n            0x04955c2c8ad3bab330220fb515cd610fd14f3a20d4c8939846580f46cf23b6af,\n            0x048ba851a27072d279d88094f1f3871974d645e1dbd9226fa35f81731ecea4e0,\n            0x065be967a2d16752761af356145ed461a2056ad0a7e9166940623e4d140b76a0,\n        ])\n            == [\n                0x01fdac4b572d213e5b5438a33af928caa48a2325ac8cc30239ceea2f45819e0e,\n                0x1dd13703749821c20ece4e35213b89da18b635672d791e520196a00c6885f575,\n                0x0df6f1389b8d70c99487871540ca5e0cf4607cf5e4556bd2d039a14916bbdc17,\n                0x10d97ee74863b8809387176212ea8d7458d2fb89e5216e6e7fa80fba63c0af7a,\n                0x1384c276930a90e80c8669d30a72706ff550e66e4b5becefa4a4a9f434419d9a,\n                0x27848d26ca176da553cb66917754c38f234c00b0b0d28c2a48e1d5d15a8d8bd6,\n                0x108255dd7381e3b8af4bd33974092e732e5a1bc6be7e6974a9e7d3c4a77f4005,\n                0x2b95ca49b2b7e7316bd7832d29e3235bc3769ffd04b98671af8d116a2ac565ee,\n            ],\n    );\n    assert(\n        x5_8([\n            0x03cab88b5d93ab657ab738c39575c2812e61f87d188d787ec9c920da592c2243,\n            0x1657057a76dc5a0846c28c33fbfcdfed94a3baea5daf495df4aa61ed4bad34d5,\n            0x050fc77fea82eb8ae11537eeeeee6cb66ad4f77810df293cb0ceb614fa86328a,\n            0x0f5574ad89685ce5ae2beab6db16631d32b16789fc9a1d4178bc1b73ad83be17,\n            0x282d72510f9ca1e6fbc868d709137e17e516cc26654ec034fee1cf5bce179bc5,\n            0x1d84329514de9a7030a7ad080cc7683ba63de7b2b14c71611f0cb3565340e223,\n            0x2605438a072c04502ef613759e28d86b51dac43671182ce62250e7a806e4bf9c,\n            0x2aea2975994ffd70c4ff8b6c75840cca6736fde04f03aa784c1cc5b7a27b006f,\n        ])\n            == [\n                0x295df3c1a93aaf9c6e852d06fc490c2811646eb73143f55eb86e679b1ca7354d,\n                0x1ad9d7447e57f1c6ae9a8b2300349e2c9332e5edb6813e12e428922bb66630c6,\n                0x2697581dcc42d3162ea222c0b5a47b3ea975824909a707d0af1431a2a2932c87,\n                0x22829b572f388ea29335c16f079d9e1ea8081a1709e45b9be089932fa70b5e58,\n                0x0398a6b47097a23a0afba8d9b76e126befdf2fcd7742c3136600b751ed18c106,\n                0x203aaf9774c8d558d14c52085d9a4c2406394d0000e640f3372d0084ecc84aa1,\n                0x14be6fa6b09e9b03b603e75baa6a80764e170941fe782879d02988d0428a115d,\n                0x01579c9185a70c3885e75ad94de88c2b6237d7be5fb8f84ebd7c3f2733a04f3f,\n            ],\n    );\n    assert(\n        x5_8([\n            0x01b7c953d757d279f1e4b8b29b70cdb5b181807c1952fe7ad9cc88e441ef4f65,\n            0x09891fea0252d6f9b61c944b994f28f6dccd6f8a3965f8b7b796aec3d81182b2,\n            0x014790065d8a6de104535d6aa5977dca5ef04320eadd4186b590fa810decb825,\n            0x05cf8199af1df3045f8aac45d9c5eb0b301ef9e9d305db6fc6883ca98db1ce02,\n            0x0071c2a63515055a6e739f7f615c549055d12a62336a5458e0dd69857e1ed5f3,\n            0x0b81cf03fa8159f33a588137731941ba56001003494172f97ebc0db4af7f0c97,\n            0x17f989a8604550ff01a9950cfb4499fee9902f763c5c5eac009122da69e8afd8,\n            0x01f0f10c2672f33e6e7510229b2ad4c6507cd678f856b7a7b3497b94da784463,\n        ])\n            == [\n                0x2a989aca81a76dc71608ecce97a1c8a9cbeb17fbc3384155de797d4ebdba2b6c,\n                0x09e6484583737642bc573e4ae77885d5b28f7b4954fa59980d0057e781e1b69f,\n                0x1d738584ceb67d8b49b3ee78b4b3ef1b808f7cac646e5b84517f66342d26e0bd,\n                0x2b0202533b12d6a69de9d2c54360755853b2fe7dbe111af464a3d25ee7a2bb06,\n                0x1b72cbdc33d5b147be615f4cf8c270cf0d49d81911fa03a8108c961f4a83da7d,\n                0x1d15628748330de1caf59dd3246228da6b54cc42b5f2657c274552acefa0ffc7,\n                0x2fb4d731d2643b8247e322052c3fcdaef68775df06174f649d93fa0ff1930bcc,\n                0x0313b7cfffa0ff58a8a1f54fdf6b95f7f772a5d9d24acee109c08c055cde351e,\n            ],\n    );\n    assert(\n        x5_8([\n            0x1a9c3fa290fa302f24a32fc7196e3fbad886e55f0416fc05a0c4ea5f92cac771,\n            0x071a29de76b7de4cf5d077d2ffa826b3bf8fab45f1becafa8eef4173b8c1693b,\n            0x0cd670e01cf5d1f3f45324fcd78776e60a113a7d804cb370cfcb9ab480e47fa6,\n            0x0f4d079133acdc2c86fa92aece9c1a14cb80c64abba63608b233ebd6451d0b08,\n            0x2ea0a7982d4b2cdd448ffdef1635aa69ba5a97520d6825921ea52afbee172a25,\n            0x083171a1ce6c5b90113821f2bf850211372151fef1a5df8efa29845c2c6704b2,\n            0x12e9ede1912ded64927bde975941151f9c2ab111823df2f0ea72fcfe9a6ecb5f,\n            0x2bee3febf6d48fcea7846c6480949bd7c6ed3237b39ba61d48a00f3e6db4afa8,\n        ])\n            == [\n                0x028d3fae682b98b85071b577781c740da8199fce5a379a9dc68fd9f00c6e5520,\n                0x19ba3cd5167c9fbb57abecbbbb9832323f711d36fd37dea79b7571a53d1b5a00,\n                0x118186bc3696352f5e7215011e870b7f2cf9e09989da49e4de935696723365bc,\n                0x04307689687696afb89acae109697ea3c428f9791c03a42dbdd32670d45fb455,\n                0x03a71c8c430e0d2b7ed54ea400147ca5d7441dd63cc9a0ca945ceb11258e3107,\n                0x20ed2ac661874da03bcbe13a250eb08487152d44bef8eb44d1ca1a76dc5cee83,\n                0x034fc10be3c3194c5de940ad9e58cae869ea950c2911d998569658e8ccc25c5c,\n                0x115758ad61eeaff2405b0422c178a9203cd208a7499700768d06c8bbeaaa6399,\n            ],\n    );\n    assert(\n        x5_8([\n            0x05af85a2a83bbf0c8e1745d32f821fd445e7f0e16e3efca09f7b670a7d1b3303,\n            0x2db863f54326e5338ac73f56d5c93d591241489cc2a21faf87385c13dcb73de6,\n            0x04f20a97ec43ba9ab2595f72f6806be8cf6defbf2c5a62338992310c82f3f4b5,\n            0x13f04b49992fe7feceb79da483d1291c04ba82d7ef41321aab047dae78726ee3,\n            0x2e378dff8c0aaa5c7e68f4d288fc3f937eb034c8abccac668bdbb40397bb1189,\n            0x1d3ce99b763439ce5d7e7b461b34d52cf7d2ce66a60017f124d5a89a57ff92d6,\n            0x0467533be3b8b58c27a480b3271328d74e58b1b7fd0135c5871c1cfff3288eb2,\n            0x17efb1242817bc50e52ac1508414af0463ed75b2cd39ceb6b510ec6ce872b631,\n        ])\n            == [\n                0x248c269a62e166b3b921c7aba80b75f73a8db719b3e5bbeeeb519ba146b5ef48,\n                0x00d743b68fa94736b4ee629fa69f1d05ada368b86e272c6187a09bb9ad45e084,\n                0x17ff35e315ac5d8a79f120d82ffa2daf92aa01316b4c56704243af1d342314cf,\n                0x18ebb33f68d51fc94b4815bdb4213aaaf8127d0fcdde245a1a143bf117b95a6c,\n                0x1dba46042e735f0e5171b9ac3740e4448034a69a5c1fb62de8c7e3a89d022161,\n                0x1372c3c58af5ae0ce04419601e8a03e2f613f1f4baafb9561d483b691bc625e4,\n                0x274fe183a550bf98870960b13668ddffd5ae00b457e145695e6752d372152ac9,\n                0x262db490dd2a0370e2a96bc9c5d9296dff723e984b36415273f66eaa55314cfa,\n            ],\n    );\n    assert(\n        x5_8([\n            0x2c8ef342682e4a13c4471f202bd59b9e1a3a89a4f58f456d279c73e92653364f,\n            0x1180875747bff92f8ec8e698a513965c142bb3c2d9d60276a9f3c37f4181fb4a,\n            0x27c395d2f21b9f73aca6fac113a2623cc015c5ebdf87ac3581022a5d55065931,\n            0x01689ef1805380ceac4d0a7e2e80445d0853a5a3813a4922dd9d3dc1c1a1380f,\n            0x2f9bacde66bdd6b539df5ca9a80933db287013d55dab4acdbb5d84b3da018f46,\n            0x26b5f43cf484dca908d3a557b990eeca6a8e6acf9303ac8ffe39366e66bdb863,\n            0x1552a91453438609e676b073b0f5aa68b0713b602adebb39049654ec1c6680b5,\n            0x2d75ac7fcd54f53156a38651170b52281504be4098deebcbf475a2bf4f74e66d,\n        ])\n            == [\n                0x09b846d7cbedab163a34651b199c13fd5d63fae2ef0db60e0e5febde9067ac26,\n                0x1e0ecfd870f8d60d801b899b0070162d919eaa3c130e86e92a5f95e82748477a,\n                0x05e646017cfce6a345cf4a57f3b1d7807371d99ba68bd97ea7ee438e207602b2,\n                0x233c61724808502fc7756361bbc10a45956ae30ee7121f2896b3dc4e764714ba,\n                0x13467a221ce5d3bf338d36280d0a718bacb895e7630edada9fb700dabb95ca51,\n                0x2d996fb08004f0fac8896517d88634daab4484e2d6506f12aa38bbfbba2492f4,\n                0x202b9e2900240d9b062ca7b1e795b5f8265311de20d2c67ed4dfaedcb03c63a0,\n                0x2ebe566b153b14dfe3602a610a23f53c3db2af715dfa9d51be7df965b83ee0f6,\n            ],\n    );\n    assert(\n        x5_8([\n            0x032227d5200a7a32ea6e15021e3e0eec3381e3ed9eba437657422ecd23e7fe53,\n            0x23043016d0bd81048340c78dc7a30339fbf5d6e1a2ff320869af5ad4ecda70cd,\n            0x05f4fb3ae740d37ca96cebd4e5f8b4f115f74793885cbc318f6b15c8666d7cf3,\n            0x1ce79da00c696eb21049015a1c1b00bef6e6d9e097a01d92101518020e7764eb,\n            0x02f2b1d10ceda238ca16f4a1a99449f4858b822ee79e032ca3b73cc17d9e5d61,\n            0x0573ef89a24f29c0e17f1f4429e03a67cadddf208a692610570e9671a9666b51,\n            0x1d8b2b93983ca3167f92af6e873e3eb3fc00912f9d0ff552f2a0eecc4bf5ef34,\n            0x168fbe71a83806e9181500ebbd4655ae1883055b04bb6b7e478fd755b7de5b9d,\n        ])\n            == [\n                0x21e9bac62e77ff814dbe0e6a24c75135936f4988f23197bffce2466810a2b07d,\n                0x25196718e461793cd23d5f04687ceca0cfc9dd398afe89acfa73449630016f50,\n                0x07079236786886d210f62709c3b5921a7ce5bfbfc4a00bc71918bccfb8b15377,\n                0x133fdd783f3a83c6f4d7555919cb08f669433520affb73d01782039749ed70c9,\n                0x290a5a0bbf07a09a3aba494da79f3c8137d772b0359b664b6eb56b7e84db453e,\n                0x184102d72083529789e0b89be0dfa370fc46b62b934f520654752ac8c1de5c93,\n                0x283faa9f66498adc14cef4a5ddb3affc5bf5b67857e52090b515a7a3c4b156fa,\n                0x166a12fabdd43d13c5627a47641eb870946b46361b4c037eac90da1995c4e64b,\n            ],\n    );\n    assert(\n        x5_8([\n            0x2b38c44e6d922f1916c6fe209b60f11d79690da00dfdfc688b083a84e2226575,\n            0x28ffe5213d9d33b4152a2f9df1cbe5be036519f9931371568d3675ddcaf0513e,\n            0x12f3dc47fa9ecd2c8471c8921797ffd99a647b0e0a7f053fac7d20cfd4e7c45e,\n            0x019b85fbfbf4063ff1c2abf19456b9b1a102f35d6fdb93b47b16baad1ba4109a,\n            0x1af5fc2f51aa73bbb6983d3f3208e2443c5b91f5ff862121c05d3f46dab238db,\n            0x2824df6732b46722fddfebbee5ad5dc247cab77531be5e0d46b85ed5d62acae9,\n            0x2160a8293c32813fea9fe6b91cdb3e8bd464b8f0213425874b0b335487675138,\n            0x11766143563259de702db02548131cb0f4898db4823769304c806123d1bdbd43,\n        ])\n            == [\n                0x302d72785ca7f277a71d3f4ecaa03425402f2469f0b412915d7693454449ab55,\n                0x06dc87f90a66d0fc9beb26840a5ce5e8f6ee9372eb2cc6c1e68d26a48dd2380f,\n                0x0d612fc26aa0f5198ea2b6cb6d7ff1b87e7d0fb85e6251107405c0acf24a8c49,\n                0x02da5053884af86f628c215d924f8c5d506f8a6e704f25884c932b5679cff1b3,\n                0x0ee0fcfb45654a9459ef304b5c7ef5413573743f16c661fe0b488270648514f8,\n                0x03d82d7c49a21bdeaed9d646dc878803076564da8a6716d2ff27d98672a9015e,\n                0x06e695edbf722cf7f00c732537f849c950d805819c2fb697319441ee6c369a2d,\n                0x01be2f8cebfbba528e81e581c55280cc32e33931f6299f68f68a2afc4858e334,\n            ],\n    );\n    assert(\n        x5_8([\n            0x16e42b1b9957861119562d0f04fec5050762947b381e0578367260b083327887,\n            0x1ab2141e8e0a746272d9af6699d4e82d5674c69d25d11dd6b5be1725a3beb451,\n            0x1acb3bcff3b760b884bdc302d3003dc62559cb9461f037ae65ed8f625d115f22,\n            0x18297976ae4add63f033d6d282271ca89083d63a8890640b98e3e1324ee7569b,\n            0x077d73a6f7a05d84e5fa59da6c1d3f406852cc9e514cc3547b5d6d467f727a36,\n            0x177aaaf8c8e7ccb27e2ea54943d5b303936e88059ecf15b0a0dd93d07803a928,\n            0x108a170d6203db76a36ac6db771c3519f9754ec6451fae681b774762c2d06c2d,\n            0x143070956a890ae047b64d289805262f80116094005dcf064bf76513c13674d7,\n        ])\n            == [\n                0x17764106391c20d0e4c05715425aa46b968df076f693b32c6e9691807a7df01b,\n                0x006c8e661c70f83b92538e86bfa9d9824eddab837e2cc73db916126902c8538a,\n                0x2a90c3b5b82ce25c30483012671c78a59b0973cf1b547e6e708608879a0a6332,\n                0x17c46fa699248524eae3cabe54df82bd3058209481ffe64d2979c33ae0495ce4,\n                0x1d3ac6bbea4783bd4768316f1673a1e878e0541f5c6aa313530bb732373aa245,\n                0x1c489d5d8b6a312d7e0b038709cc6a8a38e312f34b30398e5efe01da4f4c571b,\n                0x045239eeb3d5e28490bbb2ecadde5f93c8770a0fcce6d6a15f37902ddd93fa02,\n                0x2868346064d8bcc538161402cbd9c297872f9e42205130ecc9838a8f41599d59,\n            ],\n    );\n}\n\n#[test]\nfn test_x5_12() {\n    assert(\n        x5_12([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n            == [\n                0x3014e0ec17029f7e4f5cfe8c7c54fc3df6a5f7539f6aa304b2f3c747a9105618,\n                0x2f90753e7aaf46c158cd12346da7dd37c3136353ec51525cabbaaf2b2350f9b2,\n                0x2e28bdc8b2c68b09da0cb653ee7e54eca909cf2ae010784554aa3e165b1a105f,\n                0x1d6a97ef87dbd3476a848af45beebe6b5d79cb047b37212e3e5839f1e80b397a,\n                0x24e23df24b19b75f44218a08d107709d35561bc1b982cfc317d54568cd496519,\n                0x185a08e623b85e797844191a1f184f7b8fc486253919eb20f1186a8331757018,\n                0x069ed78df853a105c8949dae5b4e81cbe370e8f6e25735a688aa8ff3df9659eb,\n                0x284395d79b64123211a4a59b81a90f9cfa8d8314dccde4cef22ec1e31431efd3,\n                0x0f24be5a8c95e3504ead0da9e792b77d7056f94461d69b04b33ea5d239f8e444,\n                0x022469ccfef0ce5a237518c38dec31fc2804e633b3b365c23a9f703ca31ef393,\n                0x1fcdcee218d5a0101bd233d572f184964854d445ca08d2bd6df6ceba5651e322,\n                0x0905469a776b7d5a3f18841edb90fa0d8c6de479c2789c042dafefb367ad1a2b,\n            ],\n    );\n    assert(\n        x5_12([\n            0x2954cb9ff6347d5c499f1fc52db830ea8fa29f01e77c979c5611ae2aaae0e3de,\n            0x2e12b253c9034b6cc304cb4420dd4bf63c9216a8db85b157b55f45570fafbaa5,\n            0x2de62fca9606e83d76d60bd222c14d4413e9fff2d15f8864a18586b76b32a632,\n            0x053aa142100d013792bbd568174ebef586796425b95544a3f6a206a634be52cb,\n            0x22e8c7cd6ced3be1e324aa7ec1f6c7347c849792e943af4a6d20c962df7a8e00,\n            0x13a81629feaef1e972cb07eb6d159532540d824adc6447dc68ddd3d87f57d767,\n            0x2e28fe5682677d8cf856dac08146a2be10967e4a4e4f4566997862b2e6d05b2a,\n            0x01d5081e49390999b33ea02ab069f0b8855d3fa8bbfd43f9121b4cf28783369b,\n            0x105dba4ad50f65b112ba7114004c8e78acdb8d82e503eff0bbdce42ae5ec7b31,\n            0x141fad864e665d79d8db92eda98782ffb2b2c2f9a3614b3fb777c52415e7d8eb,\n            0x222b0b923438c6a043369e9aa8eca0bbca03c6a27043cd522093da00e0f74967,\n            0x29a6fd647be4d6cd66d9a1113b7360370a4c6709218470c593429b96af7dabba,\n        ])\n            == [\n                0x0257f0ad69a35000c0f2098903aca10697d8b0909bd7e95f54602daddfec71ff,\n                0x2d9ef8a8b201f129cf9ee4778dc349d8f07fef770b637c599869d38b210079a7,\n                0x28f7af08ebbd432d38e754beed5388259415787336308d3368afb59a7afaf483,\n                0x05ff1f845ae26942c954561231bbcbe486d11910dffb70b79eb4623ba0fc6ef0,\n                0x040e1059dbe09077cbfc249c44a14c15bd76d593223daeb3bb96d2c103e867f9,\n                0x0aa8fe67e12b6fd4bc4f43aabf21d3e2c0527a0d708fc15537e49b8138fb14be,\n                0x1c79772645dad9c4b23063d6af5caa9265477748de8d1cd6f09d8e8e7f0bfa3c,\n                0x1da93a274000eb66d6f0745165382a3ce35f8a6984f4f013913e05294113d80e,\n                0x230a40b2e0b5c7f1421896cbadca811b6ab7bd7d550c009048a9a3f1b5102aa4,\n                0x19ba5c10d702746c2a91c418c7da7529fc7739ecc8b9ebb9930cf3882c734161,\n                0x20fb88db1e84b64a269d166dab1b4fb41eea93fc70e8ac70fba15c41ed94440a,\n                0x026a4a32f3788bf37504e335a6565b53554c80f61dd4affa003d399a704a8916,\n            ],\n    );\n    assert(\n        x5_12([\n            0x2668dc335384b37562764a5a19c9e518210e99df10eaadfd8234582773424edc,\n            0x1547f370a3afc9e04397c85b7a3c4fcb4a1a9a82c496f97a24586ddb2899991e,\n            0x301401729a06d886a0e6994e5eeb05df0f132f1e296c7c27ede1ae6e635badb8,\n            0x1f3baa6f3437051086ca888b5bfdf4fd52c0d7dd0530e7ac7da2e28f18a3f8a9,\n            0x274c0f2fe96c00f0b5a429330c5d353f11df9be99d647de5ba2f304c93c16a0e,\n            0x0fb1c188d5e118878c27d579087530bd62fac3244567a97eba7f894fbc769d44,\n            0x25954b4a8b7715fdba97363ab8eae609ffb4f8c4e21a95d0c5e33fbcd44b8e4e,\n            0x27cb4b4b9dd72782a603042e9055c323528979f9e7cc20b9e9732c4a893b0240,\n            0x19945581bc40d43994ec03b221b67bc066c0acad440b8e088e053a0c48bdbb57,\n            0x1871e044e029613b440f0e4c42f7016f2d5996afba39803537cd43d231bed230,\n            0x2cc3e85d2fa143ec0d4360f4b9e818177aed14aa1729abda9fa599895b255b06,\n            0x263692e752e88ca26f0a11f287bc6e34ee9293960a3272317306cedcae431daa,\n        ])\n            == [\n                0x2761fccbeda551f0c04e8b2ff444c1069d9f6b1ffbd27a6cdfada182ba8dcca0,\n                0x12229ab4e7120c8d3b6ce91a8dd6cbfab56b47c0a83f975c1a6e02f9e3d66ef2,\n                0x2f21544af0290c7c29df3aa46d799a0c0e90d1643598b45d6c5372699fcca267,\n                0x26e3da009605d1bba4a63c81b74274a52c61d0700084c8ea08bfd74fdac2d65d,\n                0x17de00cb801527c11534a372fcfabf0f671172b6e868b8d5be1c513065f3a11c,\n                0x1047b435887e2641c56bb84203a54971509ea420628366fa567588e66fd968c8,\n                0x165d2fb6addc9d82bf44c478ccbf2ab3f60d07eee609a4840367accb3ae309bb,\n                0x23fc43f57315da64e45970d84a4200312b65d7ec8c6778831e5f0bb03748bfb1,\n                0x2fce79cba7d35f3b7ded143dffd7f63ced3310a240fa9f8b87b3ad209cdcd999,\n                0x02f7c02befa262f3ee29bd5b7090500636c85bde0de0279166dd0fd9a4235aba,\n                0x0ca46b5a35de6bba8669fbeac600724eea86fa910dfa5e7aea6644cd874bf6c1,\n                0x01eb392b97282a8841f0aee92cfecab3ce141aaf895e011dec35c41ff483a3c7,\n            ],\n    );\n    assert(\n        x5_12([\n            0x12b0aa3d80398d5a38e8bd25d2e0deafd716d06d5b81226951fb503441fd05b0,\n            0x1b9dffbb066e42c5e5fe85e5850f542afb97ff19d0d9e336e13c342b1d856b00,\n            0x2feda7e3978df56ba8ff3b2f922c1dc14b1eeec68c5b4439c48fcb588dab04d4,\n            0x2412a693e4bb430dfe125d42dd27ef6796aa5243325c2da78de0f67387e6666c,\n            0x02173d9ff42d29fb20ac917034ca2b71ebe1c3fe601155505e5506f248a7b4e0,\n            0x0e4e6b1d12b4f45c77e827c9d3456a06f8e072549f5ad6fa306e9a43a803a605,\n            0x2150a663f9e09a48f2ebddae69702f805f876c4857e339312fccb02ee6ad7b21,\n            0x2e35e0cc3cef89f252e864a60c17a99a33992ea8dbb9c99c8d45d8a515499d09,\n            0x0ca9ed526f7bf21c7b1c94cc628da0bb5195a0219663dfb6205d3f6e58a64123,\n            0x283102b3b664803689b7455d3ac787e983718440d1629ab68099f844613bf82b,\n            0x113416a1d8301bacfdc5b45e533a93f7d00ea8882d1dc8a9f0dfd1ac13f8b138,\n            0x107b2566c5b160848eabecfa4b917f7a1ebb03e9593a57b7dd964fdd0263f221,\n        ])\n            == [\n                0x16a931fb7416d55742ae30f51abaac8b2d50374461b45bd7c0d3944325cd892e,\n                0x10ecf93f67f0a304cd49bc0701a89a649a22d407e7172e0d588e8efe39b9fc70,\n                0x1ef1c158ae71004e37af4e204fe4e8de4e09a6eda70526f8de2497a43a43aadf,\n                0x1d1d8ccf693996a2e6ee6911a46afddcfa21eaf13bdbd595b95da72de5cbb0f3,\n                0x0aa36ee23897734da0727d13d55a08708aa02b34e831d46351f2ddc697f90969,\n                0x0aca8aea0e6f9407a7e505bd4bbd17b236d960bde0de04ec8fc780b85db2c4d4,\n                0x15b91aade12b7ef464f05f0f2d1bb28e5351aae1b69b23459102fa8c749e8b59,\n                0x2d446ff7f6e277dadf83f087de11f06845edc688248fdafbde1d003fb67afb57,\n                0x21e2cdd361f7000d443656eee38424e84e6b8ea759f6166223104f5c1ae4145d,\n                0x0786373dd287cb1d1af2e54a065efd1ab958069279a0a42e2e902fb59c136e41,\n                0x20f80e49d40a3100f0e47d677efce1a5754aabbbe942a268f09435bff7fae158,\n                0x0de42ffbe0e04712b1d7d0f921567de60274c5889cb26ea4a843b3e8ff0ac7f6,\n            ],\n    );\n    assert(\n        x5_12([\n            0x06f913e735c17444995621ccb42a892f5793b5bd46bdf03a98b6eee8c982541f,\n            0x0574c7bd5902a962ed3077ff2e512248814d80d4ab986a333e61501ab784d116,\n            0x156f483ead068aeea616b0207af754c9d196ccde6a4cbf3c065a4a0d6cf8336f,\n            0x0c36eb86f67eda21629faa9edfe7161811affbc1c74b60d24aa07069f56661bf,\n            0x20044ad0f60425e723a914e7e1c24c795ec1545a0fc82d9772a33bac351b74ff,\n            0x0544490febb34958b8f5e1dcb49707b33cae9de07a14437fc19d076be4a36586,\n            0x2f763f8c88ead599291f6fb6b2d3638b8ab2c786d0c1d3cd4d228acbc69511f8,\n            0x0b27f81a39605a7a02f36150b6a4925178a1fd47fc978fa04d79998226e8393c,\n            0x2a7ea9a50b2d5ddfaaa08d928af2e106fd9310effa7c26e477f5e09b7766a87a,\n            0x23cefc7bfa7eae7afb78d4477e9c0dd80b9f352c2cf740339c2c90ad8c6562cf,\n            0x0e34dc8ad491c9d2a5dc1735e5ef048adc86e83263fdea28d8d6bf169b6edcad,\n            0x2672af63011515728922cfeaa20a049e4780434e752ee204c83495e5ec6a71b1,\n        ])\n            == [\n                0x168fa37ee9e60b2a56d222d0f46cbcf2a9df856988d85de1984da99c7938a19e,\n                0x0a73702bbdf479e17920fd6c3ec1dc23388dc682ba923b58ceaebd10e965f984,\n                0x2ac4fbdf9eb9b89fee2459c2f3b0815a202f00810102a71efb0a7af8b2da788c,\n                0x2813a024b1a4d2d0f7a84b7c342832ee114543d0721c0f64ac6dd38d4b11d8ec,\n                0x1dd01cbf89bfb151ff192e3288bbcf8ab945beca481dcff187e4d618912aba49,\n                0x14c705069f9c78085477d0e6271a3028fc91b598e5d18d80e458274744bb382b,\n                0x0f60201b8442b0bb2565efd1811ef6a676f1e2255fa7b58485c8462f6fba6a51,\n                0x2237f69bb366146603f4e99213a34100c68de11bb266753ed12a3db609301f40,\n                0x06abbdc76d0a8a44752c71c18f6a171dd7fe06a28bb2e44986589be9a1b6e154,\n                0x26b80d0401753addf90bcd9b049b1368e9fb319cd9d75c41799d55c57b2cc1f1,\n                0x0fca323792bb9dbb480e3a11815750654c819f9a65881632c6bd28bc565d3565,\n                0x21baa4015d5311a3bc0f3c06b2ef48ffec89381da52d64f7b514bfa4c019edf7,\n            ],\n    );\n    assert(\n        x5_12([\n            0x177a260bc01e2206326dad4ae268443ea9f9705eb56166656d4282182e48956a,\n            0x13a9fcfe422c32519591d2a702cea14eea6e86d596cf540f74e6e46288bd53af,\n            0x091fe67afb9b11c527c44796558c13948377689f5a0287ef66bc03c5cf5e7057,\n            0x22fef16b4f5f91be49cb622133c2a2810df4ecb92434c9ccc59fadd66f4f8ac8,\n            0x03aee156ecb1432ef49a275c47f05dbd418c0495377f9711ef9a475cdd6678c8,\n            0x18a8fa0bc6076c19f4de1dad675096485f2dd87f7d609a62dda31a190dd1a73b,\n            0x04e9d288d148ae100fe9c0a0fec1d380bfcfbecaf5793cbdb1f0ae63798390ee,\n            0x268588efef94f39d1bd2ec66efbcbaa874e8bd82c25d9ba3033667005672d70c,\n            0x2cefb1f70bfce0734fcae65b774ab4ae43d3ebcfe6dd8de89ed04d2ced55641a,\n            0x01f5dcd717cdb8520a7c5cfcdba85f39650963569f9f489f777c198795cde267,\n            0x05fe859357c4d9d97482e1e19a8ceea5643fdc8dd765940e671323b46839ec19,\n            0x0285aeb28910cfa907fc8997e86a9e839dc895f0a0e5784eaadfa963fc15e325,\n        ])\n            == [\n                0x1fd6005c290e81d9c34318a8adbd11dc97926d229d62857ccd76eaf410e71bcb,\n                0x0a81e443d16f10e0ea7383c8dc0ff87de8de5f90f98cc2aafb273d9b3a65dc2f,\n                0x3060c2ef68c8a51854e47610c28209e4dddbcdaa9d8ee59ceab07a40d723c792,\n                0x215cc5f37b3678e6b1d7e150690f7ab0062169a1220bcadf3016d8105f1e2731,\n                0x159ff7fa2d966d31abf6cdf41a6a3b574fcf9e9cfedd74a55ab78acf3e7481ec,\n                0x08ce401382ef70859aa564acd3a653c9b01aaec2c98b8437f9ed265303a660e6,\n                0x1ef105d5bfd674ee5c1e9484c8123d8bbc658c1346547b6ea008cb0ebb29f1cd,\n                0x1cdf6648a93f8f8d391c623a239b7bd0da434252d4b32e3f02ee01a96aebd9ce,\n                0x21988200cbea79d3ee52bcd026fc1bc6b0376b9caac771224d1a767d8d362cdf,\n                0x02b094dc06e309d26b5d6afc8f209fafe77b5cded58c661564404b74111a1f8b,\n                0x21cc36fda0788830adc7a7113a4909f9877c8357f926cea204eac3f544881341,\n                0x05049e36b9f79cdf36b6d1e9a61a68c9c863f8d40055816a1ec97acda3f9f9ff,\n            ],\n    );\n    assert(\n        x5_12([\n            0x0a354297f59aa014f9204280e96ca66b80d72a39a338c65aef8673cd113015eb,\n            0x2241a377f9b8ae774bf59d6d48b1035da05bc0095f63cc88045b4a6150327191,\n            0x096d075a1c648963c8422186bc33cc4b4312bdd7af67e10ff5ad88a3c6ca7afe,\n            0x196dd3fde8e4b0a246636a3a729f9a9edf9c5be51d60979a031b74922f29865d,\n            0x10b42b3ab5dece6450a23aa00cf1be5e982fc9fa50695d672a62ad6823cc54cd,\n            0x12e6f93b0c38eef45bead71ed2c20bd370acac6c144ce3b2fb93f32b9d3ac2da,\n            0x2528654f111a309cc8dd885cd49c3c075682d7a683d56d9d5f2d66da33caec30,\n            0x282ae441aaf30c2b08e0e0bbc657bc37eeb00b9f94c326f81ebdd5f1d7193311,\n            0x2d2fd1872fc0aa489d34d8726bab7d4db12c0edf4a0ceaffddd547b4564df0fa,\n            0x27f0c934ddfae26f31f1ac4ddbd61539320ef641e256efe6ac45a81c6a5357f5,\n            0x23ef2eb57a5a9a5e544a41c786229d4ca7d601bb8bd53981bd79bd67cbf4cb45,\n            0x12a74499eb59691ce7cf48f8725d4097082a9281a2c2b5f54e4d9a9341969b95,\n        ])\n            == [\n                0x194eab2c8b53787a84dd6e88590b591db109c63bdbcb4dc180e31d1031a7342e,\n                0x2118c1a10302af8ce58b29dd5b32ff8f9787f54721619c111095f3327f6a70d2,\n                0x212f12c1b70f000983b1d2272838230c69954f5dd7d197fb0d53cd4cfa80fd0a,\n                0x2409845ae9673176bc51ae77ddfc98053cff90112efa3dc67fa5e07cdacb1fa6,\n                0x22abb8e62ab7f47dfe5ec1d87ca8381a63e7dfbe26d0eacb66040b472941278d,\n                0x0eaa0d6fbcc999cb08aca688d4c4c3a5f6b65f9f6380ff6f744b2d8b288252db,\n                0x255cb80c5ce5182a68536ffd6ad4ebd98058836647d8f276e90e71fd19bebff1,\n                0x123074efc3df4076da754532886d7c37e3c3eeb4ac3879b0e225466ceb735967,\n                0x0f3f4ba00481221e9d34f5878560f932ee12d045325df064c224f2d8db8551c3,\n                0x256915e6e98bb1e24a1a0845fdefc7c6a53c690e94c39ead0c76c19a629e7834,\n                0x1936288460695d01815205027a3892a23649ccb9f12506a47ffc63d8c35ad7d4,\n                0x2fb218ed949c4eaec724e1f2ba132bd4e390c9ff3b4d28f6b328b2387a8b9934,\n            ],\n    );\n    assert(\n        x5_12([\n            0x038c3a316e56fbfcbe9cf422c1563a0551b6f6fb6ca764db2cad53ee63c06c86,\n            0x15c3f186965de711887fcd8ef5b395e97f924941134119e21d204a4e1ebc687d,\n            0x26989306c28e62da14bfe4b08459b27483e6522eca75b0938080048d3d34daf4,\n            0x1d0e2c7034504270f703809ebd28af720fe2ee1d08d681e1ab00db3200ed9664,\n            0x201ba1f00c33a6b1a7dd0f774b94c6378bc3e4a69f6c018cbdfacf019e896791,\n            0x09d545e35cffcfe4fae0d83fdfb2d3c2018fcb0338afda6d0a74baa4f1b8098b,\n            0x0f002baca28a8a79c2e1f4f68c2f3eb6d12409ac71ab33ca35ad528f018dd6b8,\n            0x24364b11b5769a8ce7253f6fd6d1b948410173285d276a5441a0239f483a0df0,\n            0x26611dc5eb9bdf8b12ac7493cc531e3a8d758822ea2c4b687611abff37e4a560,\n            0x2b202bee34a7958f47448ba49ce44bb535ea9835e72a6b9726ab59ebbbfd1d49,\n            0x1813fa6108f51d636cbe5a23dae341506442c5ef4f327a9b6ca122e707f7431d,\n            0x05b75d9774d263e55429b82ebe8660d7b28a0e7cbad28a1533834641c1f47969,\n        ])\n            == [\n                0x0315c8823973adf8f0278ac8112f2b04ecd95b87719463c4393573581fe0d6f8,\n                0x065f4248729ec96b816a59af7d1b7df71df49c58cc2a9afbc0395bb3ddbd6be8,\n                0x1406e102b472cde209f5c37213f62b265dec185dbd631971cb2023d985d5ce04,\n                0x04d8865d19fc211c94a232513129140c0f86306623e36f117635891541bc6263,\n                0x0d9577e818494042f48e998aa57672f620bfeed5e89f6b929728743318c3bff1,\n                0x2d4fdbc297d26614016e31cc6b51be3e048efc42ffb32ec878d7da8366b62e12,\n                0x1e7adfa1a68b390a0d9b681b9b37e0fe773038b84f51dd2239545d070c7f9c13,\n                0x1f7137c1db6ed9c608cba8df75a131bd8173566c80d7c6f0429d40893bbc7cdb,\n                0x22b3c88196bb3cf52d93cf0505f3141b01a9d696f9b75273a9ed29aff7c8c7a7,\n                0x14c1c9487ac3fb49fa10efada3e36dced10487077ff24fbbc1c6859fc4437378,\n                0x09093266b2846e1b72402111b6207c45c22ea66fd5a12c9b451ceef95e4f21d3,\n                0x255d822cc1dd2aed4245128fadb29cccfbfe65c02e6adbddb5af28f1e7317654,\n            ],\n    );\n    assert(\n        x5_12([\n            0x2cb1a7dc7f386ebc390c83c64eb12d23d6ce767d27d96935a9247e32812fb7f9,\n            0x0cf7df2f03aa0771560d176d3e1805c34873c5a7fc00c872f5102ef7ab5bd550,\n            0x28b52e69a1ffd2df7f6812a11207f1543c7aa0e40c565f051a721175cfb8dc03,\n            0x18fa26f37810ff1d6dde96dc5fa3d488c213e18739feb0a52d7338dadf00029e,\n            0x08ca33109f8fb4ce0ab6395f90577abfdcb8658abf1dcf300e06f507d7dc1948,\n            0x1401ebcd255db5d34fc562cd00053a1a077c8c1ce780a2a41004a726877d6a9c,\n            0x1b41a43c3a4559c4d13ab91093b9fd53520dd2be02385db4d622e42cffcf15b0,\n            0x1456d6acbd7c08ca242c4dc24152db5f98ccadb20fb4047d5197f900dc78f577,\n            0x2d0e37473c0f1d3bda010e4136dd9d68ed347b23d0425f79921fb57721d2666e,\n            0x0165e900128e5aff68b7db9d0add1c1615e1c1b309514d400798131c748823ab,\n            0x2e9f73bff715be4ef077978ab0c7c3257e74c9e09f416a9d2c02ccc7dc631fbc,\n            0x2546acfa813df1d7bed750425da06ef3971c6fc1378ebd349dea0a15884940ad,\n        ])\n            == [\n                0x0d94945223c7d15a1c19de3b05cc406cad22b679ddae9e6f14ae083a3b629ea4,\n                0x1dd61aeb528386b7b712092ef4a5e298c3ab6374d7b192cb5fde14fb0cca5dc5,\n                0x2d7a2d302733f8dd024e0b0c0a730256ac851cc585f4424e0946e3b811d6fcf3,\n                0x29330025d49a6632ea66d245af5fed97600710f757389310a30bb772e2f86a99,\n                0x284a71b77bd2a264443e4d94b073f2be991d1f16cafdc4536df1411ccd547f3a,\n                0x11593ad25beacd1fd84db833ed62802b962bd5e0c40d70bae9a89d3c75c73642,\n                0x1f241e83d36b3f8e365b6d5e2804678801eb427cdbc9eaacaee1d4b7e847316d,\n                0x26afe3cd8d36343dbc763ed8e97097c555a6982094a0e43c6ab60e30ba6a2342,\n                0x2f0fb792a6860a99ea231776cf1c356811ddff2f95a8bb3a0b122409434955fb,\n                0x051d2c3dc512f089685de894e4182d701f4753cf815d2b509c0ac4c3adbcb011,\n                0x0e84382257339dad52727c2ae9017a298f47a84df54e20187c95f1a411af76e3,\n                0x0dfb0fa8b51ba9c7a88504eea234dbb963cae0d7528bc01b842b521c39b8120e,\n            ],\n    );\n    assert(\n        x5_12([\n            0x27dea82d8f6011df0fb78da7e82e2a13a22f566bb125274842ee68c942ef7553,\n            0x2c7efbf12d19e481fe927c5cedc2ea0ad4e7f3a461501e5b8cd2d559b7d848b4,\n            0x23c963940566be144921a594c3fb1f65068f8ca74fd2102b4475a06328c6e9ec,\n            0x05131895b08c5568114cfa055e5fdd9a43619a11cdea859ef88e40406b10e70e,\n            0x241cb1dea84f0fd68f06eb8e2b37425b017301a93b42fbcf01fef489ddcabd50,\n            0x1c19a4160692eb67a4e98f0c1ec74e34364c8e2004cc06c05fa29a8301db0599,\n            0x1817b5d0a05e86e72f9827f4b7c857a8860ecfef963b18ce965b8e039f075ce9,\n            0x012faeb2c72841492df2192a637f27b0d31a20ca554d451fa2432f953747f6d2,\n            0x253d1d4759f5ddc1c15401bc232e6041e8e7fe7af9d55646a9285ca0c1bf3225,\n            0x226f9d027230383e36b643d17cf11b259e25fbb938d9381b3cdcbdde16006186,\n            0x0b1e4e3b45c23370e9a33a44965b6ed9c70b3193b10f9fa1ddf61747952bef9c,\n            0x1da8de91caece3da1f98e36523b57d29ffea0f5a0364ae04fe6384bea8421789,\n        ])\n            == [\n                0x11e785574a8422eb0a7b9974a4704d2d07a8105268753a96abb59ba492c68d44,\n                0x2d655fb4b6e277d7651728826bb37d7e636c1dee8d532c3e7dddd83d610a6ec7,\n                0x091b41bdefe0e8cd69d94e37eb036f2bd89c82301fe73ec875879bb16b6c9ed2,\n                0x27be34771f7b56c9eceb72e2cacc6c81f18e2317ab1de0d6b330c78ec4d25c49,\n                0x1810db044a8de7cf325fb71272cc1b159f5c7c2572d5a2e254ae246eca122ca8,\n                0x0b9e2f6caa86d76a496ecdaa802431d8e7ce640fb34671f16b59d43719a181c0,\n                0x2d54f8498ced37fc8a89dde3dd4533b229d5afa9f212108b31e7e229712eade9,\n                0x142c4d823407ce1a45cf7204e0bc3afaeb7dc99ecc19a05e2ce17cfd0549e81b,\n                0x2576c6e7dfc1b1f565c01d9ea548c960c94a2c3cf9fafffdc2574db6973df1dc,\n                0x15c96db01380eade5c28754ea21abb2ea9051ea8bd03a74c41f5562906376ed0,\n                0x0e94430cbc9671b09b1a378684d53c5e38181585dac969ee6afd72ac2fe80d52,\n                0x08ed6b7f639aa70211b8aba5e661ee0309ec827690a9472d84f6e50886af4d41,\n            ],\n    );\n    assert(\n        x5_12([\n            0x26e19349657f94d69ef38f895ef34f6cd3dfa6677b8f083b158491bc9d019325,\n            0x10a908d07457a6b73175c274fac62205da9696826a4d2ae29c7d95896c74d4c1,\n            0x1a5b072d9790d06ec111e6220a1505f7a7bf604325634738da0c17abf980b4da,\n            0x23c06f97c13ff15b47a5498b081aad0e853e4c606b920430dc8f74147e1813a6,\n            0x069b8ddaae46ff2333637161daa57868cf58348528844f39b1c9db77556a6f7b,\n            0x0a2f40d0fb59d436d45066a15442aeb5a779ff5c5901761499e37c46e04a0829,\n            0x240811d7aacb9e5bc330b6c2b87048efa021463b33193d6dbeb0070fab3f12b8,\n            0x18025d1b4cd88a705ffe58cf9c537441a46c730e549967f7714c3d879c8f632f,\n            0x00f8aa0d972181b48333521e50f58ae30f76d524da5a76abfb55a34999d30a41,\n            0x1973258be07ec6637cbb9068b4459ac04eed5e6b5a82d24f5b3e04d8b4e4b573,\n            0x239d3d9e7599144aca6dab517d82df07f99a80fd8907ac590626ce6c8752ada7,\n            0x0205b13226797036e6099fe4860572e772c9e6a741b6dacc38f823b6db0139e9,\n        ])\n            == [\n                0x237d0dbf07704544f78073b01b7551f4c91a9b830d87719efddc466b70482fdc,\n                0x2e8753b472abc3b9950c82084c89fd6315f2e18821695d5d7748ccd55e7e0f8c,\n                0x0dd69fc03905ed5a5b9e8f1698cd25757e8fb62d8029e6e1186cda5ee8cafeaf,\n                0x2035d4d8fa26e694a2ef3d21dc5c5e37f1f287e0e89e43e84730e59cd8e567e6,\n                0x17c1631a572db0572bea9aa8d42e39091e182bc7ba125b1b69c482c7388085a6,\n                0x2fdd08a43d40740c7419c28785951c220cd078e8678332dd875f6b15b816d21f,\n                0x2eaa4630bd3804b09117864bad7d138c43b0f8098b75407c68d37ec98f5d860c,\n                0x1475cad03a214e262f4e0f1b70993c068f0c9e508075ee72dac7a91ef5e85fbf,\n                0x030767e78eee3e7a0a33432482a6429d5cd01f5b3cee823ad789d53492110d5d,\n                0x0bc095c941cd2404b561304bf3cd2310f075f55e711ef0e96ba22b8a7e91fcb2,\n                0x0772fc2464ea3d268900b9fcafdc13dcaecb6c2deae2b84f0d75fa5652e42d91,\n                0x29dcba74ee5bb080a8e156999617ac14112435779afec154a9e08c36d286947c,\n            ],\n    );\n}\n\n#[test]\nfn test_x5_16() {\n    assert(\n        x5_16([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])\n            == [\n                0x0fc2e6b758f493969e1d860f9a44ee3bdffdf796f382aa4ffb16fa4e9bcc333f,\n                0x0c118155a0dfeca3f91faf14a350511228ac33743be91249c6e0b3a635a50de4,\n                0x1a02b3a6571f22bb6392322d3f9f5de145b4f00bdf483072ce6188c30ba0f83d,\n                0x26631df6b2522ecde57413cd680ed590ded356e1c680f865f45be8eb960d1e06,\n                0x250ac4dfed40dc37bac9abe46f7bff3a80481d52a157ac80a1e5d39a5ed60e18,\n                0x17160980d8e7d9cb31addaf294cf047768bffd9fe433e8903b4ed262ee913f5b,\n                0x1d708a9f0995c2e0cd2f55e5dc795126f7191a0eb934ac8172bf54e520361ff6,\n                0x20721a18915e96e37e12c9697427f34d6a366787ea94ea65565c36813a0d77a3,\n                0x08671a9e58105eed9ac673249dcf22f08f098e3c6eb28f9eaa55d67d755972d0,\n                0x01e879484303c6d057128fbcc3a4222c779a62d3666df65d4e0b64c8031d7cc4,\n                0x239e2ce87955ebe19aaad000b38725b729f51175ab7d688f15d997edf0e3b7fc,\n                0x06be612f42b3ebdbade3fe199338c9118eb6b5fb760bda96e45443f130a8b2de,\n                0x11b2c04b4eb9e4844e5ddbb19b56059a815ed5d69405ba51786961235d5f073c,\n                0x006da33e2d57616c0ffc855b48d225a1237c3d80fc7e6b6e73b74e162b85c8a8,\n                0x0ef50c2615882523c6c73a69b4371332a066b2dc4b9630f186db47e3bfca88c8,\n                0x0e2ceb1f8fde5f80be1f41bd239fabdc2f6133a6a98920a55c42891c3a925152,\n            ],\n    );\n    assert(\n        x5_16([\n            0x2ef5bd70482d1d5bce16a04a5220175878dc715c51070672fd79df2f36fb719d,\n            0x015425a96665c5004e9210cf6828d8019c057cd587408a27347d951d9dffc2d9,\n            0x1551585c9c4cd84962ce750509aa7c10f6070167cf02f413b1ebb99b46070f9d,\n            0x13b3e781956e21bfa1ab9b729c8870cd6834165331261b613ed155bec20c705c,\n            0x1efcc38f5d29388649ac90a53f2f18199b3b85b18a817e0ecc35fc8bc0c8f935,\n            0x301c505d503072bf6273b63ddb8ab6decf288fe0ca24e01e9d29d1c2b445840f,\n            0x1d0f515363f3f1d7a730fa40ee5adfc9dbc64ee624f748578583724b9c950d4d,\n            0x08d0a79b8f7f9900e653719a0fa83eddea4cb60912ab072a7c53c5e06be06f57,\n            0x257634dc118a69195eba44a7d683b806b13b6954284c00df03fa6fec498d7136,\n            0x1c3a1e671b80722c3093704597f0682648d4ed2edf527c394437f83455c6dc9f,\n            0x2b9b5fa799f3e7e3b25f5789aea0ad85cf688df558df55cd5aa01e08ad61a0f3,\n            0x2976d9a19d3daaa5d4754b07212dd1790e1a2e792bb1f3f3c1fdf29cb9876a0c,\n            0x024e57dba7a40fcd9c055126821db288671ca25c7a2d331f0a44aafd281c420c,\n            0x2ace2b5e9b3840a1bf285ba01256a92c847585a0387d82959331e1ff831fe7eb,\n            0x095eee248104564b4123f8b16cd2e659a84ee02453ee37267a42d29fb4698efe,\n            0x023a74b7eec73c64bf4c824bf7b15004252f23594d733e8b5e3df99057a1a402,\n        ])\n            == [\n                0x199f8c0ddd4fc19fbabcce889b860aea0840b953d7cb9897a24c03aa91321f30,\n                0x0488d23f20fce69d1c4f405f407987c50e605487002856e3d100a531fbef76b9,\n                0x263a13c6a63a36b7f83690126f3da9083932a4c310fc8273faf7fc7d4106a61b,\n                0x0c819a478981b1e3056aa6eacb7ca03c75df4ef8106dea2e920c6a30ee6eb295,\n                0x186a0cfec51820f97f3c64ca9a3f9fe84d728c3fc65298308db8c252e7763d2a,\n                0x1de58fac635c3539da015d1ae4f775af54ca361c1bb33949146ebc92ec08ed05,\n                0x22cdb2286d74a378ab0e73265d8ea805e70487bab78b09624fae0111e72e7c17,\n                0x2a530cf261e7fa2c5610fd39d40e5363d238b66127bc4da42d3c3e41252f2746,\n                0x1435915959547c0b78257f1ceaddf744d24f20054b06901686a409f3fb7fdd02,\n                0x07d3142e793fc9b5d09fb56da48bdbaf9f3b0c0a60e65c22faea8abcd81fc68a,\n                0x0b68ef91843d5f6a4d2c9274f6ddaa7bd6d78677502d1f2f6b220016fa569b92,\n                0x08473d26da0495891ba80a6b8a306c62d0084260690ccd9f5528a11bf25d18aa,\n                0x2a6c3ab5f6ec231bfab2908184025cf5107cd9231d9e24bfe4676f93e4232528,\n                0x1e7b9102952e2c43c201ca85d589c2ee2f15a0fc44d3c1b14674044b4380f9bc,\n                0x3013bd07b9ff2be6b049d89513b0a65965980986383a64cd5dee34a1f5952917,\n                0x02bfe073ffc8a0c7cc5c2887333dfa9252df70099500399034bf491bb4cee13a,\n            ],\n    );\n    assert(\n        x5_16([\n            0x06b55384dd1f8432d7a1c51b5a6233347e1a01d6ccf71e4df8a97e6acfea494b,\n            0x1fb69c58f691a3f1a356ff552ff6472e1159c39eca1298ff6692ebf1221f21c0,\n            0x1b57c97bd134be1d2ad6ee333fe8f0edb31fd49777b62b78f8ae06c9fda9e4c0,\n            0x21147db82f08d38c7f0041c175f162a5c446de7358cfb084b0290da8eed8a6c7,\n            0x05d9295c10f3f4d7dc74e642e028503ee78745e579cbfa3f1aa69d51921e7f2a,\n            0x08b7ed23161d249564b4fea706cfd77493bd09177077ff0e0c37c708c9137593,\n            0x0f6088e95561f9048541eac5e33fe33cb0a63531feea3fc00158956f4b3cc005,\n            0x231f9caba6d6a31d08fcec1da6c51624fe4563dffdc58f8874cb7e466c98dc50,\n            0x2da993dfb755a6c0c91a1253ee0edc67da208952f85ee94bd4748bfe07b7dcf4,\n            0x2b570a865c287eb3a020b7c5e8d6f9111d77624b77800061df004bc4840e69e9,\n            0x1073ae829bcf6044b33dc5879e01e2e85dc2f555704210a9dda4b1e1540ea2d3,\n            0x2ddd9346aadd09f246abac523816c59f66742633fff2f678556e08620e06b885,\n            0x05c56534c601f945933edbad83040a988aeb0c807891be8270571d942af99cf3,\n            0x26b1a1a534e46eb0e05289e4212b98b3c3c9f03ef2e6d26c85eeca1727ab8628,\n            0x0be9f33db4474cc99f5e835083737dde85a90a009b4d0d06afe4e0fc9230a2c1,\n            0x2bb8306d7c7ec521001e46c904e4761fe8336f9f1fe6ace0e1b5b8b1f473af55,\n        ])\n            == [\n                0x16870ef1a96a29aa6f91b1bc5f129795424bb1651dbfa593b6d67c45a015a325,\n                0x0b61b9d5c43ce81a4101b1a0cf6fe7e8f04af3f8c0af1c00661b89f70addd21a,\n                0x26ed8fb676ab100a0bdbb5835e2ae78378dc93af64926e79ce6b4f67f40a9f2e,\n                0x00afc78c94142cb0b383199db78411ca62cdfdc7642c262b50d82c9e4fd9bb2b,\n                0x100bff127ee5f3050e32522e45372280894ff84b2d73ef46f6b0a0fdccaf7ff9,\n                0x12414b2266a60acf06663ac7396712445676cd748589f272ce0fa143a503af20,\n                0x0bff1c82da41aeb1e380e8fda26480b010e054739d086bdb1236fd173166c032,\n                0x1e969d843bc4ab33ab1ee96d266d57be7c3a401660a5005f2e60378f20913a2f,\n                0x05848e0592a24fd0084d974d1ff4993a11a6b421ae3483bc3c875ab8902c52da,\n                0x17c202dbd22d4ac3d67ee56f02c9a7f707962224d1627bb40a6d780a6c166b09,\n                0x24e7c391772e5cc73fdc171313791b86d0463bc51e7208d4cfdaad7209bf8281,\n                0x0e206595d4d2e3ddb5eb38d58b0bdfa5099b4968a5239912f2840355c67c02ec,\n                0x26323fca2471db34936ee8ec5e48e20de20897de79170ef2411df3e438be8739,\n                0x0a4e622b558ef6d52c7cd3eaa99dfbef28625d7c6c97cabd4f4133c1595eb51d,\n                0x0c64abe0b9786cd362618b6f82c51759cb62844cf2dbb5d42c46f219dfe0f2ac,\n                0x13be1ac72d72e5228b27c42bf32e0672c9cae552f97b89facb63b940e3f8eacc,\n            ],\n    );\n    assert(\n        x5_16([\n            0x1cbaec6b27c2ebc5fdb69e1333798b981dcba6b38391557b7ac7b9b58d0f66c2,\n            0x189851071e8428ff3c8a96ac2ddb17ed0880c59988c3fee8dbfb62e195867fbd,\n            0x154f46875dfe815d037f8c06b2067e2b5cce8b77a9464a65ef2f6e665652b293,\n            0x210f88d63fa89778096ad54e6c0936d8f4d2453536f8f86b83ef5136ff2bc98b,\n            0x041e749316da9c8b5dd8897666b38053a14242ddc349d6f327eaa1e42ca5b570,\n            0x3021a34419c0bf5d11966d97e65789e3c614f59cb295c26b03139e59a053ad2d,\n            0x153dc912ce0688cca194db013cb5af4bf76dd0bcccb59803d6f47a626e838629,\n            0x145ef2786cf7f7dc887e77cfc268fe97d0ce8d3dbd62bf349dd28e8f2a77b008,\n            0x2d284de1cf215ed8a1cf131eacd8f192ba61c98383d2856696da2e670a5b23c1,\n            0x258f58bac3d054ad5f27eae324fa6fe5bba15ca5b84c93887aae8bbfb81488c1,\n            0x1312478dee9197edff1690bf7b350856b0f6960f0f4bd97b1aeb1866f0e6697b,\n            0x0633a7322a72259ae4201daf36ff2dfe2465227bf3a0d521b7b6aab723db6c1a,\n            0x1d712e293228228b7f0b05446a2f4b27c8746711f59ed13bad7218be7aad98fb,\n            0x11745f000bdcf819b4ddbd377ce1d9eb7c326025159c771b055a7ac41e46eb72,\n            0x1fed00452611c593649df2ae4c8f83545a897e67ed2d9acb028f94d114810505,\n            0x2525294c748d48ab2b1f30a660c134608427b3be80a4d72ab723b17d25ed5d52,\n        ])\n            == [\n                0x2b20cdac71d0877cd2ca763fd3b97286a7c6958b9032ff694f7f9a0fab0e6195,\n                0x23aceba4409f64808b72fc225720057fb9bf610fec117d3f981c8743884fcbee,\n                0x08662d7bfef474d3ead01bf3c94fe4ef10e70baf5f6d1cf3e07ce4b6853f66ac,\n                0x0bdb073e51bde89f93a65cbfd98e80ea7f091299ea93eb6cdfadfcec86757077,\n                0x2c78c4dd3279322e16ade03e9c9391b46933d39d5d38d12e6f390b50591ca9f8,\n                0x2d4d8765fb401a33b156176d07abbee282c9e7f5a87a1b6e288d5dca2111d909,\n                0x16a8cf0704071589af3113d86f0b3d0911a56504392015f5adca2c02cc73ccc5,\n                0x055f44503d034bfe2a2699bedbd15681610407737fd8dfffc1513fe10f39b289,\n                0x087742e5845e1b2c965e7f2bc5b408cee716df9c019fb7a770138d5d847e02fa,\n                0x178cbed7704d0d1da3751950067f811e807ffd9c932a7e8ca5d640a41f596f04,\n                0x1bd115492e405f8d46cfd0f60404ad75497aed79a906ec85a29e396f69936ef0,\n                0x27a5f932a5d1078475096c225559697ff8ef6b1a99dec900d802042b71b41987,\n                0x25f29fa8ce03cd5248cfcf4485993eb06d6c0f3223a9ee97af994688bc6d8208,\n                0x0120aea7c2e569bd1cd3ff49623c9d71e0b98e569659802a6ff1d93dae4e4ad0,\n                0x1b8c8cfe6aa076226c4e38ea6ce8407e1e1180720c6c033e041822a809172253,\n                0x20676fd2b77c0704dbf127d2d57e4f3bc12f91a8097c3e99b7a38e9b2e600239,\n            ],\n    );\n    assert(\n        x5_16([\n            0x0aa86dccef554a9a7f6c92f6c0165a13f7a8be302163322a6d5f711eb9e3845d,\n            0x0a190cad0005aa2ce4a7cf7fa9a62653d3f3a43827fff30110fd020402c53905,\n            0x164cbb52ddfd371ffa882dcb7439e0ecb65f82252436ae949192267587120c4d,\n            0x299cad782ce98cb776b5e6eb0f4b14c6cf9ac946c456e42c8285b697e3c6050b,\n            0x088dc71bce272415ab0d566f058612e22395a813a883f38db1822cb18b267009,\n            0x2e1a2c50ad4ab0658989e698e8f5e44e6d6430dcc58b72d2411c670eb2503eeb,\n            0x20b75de40aa801f2d32c39f6e7047f160488af0a746b7b17093f413ef51d2890,\n            0x0ae46fe3de0323cad20b5406bfee689dfbc9d50ed8001d76da9d1690dc396b92,\n            0x2089eb57a6f3fddfddcc41c1eb802f9a01e05f507031cf884329d6db8c7e2bbb,\n            0x1328bee68b74f2941de5e0566a6d512f1911a499af6898269d711c5cc5a571cb,\n            0x25494cc367bf5e4e32161791117ddf46b07f1953a884f32f5cc538bd9593cbae,\n            0x0b9296169e0ab77ce037b47c252113c58a5df01a3cf1578b13e8c5b321311bb4,\n            0x183100059e377c7b243ccedf3fc23fb155ed5033a418ef1918171442bb980623,\n            0x11d7d6603136f4524c6f56871d3d6b55b34535181e10784cab6523a9e22b7972,\n            0x262b84aa27a96cd7969bc7a159bcf16ebc47bc5796ece3990722e8a3748488d5,\n            0x1ce939c908883e403f196b23e35aae5318fe443f56732c7ae3e2e6e8cfa8fb9d,\n        ])\n            == [\n                0x087f30225a428d5c33a5f30a20e144a4bad98168691c477a5d937513c145ac42,\n                0x2e02134b3b4c94e8225b7bda60deae0c941f0d8f1046808bd0bbe6399eb1ca15,\n                0x152f5d1a0c0d5d54478de754fb8749b7085809fd00c084e367798ca4266e3a36,\n                0x2765d29175aef99be7800a2bc4be36b70a967d2d71b717e826d42d996fa36b27,\n                0x0ae1f733d0dde6cfe966688adbbf57d158243f8241cdd4f2ba3a4ed3a33f97b5,\n                0x0ce104a162f4a18b7987c192108df72d8d01fe734d8ff37eba67abc3011b431c,\n                0x2f90f4b7bbf3803960e5d0135933a5b16b95883b0ab32b658e5bd144f7a6e4f2,\n                0x218bdb3f6179a9c2749e5506e3ea3abc9134e1adc1ea964d38060f10d7b842fc,\n                0x016366359c1a2491cd62fb3fc0dff757e731b36149aa71d17ca09e566726cfe3,\n                0x1c3dc890ded994bdac60f387495ced2a17d3cf36debd0b6552726fa18559ac04,\n                0x1280cd57db233133595afa3d60353b3e2bd5bc204bc004598a4c6c4177fdc230,\n                0x051fe637e05e3df14a490a6361c49813eeb572f1ec0e9cdf2bd1b083a3bb4690,\n                0x120f57aaa9a2d63ea48f48d66f3ca7b49bfb2c643a82345086484f07c3d10a9a,\n                0x0569b317c695653ea95ad1238b4c27849cd83fc9915e0942bb5dc04a09b83b22,\n                0x1d8ec58c597322831f4d7ba4cdb1854b16e4a1d50b3dd5d50f5a831068317159,\n                0x11f9675abab82860419f58f50d66788b10c925bace3c0744d4b35d2d705590d1,\n            ],\n    );\n    assert(\n        x5_16([\n            0x1f215d88b7e0d178c8fb74da91021f394ca93b27c8492a2864916ded48b7d7f4,\n            0x031a1f5e05f55ef8abeef5ad6441e6dd3216715223dbcd72b81c4f8bad05c7b4,\n            0x1e7f0b196954bf7434714f11608fb1bb75442a19baba47a538815c8094a4a13f,\n            0x2be3508f3255fdc6e87ed923c0efd1a636015e0300c7b60961413fb1c7fe638a,\n            0x1b57649397840798aa1b82ae73879f3854e93ca5762952136f07af4117b664df,\n            0x1ef0f16ba5fdb90a989f414e49644e591f6ecedc58e932b2382ff136e86ee1f7,\n            0x147db07a080e692a95b481b01fec39845c2663e2cb169a7d31b1968a8a8f91fe,\n            0x1c1b51578fad85b1e0ffc548ecee7354deed9bc75fb45587a6c9cacac3df063d,\n            0x08d54dd1583ec89851a7b6c34f0b684a8a2f2ce0548dbcf3d3f0f0817ef46cd9,\n            0x0674f9986e4f58e1e6b2f66e44138bc1ab5e62d1088eabd0768d1ef294f14e26,\n            0x0b30b59f455281a391c44098a8a25e00ab0f0bee6bb6b6f0b708868000b9d32b,\n            0x025646f735b1b00118aee20d7c8915fad5ac40183cedecd7663ba4d9e065ce4a,\n            0x193a13cb2f3bee2ff69cd7d2abfeee46b0e36df272a405cd13ee20edd821d6d6,\n            0x299c2b6a27955503fffa9ed3dd8d442a075ba565b1c9a063314d8e9f2ed4a776,\n            0x21847ebcbaaa7ef15a86d70147cb83568bf13deaa9616bdd193d9cad4f700e03,\n            0x212bd19baa0935e3533da9d039c0573c6cc511d86ae155e3ff3824b09a24bdfb,\n        ])\n            == [\n                0x2d77aba67df78b757cf497916e42ea927f54c5e31328e6cf1bebab015c52091d,\n                0x1fe50bd2ce720f50a5abc9cacc5e642bf9f0cf48674ce0555ee74259553a4502,\n                0x016149390f59f06de6f97e8a0ba28b041819189b5f92909214867b8e92df0628,\n                0x1b207e3f2968d97fe5602898d8c5ea1e3b950eb44d377042ee50f0fd64891c66,\n                0x198ad95eb80134726e88e82db424001636458d2d5a6f5da69c940af1d61c9d45,\n                0x08c5ff8ac18ad588ef8ebb581cdf38356b94b8cf1ab542ab63f198c13ad3cfbb,\n                0x010b0064966e3457d4a908e9598c6221f73ddf3989df7341f043e7d2df870c93,\n                0x0d2bd5aaed8f574f0ebd0475f7ec3babce372fa1786c0aa36c1ac4cae21dae6a,\n                0x04b2f761bc78dfcf0775a25fb55937efe2f7ffdd6302bbe6d6926caeed70a10a,\n                0x0fea7bbcfbdca10018a0bc6dbf81bae027f12ce721d68b8a6fbd345f564e8c63,\n                0x0ae4518b024d662df03438a13507afdcded21346938c502e5f6fb6cc3eb660ac,\n                0x27007a4792c9d5fb181500ad4c516dda340d96762e0b6326a5d1ff5a4b3b5bca,\n                0x0956ad62323a65c3ba1d1c4ffa34e0401c9d29993a59ad0f4c063b0f8129c3b9,\n                0x2d854411c11ffcf486ce7d6f458782afc80cf2eac1104b605aefa8f7b1eb4392,\n                0x1f4a4de11c6554fb2575b17f7ccb63bdc465ae8db1dadaf6da09f9881a904e9d,\n                0x0c4ce5037da00596b60762c0299771d6c1f3c3ae77d47caa177050c5e655b323,\n            ],\n    );\n    assert(\n        x5_16([\n            0x2d68b06ac8a6c173e6c3973ba865a74dffe3294bff9d0a000f0e48c743f7e5b6,\n            0x11a9b30e033e2e4f6d9953273ea2b0c334dc0d3f0548ee1480ddb8089cecab4d,\n            0x2c8863dd10933bfe3670a9f4626056b32d12c85064b06f69ac6f20b8fd2c3160,\n            0x044d774b22af32615ea0d456d6da216c1ed077b96e363bad69fbe72d45220069,\n            0x218a83e6f91618448f25852a405e540302d5b28719a11491b1ce1bd26997614b,\n            0x286ee17de5be4fe8bd04522619f5624d8e115daeea42237d2beb5e98de6a015b,\n            0x211481e4b0452fc24fdefbb1c1a5f1135816e16b02291c1d88ed3a94b830c9b5,\n            0x1f0d0f9d07e1dfe6471a3772a74b4cc3da80d771fa1a34558c52769ded61f838,\n            0x15b13d0d6834a8794655db51720dcc9c7b454fb2ff919e52767fed602eaf00ba,\n            0x2802cf4fa69f1bca58dc8197bc3aa601022546375f1503964f33727eb610d03b,\n            0x18c298e8be0426a033d82eb001fe15d623867737ddd036ba66508982d02cc8e0,\n            0x153f39a3285da9162d7bd51d5ce90bf0b6c0c1b56943ef4ea1dbb3e0edba079f,\n            0x09e4d973fe24511b29d3ff119362d6fe3f8c545ba0203b2fc2f5b2332b6af67b,\n            0x183c4791f6af7b260faef4dee944dbd032b7a6b36ce6db1dafe39a68581b05da,\n            0x0fecff05819aef06b229c4c9c45303caab0b6a10ef21b2c78ff4335777a950b4,\n            0x2fd2a822e9dad5b1bbf05c48a646fb3baf8fa569ea56b5095f9932c478b402e9,\n        ])\n            == [\n                0x00e7985063474e552a70ee705434a9cb8ad5fd3332081ca7ea29cc2e04736443,\n                0x0bb32611f7a673adaf873ecf44903c4683fdf054c7991868b60986a3fc2434e1,\n                0x2a34a647e4399d41bd6d56b18455e55472e9a3d0b8891ebebb4cb195f1805818,\n                0x1df3d37d4594605755b6db26c7c491f90b166c97e0e2e272947964a406123931,\n                0x296720f19be76efa3be6247b0cb47b5da39a5720f2da232d48be8898c24c644b,\n                0x2f3d7fe8e710de783b56b53b924e1721d80f2f278fbd4a8237dcef5106054295,\n                0x1163dfa4447a370bf32a35ba50ebe6b891c79ec77eace1c189e7122391dd7692,\n                0x2dee066e4cb642e4c36622c7709d56be8e0d4e085edb8504a03b886e5243d9a2,\n                0x20968bd0e88eddb3223fbaa9a4ade0da528774a350851631400da87726794b29,\n                0x22363da61fcced4f9abdbaa90adaee6fba2971e3a2a0e79a2e6f1677b402bab9,\n                0x2b0b7eb2a75f97a809fa1300193648a3d018fdbf879ad078789190ba39d5eef4,\n                0x0a635c902e1d0e7f0b9200babbc49fe779db22445399e372faab05b95a5b0462,\n                0x2af2db88a9a4093bd91bbef603d279ce7ba9fe39da2fb8e43d8640c123c5e91c,\n                0x0389be83959d40d19b73060cf322298ab5031761f18ae2e8ef537b6ea44ab19b,\n                0x2a77063695be741137fa3933536515607abde3f7704a644f763eb7e609e1a78c,\n                0x191a8fa7d5bbdd528c0ea7878e0c731ece9cc1e6e5cc0a6abaab4ae0caf0f769,\n            ],\n    );\n    assert(\n        x5_16([\n            0x26fcf669c5d648ed59490ddca7bbe354b02b4b3ce3413abf45bcc763632216ad,\n            0x217c47cd62feb6c1858beb1af22a9520f7e7dbcef978235471c0255f789fdc63,\n            0x0c9847f7f873b8730c65861cc42a77de4d2a863b853b146c7ee7e3241d9e9f09,\n            0x2bd4ceea8f15ca63bb3e9a0513fff8e0386ab82a2ff7e58cb42e528f5873ae4a,\n            0x2064aaaf465b56437ae42ef30be0970d48508b9ba52aa11da7bc197ea7762df4,\n            0x03faf493e27a84593a1659730c1c124c9b0dc0c9c4a18db3c72ea927ad14b11d,\n            0x13aac7c7b4ea5d86003dcc4b744a058eeb0ab360447e7ff9c8418f6f6e508cc7,\n            0x1775eec665148054cdaa7657b3389473dae36b6c01ab64f18656ae00de9489b0,\n            0x1901be4b7481ff0c8964fa2c77794b164a2e43aed5e36c2c6ccd8f8191c94873,\n            0x2784dc417a5202f66f681f7d4c356dfb01c9522f8ce5eb63c9fec159f3402c86,\n            0x0f6efebb5fd0520b3daa0097aac54c42314945ec6fc96cf5f2f5aeaa191f652d,\n            0x1dba0aebaef806f37235faa2cf8fbdae9da9763cb3d9a6838fcff82ca527d437,\n            0x163d27405b027e50d35bf55eb6431cb75350ffc44eed52185b403b39d5b30b18,\n            0x030735bcca423d70e78a04a53d3a4e728ad28efdc5ceb2f0628937cdadb0ab5e,\n            0x00543427a4899ec4c8756511dc295bc07839445eff4a448ceb3f0480a9f9585e,\n            0x1235ce720c56b2590126a1057c953bee0810f2c9acb12c4b01bb5d9c2bd9bbd5,\n        ])\n            == [\n                0x2824245824515d822c894f4c63e85aa06e957089b7204e11f1b45b4d0c2a6b93,\n                0x0c4a5cc6128bf7d5b1af586ef4c8e8ec1d3258030df4bf9d8c8f169940a8ab46,\n                0x2cdbbc6158e398a4cdbef4b3bc9c6a8ffad29713423d7130d866fd33e046d76c,\n                0x2feae397ccab260ab856007290e7f08c7f04cd1ceeac8b8c31cca55340550b6e,\n                0x14018fd8912b3e30321df757fb6af8e8aea684f2a41663f1aee7e3cad04fb27d,\n                0x15e89fd27ca5fdbd3cf6b39f4a5515f986554ccbf7bc52803a5c989efe392c55,\n                0x1b8cc493266cf81639c10391213e5f822c348991965bbe07b5c9c3e5f78f677c,\n                0x07453d273cfa90c10d4c8e22c77e5bca6c56c0cae0ae1a324dda13615929e2f4,\n                0x01ed8c8bf6308a7a4edbff5280b09d72a74579c3e1d300cfa1432192c240564b,\n                0x1ac754480d4b218c33d23a9264406d16faf30279c3db2fa2b1e1e9e024ae74e8,\n                0x236c9c959c107f7908a670c8a4df73a6487920f5ad811bf06a1dd2c798d7c88a,\n                0x29bf91f77f69fa46f5d605c5bdb40567070a7b45ef6c30ea9c47249829e75915,\n                0x233cb5f0b7bd3b55b11270311018acdde7b7c61a3bbb2ddecc3c61f10d7080f3,\n                0x22082ab254896b3c8d771dc14c9e834878797a505a5ea83e2b624811ec0ba67e,\n                0x09c5e4ca4cb94aa5cd0006b14b62ee34aa916e69c9f52bad52e6b4c4a3b102f7,\n                0x0b6bafed1b7f470294a95eed0c44cc35c87480f167115cad591995e62c069357,\n            ],\n    );\n    assert(\n        x5_16([\n            0x1f30f9fbd02de3245ffa2a842a35c503836cdf7bd91b7bc81eef191c0ed00d91,\n            0x23ef9c7a64ae98919c4aebd890beef09ff5d1b450e3ed7a690a3e6067755101c,\n            0x0a941ca919639269ce0f274572c3bd82ab586684c14f46d648d7ebeb98795354,\n            0x115ac08664baf4020b32a68d9bf3e040e87c1672954d2601bc477121936ceb0c,\n            0x20b24021688034db1d514a2dc2eb17f02eea63e5805efd68ecebd59783d5c13b,\n            0x1802b6eed394a6f2c054a1b1cbf33c842f97ab9a6ec03fd0aeb1b7cced9077db,\n            0x14ef482e31c50bffcc62b1e4d9013f30df6bc380a2b0896fe4e483b4c18c3990,\n            0x130fa7ff2494fdf702c1fc076fb0315917add56464217960bdcdf17162d8e9fe,\n            0x2ecdfab787c80b25dd05f2ba55f49fc6c7817eeda780e464239c99cfb03e445c,\n            0x100c0d9bf6a2384940dcd88e1553609a9480c032b3be8820a3e534544de505fc,\n            0x1ef6e0c3b8d177b3a13f7af721af9d13d4043ea3ff248d4bc155639fce11867c,\n            0x2c9302b8df110fec10b69a6436f2e7cce058e8fb10de6166f2dc7dcd9e717440,\n            0x242411f186e4dd6761a58a115fc4a12a72afe15ab2a8cba314bb36c3af628485,\n            0x27f6a9b6ae28fbf5ef658e8a8d7548578c2321be2fe7d8e61437358c27313bb1,\n            0x2e6b453486b8154a925a8d8f6343d70e3e7b3cf8ae5f98fe5dad385caf3a5b6d,\n            0x251a976a3bb9b67f9c5ce1633ae24fc78d8556949fe699b89b4a496ca8fd33ca,\n        ])\n            == [\n                0x2f73ecbfd328236b62a0de2f90fda6aa39027d2445904729de2cbb132f04eef7,\n                0x2e3b0e241e80ecb5c94599ef79b36384d50924dd78b29d136a78ba8dd4eac3e4,\n                0x240e35568bcf3d794be5b658207a13f30d3be889e85b735a5658c1e8ad8ecd06,\n                0x08f9a03ac71ded3712140d95fb4d84b6247f6ed3f005edc22c11c5749dcce0bb,\n                0x23d19806e8344c08f772bf1e4e6abb068bbe34f262a9e8e4dd1dd87cccfa76b9,\n                0x1d43aa80b45193c0fd0e0ffc51217feb505c0127558bfc4d60f8640a2f799225,\n                0x22bd86bb51b7941c6aeb8905d680a9f2b5d073cee1d72171aad90ee25f07d2f3,\n                0x21acac96adb169d04127c7ad9074753b49ce0ad68d1ecd4be803c7a7bd75049c,\n                0x2d3ccbacd3110045e3d7dda3a9c0114f03fcbbcefb5bf2b864627fa7e015c026,\n                0x0ecd348155a751f395a2c867f4f82a6e2e6a0e549784c3da3c6defd3ed8d2593,\n                0x17cd880e932fc4490b11b73a32e741052df57fd9b563f94192f0dada59fa7eeb,\n                0x0507ec99efeb586fa4a628563ad4c18d92a9ac3f3b69bbffdaad18c43a37c774,\n                0x22ba5e12ee0de1a7db0cf232639db2006be109a47dfd591f9ad4745844b28985,\n                0x0103ad1ccfccb7097c13a71f89d806294a355a4e0e24e9d7d353fa27a60599ed,\n                0x0a2744a2b3f1a1e9f0e365f195dc7bfb2becce17d346623407b68f2be38e6840,\n                0x1a10bad64f9099c918f1e3a713b34d43c9c8442eca37ac2be2933ef06a85f274,\n            ],\n    );\n    assert(\n        x5_16([\n            0x102aaf737cf6e4eded17a778873de94a33432c19f78c93ff6a438b54503073e6,\n            0x010ccff329d1680eb37dc0a14d1df9ecb51b563fbbe8e02f4b973a6d7c5a3ad9,\n            0x1c80734fefdf741d96d23dd5c9494a69eca35ad4c52e6781fe64fec042a39034,\n            0x1fd6d6a936a506af5a88f4efbcf6bacdaf166e18c1a9d9ec2706097e049a48d8,\n            0x0fcd3cf6478e2303fd67a88e8da308c99c6b034b9d9e8505a5cdb1f1328ac19f,\n            0x00a894f3228b2f40329bce6db4aed140044ca13388fe31dbeb7e920c47626b98,\n            0x05627ce9f83ba4ec21200390b4459d20a841b7b6bff58f54f859746e6a1a5bad,\n            0x1a6d68c2e6da0187cc187f14fd60d574347ee8e3b2e6d5377ca28d1c2126d579,\n            0x0796ff0b481621f97e6205b7098b3f34d9e25ce2a568823d34960d10675abe00,\n            0x1658c8c71f79eb8c1cbed9176d3fced3f102f6f3185c0086ca281621421ea687,\n            0x17b29467b557e95e2c98a68a62ae669bfea7e60f6f4b5c6c748536606f9559dd,\n            0x2db966ef0090e9b6b5e8bb41890ed54469beac546172968de44ac4fe1c91fc57,\n            0x116734a408c7898e7c14361cb189db728557f6cc7bf643ead36f46387e474105,\n            0x278912d4acb55f15c263054ee5961722234b0e8fc257d8afe3f55cd707fa8450,\n            0x2a3dbf10426ec43bd82e1aef23553b695b1a9d2339a99ec299649fdd128c7ffb,\n            0x1431dae2b608ec8aff9dbeabfaef7bbabb7a990241b2d2cb84d2b16b474dbec4,\n        ])\n            == [\n                0x04421416d3b0398c2089bea526a32fb66d78da31fb45bd5f1586fd52303adeb7,\n                0x1d8195ae558ec24145f22963dbe020eb9eb32f9b77993dee1a6651de4e043d6b,\n                0x065012470d069eafbdbe2e9472843e570a6c4bec2bff368a7e5177ace65cd7aa,\n                0x28293baa71d7e924399a38aa199be1886bef192b9bd170f4b5061cc266cce797,\n                0x1bf0bff909c28f440eb3a7b2fb48f3b58d30e7e35126eb4c8eb9dabdf4173caf,\n                0x006e32aafe5fc019cf7f2121640ed5877695317872900b005821e902855cb9e2,\n                0x077ce2784361c15f00bd94be5923b0d423e690a51427b82ac6da1bc3e15ff202,\n                0x04bec35d3bfe48abc26f1b213b37a46a6837ea4ef4c7c66aec7d6ec506b4816e,\n                0x09891cb5c5f97bfb53df6fa616a15454a20d2d9d4b1730b143b80603f1d2ead8,\n                0x2d2049ee1c7ade77d7f24e30d79274e6d4b65e32ca00485efbe7fcabe880ecdf,\n                0x0f3f82629e5571fa2d37501eb2c42ff2532b23dfa8b60a250406aea842752891,\n                0x154b6ac1520182ff79d85376c19f8c622c251762b269deae81db64257c3f8853,\n                0x092ebf535121a0cd3342dbf040e69031c5ee7f73a46cba5d7077cc40f1fe7623,\n                0x2e013478205cbe8b6c9315e2fe24374e6954b13a121f84a046656defd81b6aa7,\n                0x14899d106105b55a748e7b8180c6cc6ce1a1700dd723a182ad421bee03bea38d,\n                0x15a2465a074528248166bd7ab12dd8c1f7b0a523acf560393fb53cad0f9ff4a7,\n            ],\n    );\n    assert(\n        x5_16([\n            0x2c8251563bf2daf3832f54b41e1019e416f097fff0185b8972a24baab0041945,\n            0x1c5af36107dd27a50ed1b7be11fecc96955c940f7d1e8d85c73b55d2a72636cd,\n            0x0c2745de6e816df7564b63085fb2bbfac5b7901f3bea6c06527fc367886f25ff,\n            0x19019d42f79fd8654f69436c8230120b91d81a74a2c54a2b99b65b1104a4f855,\n            0x0beab5f110eba2ed3e125e96f33173ce8c969ab78b3ca023c1bcc765ce5df31f,\n            0x11d9b237b412ffd1a2a9d9ddddcf8eb725222a138a12d7dcfdca0856b2048c89,\n            0x1c448b112e517ee96e6ac2f8593f51ddcfea072bf6ad1d117e9072a8084c6a21,\n            0x095dfcdc5f3bb500206ed7fcd09ce1db8a89087a1767dfadf94b1d4a8719ecff,\n            0x2b83981c4547a9a91ddcf3e3d415c6a229e5b79c0194faa17a79fec0c7656625,\n            0x0dfc540c74084bd916dca0116e701424bbb4255575d997ac0980124380c79cba,\n            0x1ee3fd68c5face1c3bde5cc8a09820cf0d55e20c354006d5a1e7c17502fada01,\n            0x1731821cf372f905084ef42395e5cf7377b8e845539fbe75d431c460efb52f56,\n            0x095dd1057519b92facabf3d1bf4cfd9cfba721f13777ee1b156a94982aa0ea92,\n            0x09d8c656b448b642be7e5ba2820cde88395ee99c1609fc57a10e1a761bcec40e,\n            0x2cefff7d3c2d8de4caa6555ef6fe2d20ea75ab55295cd3d422f1e7706d00265b,\n            0x2af9da783cf3f2cdb98d1d0db2d46b500ab16b22d528c3290f9fa61a16e90c77,\n        ])\n            == [\n                0x045fd3534e4e3a441672b2174823a1b0f2bf33744dcedd04decafac412491ba5,\n                0x2e26d947a155dc04da57a4e2d08ff2789601da31999bd3d2d509ce74336db980,\n                0x252121c4d1f937e2a2bbf228252e3d5970b693269061b30ec67a7f46ce4eb28c,\n                0x13461512448fa47d7c334f17166a9791c79b0c7c744b5ec85b944fbcf3b8b364,\n                0x1e00352c73e0c20163f184f610dbc509b6a60e5b6df8636b2e238ea0867004be,\n                0x2256f5718367f8eb6730eb4a3bb0cc69a539b7c5d2e156212944f2f974693159,\n                0x243fc53f1ef63853cb507d4354c41153690522215a975a3b6bbd3f039ee91f71,\n                0x025aa431a3197a94e85c1390f0ae568c6aff20657428413bd8fd636b5db7e457,\n                0x1932edb2b21bf6cba1f674b00b70f923fee4a222872c1858559a60fe33e7baa9,\n                0x2ea0e86e9b5f04901a072c94cdc9c04c512acbc3da27e41a364ce5d4586166f5,\n                0x1b1c638d7c7637ba8a0732f02aa3666dd61c9aa502bc4bc78f4ce8fcc8c0599b,\n                0x2fabaf28f4bb95ee4f11593906d38519054372938ba6ce3be2a3227064ba5104,\n                0x1ec7790f18b886f8806f9865a1b047532fdde00a429656cb02532a1c77d6ff90,\n                0x28535227e19514f1ab220db019b2933cce0670c1c7439bda9aac0daaf63b086e,\n                0x14226659240668ad038136362481d9b9870d4ad6ab62e73bef74ed2ab66429c2,\n                0x0eae0bc0112d05992ae574f1b33f08f5a5bcd3092a6ec79c917effa908fa511f,\n            ],\n    );\n}\n","path":"/home/code/nargo/github.com/TaceoLabs/noir-poseidon/v0.5.0-beta.0/poseidon2/src/bn254/perm.nr"},"116":{"source":"mod consts;\npub mod perm;\nuse dep::hash_utils;\nuse dep::hash_utils::poseidon;\n\npub struct Poseidon2Bn254Config<let T: u32, let R: u32> {\n    first_full_rc: [[Field; T]; 4],\n    partial_rc: [Field; R],\n    second_full_rc: [[Field; T]; 4],\n}\n\nfn permute_bn254<let T: u32, let R: u32>(\n    mut state: [Field; T],\n    mm_external: fn([Field; T]) -> [Field; T],\n    mm_internal: fn([Field; T]) -> [Field; T],\n    config: Poseidon2Bn254Config<T, R>,\n) -> [Field; T] {\n    state = mm_external(state);\n    for r in 0..4 {\n        state = hash_utils::vec_add(state, config.first_full_rc[r]);\n        state = poseidon::sbox(state);\n        state = mm_external(state);\n    }\n\n    for r in 0..R {\n        state[0] += config.partial_rc[r];\n        state[0] = poseidon::sbox_e(state[0]);\n        state = mm_internal(state);\n    }\n    for r in 0..4 {\n        state = hash_utils::vec_add(state, config.second_full_rc[r]);\n        state = poseidon::sbox(state);\n        state = mm_external(state);\n    }\n    state\n}\n\n#[field(bn254)]\npub fn hash_1(input: [Field; 1]) -> Field {\n    perm::x5_2([input[0], 1])[0]\n}\n\n#[field(bn254)]\npub fn hash_2(input: [Field; 2]) -> Field {\n    perm::x5_2(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_3(input: [Field; 3]) -> Field {\n    perm::x5_3(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_4(input: [Field; 4]) -> Field {\n    perm::x5_4(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_8(input: [Field; 8]) -> Field {\n    perm::x5_8(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_12(input: [Field; 12]) -> Field {\n    perm::x5_12(input)[0]\n}\n\n#[field(bn254)]\npub fn hash_16(input: [Field; 16]) -> Field {\n    perm::x5_16(input)[0]\n}\n","path":"/home/code/nargo/github.com/TaceoLabs/noir-poseidon/v0.5.0-beta.0/poseidon2/src/bn254.nr"},"119":{"source":"use crate::double;\n\n#[field(bn254)]\npub fn sbox<let T: u32>(mut state: [Field; T]) -> [Field; T] {\n    state.map(|x| sbox_e(x))\n}\n\n#[field(bn254)]\npub fn sbox_e(mut x: Field) -> Field {\n    let mut result = x * x;\n    result *= result;\n    result * x\n}\n\n#[field(bn254)]\npub fn mds_2(state: [Field; 2]) -> [Field; 2] {\n    let sum = state[0] + state[1];\n    [sum + state[0], sum + state[1]]\n}\n\npub fn mds_3(state: [Field; 3]) -> [Field; 3] {\n    let sum = state.reduce(|a, b| a + b);\n    let mut ret_val = [0; 3];\n    ret_val[0] = state[0] + sum;\n    ret_val[1] = 2 * state[1] + sum;\n    ret_val[2] = state[2] + sum;\n    ret_val\n}\n\n#[field(bn254)]\npub fn mds_4(mut state: [Field; 4]) -> [Field; 4] {\n    let t_0 = state[0] + state[1];\n    let t_1 = state[2] + state[3];\n    let t_2 = double(state[1]) + t_1;\n    let t_3 = double(state[3]) + t_0;\n    let t_4 = double(double(t_1)) + t_3;\n    let t_5 = double(double(t_0)) + t_2;\n    state[0] = t_3 + t_5;\n    state[1] = t_5;\n    state[2] = t_2 + t_4;\n    state[3] = t_4;\n    state\n}\n","path":"/home/code/nargo/github.com/TaceoLabs/noir-poseidon/v0.5.0-beta.0/hash_utils/src/poseidon.nr"}},"expression_width":{"Bounded":{"width":4}}}