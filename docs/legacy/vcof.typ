=== The Verifiable Consecutive One-way Function (VCOF)

This document describes the rationale behind the Grease VCOF design. Nomenclature references that used in the AuxChannel and Monet papers.

The core idea behind AuxChannel is the Verifiable Consecutive One-way Function (VCOF).  
The VCOF is used to generate new adapter signature offsets for each channel update in that only the party who generated the new offset can compute it, but both parties can verify that it is valid and consecutive to the previous offset.

As such, the VCOF has the following security requirements:

- _validity_:  It requires that for any message, if the encrypted signature is generated by `EncSign`, it should pass through the verification of `EncVerify`. It also requires that for any message, if the encrypted signature generated by the `EncSign` is decrypted by `DecSig`, the resulting signature should pass through the verification of `Verify`.
- _unforgeability_: It is hard to forge a valid encrypted signature for any message from the verification key and encryption key only.
- _recoverability_: Informally speaking, recoverability requires that it is easy to recover a decryption key by knowing the encrypted signature and its original signature.

These requirements are standard for any encrypted signature scheme. There are three additional requirements specific to the VCOF:
- _Consecutiveness_: requires that the decryption encryption key-pair used in the $i^"th"$ update of the VCOF is derived from the decryption key of the $(i − 1)^"th"$ update from `KeyUpdate`, where $i > 0$.
- _Consecutive verifiablity_: Given two encryption keys and the corresponding proof, anyone can be convinced that the two keys are consecutive, meaning that the new encryption key is generated from `KeyUpdate` taking the input of the previous corresponding decryption key.
- _One-wayness_: given the $i^"th"$ decryption key, no one can derive any of the $j^"th"$ decryption keys, where $0 ≤ j < i$. This is important because, without one-wayness, when a channel is closed co-operatively, a malicious counterparty could broadcast _any_ previous channel state to the blockchain by computing some $omega_j$ where $0 <= j < i$.

= Feasible VCOF functions

== SQROOT - the original Monet recommendation

In Monet, the proposed CVES was based on finding square roots of a large composite $N$, where $N = p.q$ is the product of 2 primes.
It satisfies the requirements of the CVES, and is very computationally efficient but
- The security level is lower than that of elliptic curves. To achieve 128-bit security one would need $N$ to be at least 3072 bits long.
- Critically, there is a unavoidable *trusted setup* that brings the two primes together. The nature of the setup depends on several parameters, but typically there is a permanent trust assumption that a majority of the participants will not collude to discover the prime factors of $N$ and break the entire system. This in contract to the Universal setup used in SNARKs where only one party needs to be honest to ensure the integrity of the system.
- The trusted setup would need to be run for _every_ channel, rather than just once. In contrast, PLONK-based SNARKs only require a single universal setup.
- It is not post-quantum secure.

Although this approach is simple and efficient, the impracticalities of having to run an MPC ceremony (which takes on the order of an hour) make this CVES solution a non-starter for Grease.

== CVES using a pairing friendly curve and a quadratic update function

Pairings alone cannot provide a secure `KeyUpdate` function for CVES without additional cryptographic machinery. 

_Any_ algebraic `KeyUpdate` function over finite fields is inherently invertible.

Consider what we need from `KeyUpdate`:
- Must be efficiently computable forward: $dk_(i+1) = F(dk_i)$
- Must be computationally infeasible to compute $dk_i$ from $dk_(i+1)$

Pairings give us:
- Bilinearity: $e(a P, b Q) = e(P, Q)^(a b)$
- Non-degeneracy: e(P, Q) ≠ 1 when P, Q ≠ 0
- Computability: efficient algorithms to compute e

But *none of these properties create a one-way function*. Any relationship expressible through pairings can be reversed using standard algebraic techniques in polynomial time.

When you define $dk_(i+1)$ using any algebraic relationship with $dk_i$ (whether through simple polynomials or pairing operations), you're creating an equation that can be solved for $dk_i$ given $dk_(i+1)$.

For example, suppose we try:
$dk_(i+1) = H(e(dk_i dot GG_1, GG_2))$

Where H is a hash function. This *would* be one-way, but:
- The `ConsProof` would need to verify that $dk_(i+1) = H(e(dk_i dot GG_1, GG_2))$
- But to verify this without revealing $dk_i$, you need a zero-knowledge proof that $dk_(i+1)$ corresponds to the hash of that pairing result.
- This is exactly what SNARKs provide - and there's no pairing-only way to achieve this verification

== Practical Alternatives

=== 1. Hash-Based `KeyUpdate` with SNARK Verification (Recommended)

```
KeyUpdate(dk_i):
    dk_(i+1) = H(dk_i)  // Standard cryptographic hash

ConsProof(dk_i):
    Generate SNARK proof π that:
        1. dk_(i+1) = H(dk_i)
        2. Dk_(i+1) = dk_(i+1)·G₁
        3. Dk'_(i+1) = dk_(i+1)·G₂

ConsVerify(Dk_i, Dk_(i+1), π):
    Verify SNARK proof π
```

This approach:
- Provides true one-wayness from the hash function
- Allows verification through the SNARK
- Maintains all CVES security properties
- Is actually implementable with existing technology
- Can be implemented with a SNARK system that makes use of a universal trusted setup.
- Can be made quantum-resistant by trading off performance for post-quantum resistant algorithms.