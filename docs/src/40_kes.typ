// Preamble
#import "@preview/note-me:0.5.0": *
#import "metadata/nomenclature.typ": *
#import "metadata/front-matter.typ": algo

= The Key Escrow Service (KES) Design <kesDesign>

== Introduction

In short, the KES will hold an encrypted secret, #w0, from each of 2 parties. Either party can request their counterpart's secret if certain
conditions are met.

Therefore the KES needs a keypair for each channel (#kg, #Pg) under which both parties can encrypt their secrets and send it to the KES for
safe-keeping using `EncryptMessage` (@encM). If the unlock conditions are satisfied, the KES can decrypt #w0 and send it to the claimant.

The KES only participates in the channel during the initialization, force-close and, dispute stages. It is not active in the update and
co-operative close phases. The KES also has an optional cleanup step after a channel has closed. @kes-stages summarizes the KES' role
throughout the channel lifecycle.

#figure(
  caption: "The role of the KES during the channel lifecycle",
  kind: table,
  table(
    columns: 3,
    table.header([*Stage*], [*KES required*], [*KES role*]),
    [Initialization], [Yes], [Securely store #w0 for each party.],
    [Update], [No], [],
    [Co-operative close], [No], [],
    [Closed], [Recommended], [Discard #w0 and other cleanup.],
    [Force Close], [Yes], [Deliver counterparty #w0 after dispute window closes.],
    [Dispute], [Yes], [Deliver #w0 to counterparty if dispute conditions are satisfied.],
  ),
) #label("kes-stages")


== Preliminaries

Let $GG_1$ and $GG_2$ be two additive groups of points on elliptic curves $EE_1$ and $EE_2$, respectively.

$EE_1$ is defined over a prime finite field $"GF"_1(p_1)$, with $p_1$ a large prime. Let $N_1$ be the size of the group generated by the
Generator point, $G_1$ for group $GG_1$, such that $N_1.G equiv cal(O)$.

$EE_2$ is a SNARK-friendly curve and is similarly defined.

#H2F([...]) is a one-way function under the random oracle assumption that hashes the binary representation of its input to a scalar element
in the group order. Domain separation and other hygiene considerations are assumed to be properly taken care of.

Similarly, #H2P([...]) is a one-way function under the random oracle assumption that hashes the binary representation of its input to a
group element in $GG$.

The KES can utilize $EE_1$, $EE_2$, or both, depending on where it's deployed and which dispute resolution option (@forceClose) is selected.
The VCOF utilizes a ZK-SNARK, and will therefore utilize $EE_2$.

In Grease, $EE_1$ is always Curve25519@curve25519, the curve behind Monero. $EE_2$ can be any suitable curve. For the reference
implementation of Grease, $EE_2$ is the BabyJubJub curve.

#algo(
  caption: [The `EncryptMessage` algorithm.],
  title: [`EncryptMessage`. $P = k dot.c G$ is the recipient's public key. $m$ is a scalar to be encrypted],
  [
    + $(R, chi) = "EncryptMessage"(m, P, GG, FF)$
    + Select random scalar element, $r$ where $0 < r < N$.
    + Calculate:
      + $R = r dot.c G$
      + $P_s = r dot.c P (equiv r k dot.c G)$
      + $s = H2F(P_s)$
      + $chi = (m + s) mod N$
    + Return $(R, chi)$.
  ],
)<encM>

#algo(
  caption: [The `DecryptMessage` algorithm.],
  title: [`DecryptMessage`. $P = k dot.c G$ is the recipient's public key. $m$ is the encrypted scalar],
  [
    + $m = "DecryptMessage"(R, chi, GG, FF)$
    + Calculate:
      + $P_s = k dot.c R (equiv r k dot.c G)$
      + $s = H2F(P_s)$
      + $m = (chi - s) mod N$
    + Return $m$.
  ],
)<decM>

== Global keys

We denote the curve that the KES operates on (whether $EE_1$ or $EE_2$) as $EE_K$.

On creation, the KES creates a new, master keypair $(#kk, #Pk)$ on $EE_K$. $#Pk$ is made available publicly.

== Channel Encryption keys <channelKeys>

When a merchant-customer pair create a new channel, they create an ephemeral channel id secret on $EE_K$, #chs, using @ecdh-mc.

1. The merchant (or customer, it doesn't matter) then encrypts #chs to the KES using `EncryptMessage` (see @encM) on $EE_K$.
2. The KES calculates the unique channel keypair for $EE_K$:

  $
    #kg = #chs dot.c #kk \
    #Pg = #kg dot.c G
  $
3. The KES shares #Pg with both parties.
4. *Critical*: The KES discards #chs.

#algo(
  caption: [Diffie-Hellman shared secret derivation for new channels],
  title: [`ECDH-MC`],
  [
    + $k_s = hat(k)_a hat(P)_b (equiv hat(k)_b hat(P)_a)$ on $EE_K$
    + $chs arrow.l #H2F([$k_s$, channel_id])$ on $EE_K$
    + $P_chs arrow.l chs dot.c G$ on $EE_K$
  ],
) #label("ecdh-mc")

#important[$hat(k)_a$ *must* be chosen at random for _every_ new channel a party creates. Failure to do so may result in loss of funds.]

Even though $hat(k)_a$ must be unique for every channel opening, clients do not have to store a large database of keys (although they can).
One could use a *master key*, $k_a$ and derive unique channel keys using a simple deterministic scheme,
$ hat(k)_a = H2F("k_a, channel_id") $

Since the channel id is already a function of the counterparty public keys, the initial balances, and a nonce, it will be unique for each
channel.

=== Security properties
The channel keys have the following properties:
- If #kg becomes compromised, the channel is compromised, but other current and future channels are still safe, since the attacker does not
  know #chs for the other channels.
- If #kk becomes compromised, channels are _still_ safe, as long as the #chs for any given channel is unknown. This is why is it critical to
  discard #chs after deriving the keys. While the damage would be contained, a compromised #kk is incredibly serious and would require the
  KES to start afresh with a new master keypair and inform all parties to close open channels immediately.

== Communication with the KES

Either, or both parties can carry out the communication duties with the KES, since none of the communication protocols with the KES require
trust between the counterparties. Every protocol provides sufficient cryptographic proof that the steps were completed correctly.

A working assumption is that the Merchant typically has more reliable internet access and possesses a more powerful machine (typically a
server) than the Customer (typically a mobile phone).

Thus, for the sake of brevity, it is assumed that the Merchant acts as proxy for all KES communications. But it is certainly possible for
the Customer, or both parties to perform the same tasks, with the same, idempotent result.

== Channel Initialization

The Merchant (M) and Customer (C) partially sign a 2-of-2 multisig transaction with an adaptor signature. Either party needs to know their
counterpart's adapter signature offset, #w0 to complete the signature and spend the funds out of the multisig wallet, thus closing the
channel.

The primary role of the KES during channel initialization is to store the encrypted #w0 values for each party. The full procedure for
calculating #w0 is described in @initProtocol.

It is important to note that the adapter signature offsets, $w0^C$ and $w0^M$ and their corresponding points, $#PubWEd(0)^C$ and
$#PubWEd(0)^M$ are elements of $EE_1$, the Ed25519 curve. For the KES to work with them, they need to be translated onto $EE_K$.

The offsets are chosen such that they are valid scalars on both curves, that is
$ 0 < w0 < min(N_1, N_2) $

The group element on $EE_1$ corresponding to #w0 is #PubWEd(0), while the corresponding point on $EE_K$ is denoted $PubWBjj(0)$. A summary
of the points and their equivalents is given in @curveCorresp.

#note[
  It is possible that $EE_K$ is also Curve25519. This does not change the requirements or procedures. However, many things are much simpler.
  The DLEQ proofs are trivial, for instance.
]

=== What the parties send to the KES
Each party computes a discrete-log equivalence proof (DLEQ), $DleqP_0$ that proves that $PubWEd(0)$ and $PubWBjj(0)$ are generated from the
same scalar, #w0.

The Customer encrypts $w0_C$ to the KES using `EncryptMessage` (@encM) and sends the following package to the Merchant:

- the encrypted offset, $chi_C$
- The channel id, `id` (@channelId),
- The Customer's public key, #Pc,
- The length of the dispute window, `dw` in seconds. The default is 86,400 (24hrs),
- A payload signature signing `id`, $chi_C$, `dw`, and $PubWBjj(0)^C$ with $hat(k)_a$
- The DLEQ proof, $DleqP_0^C$.

The merchant validates $DleqP_0^C$ and forwards the rest of the package to the KES.

The Merchant performs the analogous tasks and forwards both his and the customer's data to the KES. He also sends his DLEQ proof,
$DleqP_0^M$ to the Customer, who validates it.

=== What the KES send back to parties

Once the KES has received both packages, it performs the validation procedure outlines in @validateOpen

#algo(
  title: [Open Channel validation],
  caption: [The KES validates each new channel request, returning proofs of knowledge if successful.],
  [
    + Validate the payload signatures.
    + Decrypt $chi_C -> w0^C$ and $chi_M -> w0^M$.
    + Are dispute windows, `dw`, values equal?
      + No? *Return* Fail(`InvalidConfiguration`)
    + Store an `OpenChannel` record in private/encrypted storage.
    + Calculate proof-of-knowledge proofs, $PokP_C$ and $PokP_M$, for $#w0^C$ and $#w0^M$ respectively, using the per-channel key #kg (not the global key #kk).
    + Send the PoK proofs to the Merchant and/or Customer.
    + Discard $w0^C$ and $w0^M$.
  ],
) #label("validateOpen")

=== `OpenChannel` record <openChannel>

`OpenChannel` records the state the KES needs to carry out its duties for every channel:
- The channel id, `id`
- The dispute window, in seconds (default: 86,400)
- The proofs-of-knowledge, $PokP_C$ and $PokP_M$
- The merchant public key, #Pm and encrypted initial offset $chi^M$,
- The customer public key, #Pc and encrypted initial offset $chi^C$,

#caution[
  Don¬¥t store any other metadata, initial balances or anything else that would reduce privacy and increase attack surface.
]

#important[
  Notwithstanding other checks that are required, a party *must not* allow channel opening to proceed without verifying both PoK proofs. For
  the most part, the Customer can proxy communication with the KES through the merchant, but it is *recommended* that the Client at least
  queries the KES directly to obtain these proofs.

  Note that to verify the PoKs, parties only need the KES global public key #Pk, since the per-channel public key is simply $#Pg = #chs dot.c #Pk$.
]

=== Failure scenarios

The Customer trusts the Merchant to relay messages to the KES faithfully. Let's examine scenarios where this breaks down:

- The Merchant never relays any messages: The Customer never receives a PoK for #w0 and refuses to sign the channel opening.
- The Merchant uses a different KES that he controls: The KES cannot decrypt $chi_C$, since it is encrypted to the initially agreed-upon
  KES.
- The KES colludes with the merchant and gives him $#w0^C$: *Failure*: This allows the Merchant to spend all funds out of the multisig
  wallet. This is a known failure mode in both Grease and AuxChannel. if the KES operates as a trusted third party, then the risk of
  collusion is governed by that degree of trust. It is preferable therefore to have the KES deployed as a publicly auditable contract on a
  Zero-Knowledge blockchain. The keys can be stored according to the procedure described above without revealing their values and collusion
  then requires subverting the entire blockchain.
- The Merchant follows the procedure as described, except that it withholds the PoKs from the Customer and immediately triggers a
  force-close: After the dispute window ends, the channel closes, allowing the return of just the original balances to each party. The
  Merchant is unable to construct any valid Monero transaction besides reversing the original funding transaction.
- The Merchant follows the procedure as described, except that it withholds the PoKs and goes offline indefinitely: The Customer, after some
  timeout period, can query the KES directly, retrieve the PoKs, and trigger a force-close herself. She can get her funds back after the
  dispute window closes.


#figure(
  caption: [Equivalent curve points in grease],
  table(
    columns: 4,
    table.header([*scalar*], [*$EE_1$*], [*$EE_2$*], [*Label*]),
    [#w0], [#PubWEd(0)], [#PubWBjj(0)], [Initial adapter signature offset],
  ),
)<curveCorresp>


== Channel Force Close <channelForceClose>

=== The original Monet/AuxChannel proposal

Suppose Bob ($P_B$) wants to close the channel at state $i$, but Alice ($P_A$) is unresponsive.

1. Bob posts a "trigger transaction" to the KES smart contract on L2. This transaction includes his decryption key $k_(d i)^B$, the state
  index $i$, and the L2 signatures $sigma_i^('A), sigma_i^('B)$. This starts a timer.

2. Alice has a time window to react. She has two options:
  - *If state $i$ is the latest, correct state:* She cooperates by posting a "release transaction", revealing her decryption key
    $k_(d i)^A$. Bob can then use this key to recover Alice's signature and close the channel on L1. This option has the same outcome as the
    co-operative close but with the added overhead of involving the KES and paying L2 gas fees. It is significantly cheaper for Alice and
    Bob to co-operate.
  - *If state $i$ is outdated (e.g., Bob is trying to use an old state):* Alice posts an "update transaction" on L2, where $j > i$ is the
    actual latest state index. This transaction proves that Bob's claim is stale. To verify the proof, the KES is required to execute the
    VCOF $j-i$ times to verify Alice's claim. Depending on the nature of the L2 this may or may not be an expensive operation.

3. *Timeout:* If Alice does not respond within the time window, the KES contract automatically releases her *initial* decryption key
  $k_(d 0)^A$ on L2.

4. *Resolution:*
  - If Alice released $k_(d i)^A$, Bob can close the channel at state $i$.
  - If the KES released $k_(d 0)^A$, Bob can use the `KeyUpdate` function to sequentially derive all subsequent keys
    $(k_(d 1)^A, ..., k_(d i)^A)$ up to the state he claimed. He can then recover Alice's signature for state $i$ and close the channel.
    This mechanism also acts as a punishment: if Alice was the malicious party trying to force an old state, Bob can now use her released
    initial key to derive the decryption key for any *later* state $j > i$ that is favorable to him, and close the channel at that state,
    stealing her funds.

Grease deviates from this original design in several ways:
- No transactions are shared with the KES. These are replaced with simple digitally-signed state messages.
- The protocol is generalized with the introduction of the channel id. This permits all parties to handle multiple concurrent channels.
- The dispute process uses a simple update count to significantly reduce the computational load on the KES.

== Force-closing in Grease <forceClose>

=== Summary

Either party in the channel, the _claimant_, can trigger a force-close at any time. In short, the claimant informs the KES about the intent
to force close, along with the current update count of the channel, $n$.

If the claim is valid, the KES starts the dispute window. If the counterparty, the _defendant_, has not presented a dispute proof before the
window closes, the KES either

- encrypts and sends the defendant's #w0 to the claimant (Option I).
- calculates the signature offset, $wn_n$ and sends it to the claimant (Option II).

The data the claimant receives is a configuration option and is specific to the KES. In general, if the VCOF is very fast and cheap for the
KES, then consider Option II. Otherwise, default to Option I. The biggest benefit of Option I combined with the dispute resolution
improvement of the Grease protocol over AuxChannel is that the KES can be completely ignorant of the VCOF.

#important[The Grease design allows the KES to be completely independent and ignorant of the VCOF.]

This is extremely useful if generating ZK-SNARKS on the KES platform is impossible, or very expensive. It also allows us to upgrade the VCOF
on channels without having to change KES executables, which on blockchains is a non-trivial exercise.

A more detailed description of the process is is given in the following sections.

=== Force-close procedure

If a claimant wishes to initiate a force close they send a `ForceCloseRequest` message to the KES which triggers an
`onForceCloseRequestEvent` event. The KES responds to the request event with the `HandleForceCloseRequest` procedure, outlined in
@handleForceCloseRequest.

#algo(
  caption: [The KES `HandleForceCloseRequest` algorithm.],
  title: [`onForceCloseRequestEvent(req: ForceCloseRequest)`:],
  [
    + Validates the signature in `req`.
    + *if* valid:
      + Fetch the `OpenChannel` (@openChannel) record with `id == req.id` => `channel`
      - (_Only allow channel parties to initiate a force-close_)
      + *if* `exists(channel) && req.Pc in [channel.Pa, channel.Pb]`:
        + Create a new `PendingChannelClose` entry with `status = Pending` .
        + try to send a copy of the `PendingChannelClose` to the counterparty.
        + return Ok(`ForceCloseResponse`)
      + *else*
        + return Fail(`FailReason`)
    + *else*
      + return Fail(`InvalidSignature`)
  ],
)<handleForceCloseRequest>

The claimant can follow up with a `ClaimChannelRequest` message after the dispute window has closed. When the KES receives a
`ClaimChannelRequest`, it triggers an `OnClaimChannelEvent` event.

The KES responds to this event with the `HandleClaimChannelRequest` algorithm, @handleClaimChannelRequest.

#algo(
  caption: [The KES `HandleClaimChannelRequest` algorithm.],
  title: [`OnClaimChannelEvent(req: ClaimChannelRequest)`:],
  [
    + Validates the signature in `req`.
    + *if* valid:
      + Fetch `PendingChannelClose` where `id == req.id` => `pending`
      + *if* `!exists(pending)` *return* Fail(No such channel)
      + *if* `req.claimant != pending.req.claimant` *return* Fail(Unauthorized)
      + *if* current time $>=$ pending.expiry
        + pending.req.defendant $arrow.double P_d$
        + pending.req.claimant $arrow.double P_c$
        + using @decM, decrypt $chi$ for `pending.offsets` where public key is $P_c$ and $arrow.double w0$.
        + Case claim option:
          + Option I: $w0 arrow.double wn$
          + Option II: using @vcof for n = `pending.req.update_count_claimed`, calculate $wn_n arrow.double wn$
        + encrypt $wn$ for $P_c arrow.double chi_c$ using @encM
        + update `pending`, set `status` to `ForceClosed`, add `(Pc, ùùåc, n)` to `chi`
        + try send $chi_c$ to claimant
      + *else return* Fail("Dispute window still open")
    + *else return* Fail(`InvalidSignature`)
  ],
)<handleClaimChannelRequest>

Finally when the KES receives an `AckChannelClaimedEvent(channel_id)` signed by $P_c$ it can permanently delete the corresponding
`PendingChannelClose` record. It can also perform any other cleanup relating to the channel. At this point, the channel is closed and no
trace of it remains on the KES.

=== `ForceCloseRequest` message <forceCloseRequest>

A party sends a `ForceCloseRequest` message to initiate the force-close process.

```rs
pub struct ForceCloseRequest<Curve> {
  /// The globally unique channel id
  channel_id: ChannelId,
  /// The public key of the party initiating the force close, $P_c$.
  claimant: PublicKey,
  /// The public key of the counterparty, $P_d$,
  defendant: PublicKey
  /// The most recent claimed state update count
  update_count_claimed: u64,
  /// A signature under $P_a$ for `id | update_count_claimed | Pc | Pd"
  signature: SchnorrSignature,
}
```

=== `PendingChannelClose` message <pendingChannelClose>

The KES must track all channel that are under dispute.

```rs
pub struct PendingChannelClose {
  /// The globally unique channel id
  channel_id: ChannelId,
  /// A timestamp for when the dispute window closes
  expiry: u64,
  /// Initial offsets (encrypted)
  chi0: Vec<(PublicKey, EncryptedOffset)>
  /// A copy of the close request that intitiated the dispute
  req: ForceCloseRequest
  /// The status of the force-close channel
  status: PendingCloseStatus
  /// Encrypted offsets available for parties to close the channel
  chi: Vec<(PublicKey, EncryptedOffset, UpdateCount)>
}
```

```rs
pub enum PendingCloseStatus {
  /// The channel is pending force-closure and the dispute window is open.
  Pending,
  /// The dispute window is closed, and the channel is claimable by the claimant
  Claimable,
  /// The channel is abandoned. It is now claimable by either party
  Abandoned,
  /// The channel was closed via consensus and X value(s) are available for download.
  ConsensusClosed,
  /// The channel was claimed via force close,
  ForceClosed,
  /// The channel was claimed after being abandoned
  AbandonedClaimed,
  /// The channel was closed after a successful dispute
  DisputeSuccessful,
}
```

=== `ClaimChannelRequest` message <claimChannelRequest>

Once the dispute window has closed a claimant can claim their counterpart's #w0 with a `ClaimChannelRequest` message:

```rs
pub struct ClaimChannelRequest {
  /// The globally unique channel id
  channel_id: ChannelId,
  /// The public key of the claimant, `P_c`
  claimant: PublicKey,
  /// A signature under $P_c$ for `id | Pc`"
  signature: SchnorrSignature
}
```

The KES responds to a `ClaimChannelRequest` message by triggering an `onClaimChannelRequestEvent` event. It is handled by
`handleClaimChannelRequest` as described in @handleClaimChannelRequest.



A `ClaimAbandonedChannelRequest` message is identical to `ClaimChannelRequest`. However, its semantics are different:
- Either claimant *or* defendant may sign a `ClaimAbandonedChannelRequest` message.
- The KES will only allow the claim if if `current_time >= pending.expiry + req.dw`, i.e. typically an additional 24 hours after the dispute
  window closes.
- After a successful claim, `pending.status` is set to `AbandonedClaimed`.

This message handles the case where a merchant has initiated a force-close but then has stopped responding. Without the ability to claim an
abandoned channel, Alice has no way to recover her funds.

In summary, the various windows during the dispute phase are:

#table(
  columns: 3,
  [*Time*], [*Valid signers*], [* Valid Messages*],
  [$t_"close" arrow.long$], [No-one. Dispute window], [],
  [$t_"close" + "dw" arrow.long$], [Claimant], [`ClaimChannelRequest`],
  [$t_"close" + 2"dw" arrow.long t_D$], [Either], [`ClaimChannelRequest` (Claimant)\ `ClaimAbandonedChannelRequest` (Either)],
  [$t_D arrow.long infinity$], [No-one. Record deleted],
)

#note[In the "abandoned" window, that is, between the closing of the dispute window and the record deletion (@cleanup), the claimant can
  claim the channel using either type of message, but it is recommended to use `ClaimChannelRequest`.]

#figure(include "../diagrams/channel_dispute_sequence.md", caption: [The channel dispute sequence]) <channel_dispute_sequence>

== Channel Dispute

Once a party (the defendant) becomes aware that there is a force-close in progress on one of her channels, she can:
1. Dispute the force close, and submit the data that would have closed the channel co-operatively,
2. Dispute the force close, proving a more recent channel state than the force-close state,
3. Do nothing and let the dispute window close.

=== Force close with consensus state

If Alice cannot prove a more recent state, under Option II, she can choose to do nothing at no cost to herself.

Under Option I, if there exists a prior channel state that is more disadvantageous to her than the claimed closing state, Alice is
incentivized to publish a `ConsensusCloseRequest` (@consensusCloseRequest) which will close the channel in the state submitted by Bob in the
`ForceCloseRequest`.

#note[It is strictly more expensive and time-consuming for both parties to close a channel under consensus rather than a co-operative close
  (@coopClose), with exactly the same result.]

When the KES receives a `ConsensusCloseRequest` message, it triggers an `onConsensusCloseRequestEvent` which leads to the
`handleConsensusCloseRequest` methods carrying out @consensusClose.

==== `ConsensusCloseRequest` message <consensusCloseRequest>

The defendant submits a signed $chi_n$ to allow the claimant to complete the refund transaction under the `update_count_claimed` in their
`ForceCloseRequest`.

```rs
pub struct ConsensusCloseRequest {
  /// The globally unique channel id
  channel_id: ChannelId,
  /// The public key of the party initiating the force close, `P_c`
  claimant: PublicKey,
  /// The public key of the counterparty, $P_d$,
  defendant: PublicKey
  /// The most recent claimed state update count
  update_count_claimed: u64,
  /// The encrypted offset for state n, chi_n
  encrypted_offset: Scalar,
  /// A signature under $P_d$ for `id | update_count_claimed | Pa | Pb"
  signature: SchnorrSignature,
}
```

#algo(
  caption: [Resolving a channel force-close via consensus],
  title: [`handleConsensusCloseRequest(req: ConsensusCloseRequest)`],
  [
    + if `!req.signature` valid, *return* Fail(`Unauthorized`)
    + if `exists(req.channel_id)` in `PendingChannelClose` records as `p`:
      + if `p.defendant != req.defendant` or `p.claimant != req.claimant`, *return* Fail(`Invalid`)
      + if `p.update_count_claimed != req.update_count_claimed`, *return* Fail(`Invalid`)
      + Decrypt `req.encrypted_offset` $arrow wn_n$ (@decM), else *return* Fail(`Invalid`)
      + Encrypt $wn_n arrow chi_n^D$ under $P_D$ (@encM)
      + Update `p`: set `p.chi_D =` $chi_n^D$, `p.status = ConsensusClosed`
      + Try send $chi_n^D$ to defendant.
    + else *return* Fail(`NotFound`)


  ],
) #label("consensusClose")

=== Dispute with recent state proof

The #link(label("forceCloseRequest"))[`ForceCloseRequest` message] contains a signature from both parties signing the update count. This is
the same information that parties exchange on _every_ channel update. Therefore, it is now very straightforward for the KES to verify a
dispute.

1. Alice provides a `DisputeChannelState` message with an `UpdateRecord` that has been signed by Bob:

```rs
pub struct DisputeChannelState {
  /// The globally unique channel id
  channel_id: ChannelId,
  /// The public key of the claimant, $P_c$
  claimant: PublicKey,
  /// The public key of the defendant, $P_d$,
  defendant: PublicKey
  /// The channel update count
  update_count: u64,
  /// Other data not relevant to the KES, but included in the signed message
  ...
  /// A signature under $P_b$ for `id | update_count | Pa | Pb | ..."
  update_record: SchnorrSignature,
  /// This record signed by the defendant
  signature: SchnorrSignature,
}
```

The KES makes the following checks:
1. `update_count` > `n_claimed`, i.e. that Alice's proof is for a more recent state than Bob's force-close request.
2. $P_a$ and $P_b$ are identical in both the force-close request and dispute channel state messages.
3. The `signature` in the dispute channel state message is valid and signed by the defendant.
4. The `update_record` signature is valid and signed by the claimant.

If all checks pass, the KES decrypts $#w0^B$ with @decM, encrypts it to $P_A$ using @encM and sends the encrypted $w0^B$ to Alice.

=== Do Nothing

Alice can do nothing, in which case the dispute window will eventually close and Bob can claim the missing signature offset via
@handleClaimChannelRequest.

== Channel cleanup <cleanup>

=== After co-operative close
- The merchant will deliver proof that the channel has closed. This proof consists of a `ChannelClose` message corresponding to the channel
  with id `id` signed by each of the Merchant and Customer.
- If, and only if, both signatures are valid, the KES *must*
  - destroy all data associated with channel `id` insofar as it is possible.
  - return any resources (e.g. deposits or collateral) belonging to either party that were being held as part of the KES, net of any fees
    associated with maintaining the KES.

=== Hygiene

To maximize privacy, the KES will delete old channels after a reasonable storage period. $t_D$ is configurable by the KES, but should
typically be one month after the claim period starts, i.e.
$ t_D = #raw("expiry") + 2#raw("dw") + #raw("one_month") $
Periodically, the KES will scan all records in `PendingChannelClose` and
- delete all records where `current_time` > $t_D$
- where `current_time > expiry + 2dw`, set `status = Abandoned`
- where `current_time > expiry + dw`, set `status = Claimable`

== Utility functions

The KES must also expose the following utility functions:

- `getChannelDefinition(channel_id, auth)`
- `getPendingClose(channel_id, auth)`

This allows the customer to query the channel lifecycle independently of the merchant. In both cases authorization consists of a Schnorr
signature signing the channel id and requester's public key.

- If the signature is valid, but the channel record does not exist, the KES returns "Not found".
- If the signature is invalid, the KES returns "Unauthorized".
- If the channel record exists, *and* the signer's public key is recorded in the record, return the record. Otherwise return "Not found".
